// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: import_sstpb.proto

package import_sstpb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	brpb "github.com/pingcap/kvproto/pkg/brpb"
	encryptionpb "github.com/pingcap/kvproto/pkg/encryptionpb"
	errorpb "github.com/pingcap/kvproto/pkg/errorpb"
	kvrpcpb "github.com/pingcap/kvproto/pkg/kvrpcpb"
	metapb "github.com/pingcap/kvproto/pkg/metapb"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SwitchMode int32

const (
	SwitchMode_Normal SwitchMode = 0
	SwitchMode_Import SwitchMode = 1
)

// Enum value maps for SwitchMode.
var (
	SwitchMode_name = map[int32]string{
		0: "Normal",
		1: "Import",
	}
	SwitchMode_value = map[string]int32{
		"Normal": 0,
		"Import": 1,
	}
)

func (x SwitchMode) Enum() *SwitchMode {
	p := new(SwitchMode)
	*p = x
	return p
}

func (x SwitchMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SwitchMode) Descriptor() protoreflect.EnumDescriptor {
	return file_import_sstpb_proto_enumTypes[0].Descriptor()
}

func (SwitchMode) Type() protoreflect.EnumType {
	return &file_import_sstpb_proto_enumTypes[0]
}

func (x SwitchMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SwitchMode.Descriptor instead.
func (SwitchMode) EnumDescriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{0}
}

type DownloadRequestType int32

const (
	// For the compatibility with old version of TiDBs
	DownloadRequestType_Legacy DownloadRequestType = 0
	// For the TiDBs with newer versions that support keyspace feature.
	DownloadRequestType_Keyspace DownloadRequestType = 1
)

// Enum value maps for DownloadRequestType.
var (
	DownloadRequestType_name = map[int32]string{
		0: "Legacy",
		1: "Keyspace",
	}
	DownloadRequestType_value = map[string]int32{
		"Legacy":   0,
		"Keyspace": 1,
	}
)

func (x DownloadRequestType) Enum() *DownloadRequestType {
	p := new(DownloadRequestType)
	*p = x
	return p
}

func (x DownloadRequestType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DownloadRequestType) Descriptor() protoreflect.EnumDescriptor {
	return file_import_sstpb_proto_enumTypes[1].Descriptor()
}

func (DownloadRequestType) Type() protoreflect.EnumType {
	return &file_import_sstpb_proto_enumTypes[1]
}

func (x DownloadRequestType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DownloadRequestType.Descriptor instead.
func (DownloadRequestType) EnumDescriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{1}
}

type Pair_OP int32

const (
	Pair_Put    Pair_OP = 0
	Pair_Delete Pair_OP = 1
)

// Enum value maps for Pair_OP.
var (
	Pair_OP_name = map[int32]string{
		0: "Put",
		1: "Delete",
	}
	Pair_OP_value = map[string]int32{
		"Put":    0,
		"Delete": 1,
	}
)

func (x Pair_OP) Enum() *Pair_OP {
	p := new(Pair_OP)
	*p = x
	return p
}

func (x Pair_OP) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Pair_OP) Descriptor() protoreflect.EnumDescriptor {
	return file_import_sstpb_proto_enumTypes[2].Descriptor()
}

func (Pair_OP) Type() protoreflect.EnumType {
	return &file_import_sstpb_proto_enumTypes[2]
}

func (x Pair_OP) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Pair_OP.Descriptor instead.
func (Pair_OP) EnumDescriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{21, 0}
}

type SuspendImportRPCRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// whether to suspend new imports.
	ShouldSuspendImports bool `protobuf:"varint,1,opt,name=should_suspend_imports,json=shouldSuspendImports,proto3" json:"should_suspend_imports,omitempty"`
	// the duration of import service suspension
	// when should_deny_imports is false,
	// this won't take effect.
	DurationInSecs uint64 `protobuf:"varint,2,opt,name=duration_in_secs,json=durationInSecs,proto3" json:"duration_in_secs,omitempty"`
	// The identifier for the caller.
	Caller        string `protobuf:"bytes,3,opt,name=caller,proto3" json:"caller,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SuspendImportRPCRequest) Reset() {
	*x = SuspendImportRPCRequest{}
	mi := &file_import_sstpb_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SuspendImportRPCRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SuspendImportRPCRequest) ProtoMessage() {}

func (x *SuspendImportRPCRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SuspendImportRPCRequest.ProtoReflect.Descriptor instead.
func (*SuspendImportRPCRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{0}
}

func (x *SuspendImportRPCRequest) GetShouldSuspendImports() bool {
	if x != nil {
		return x.ShouldSuspendImports
	}
	return false
}

func (x *SuspendImportRPCRequest) GetDurationInSecs() uint64 {
	if x != nil {
		return x.DurationInSecs
	}
	return 0
}

func (x *SuspendImportRPCRequest) GetCaller() string {
	if x != nil {
		return x.Caller
	}
	return ""
}

type SuspendImportRPCResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The last state before this RPC.
	AlreadySuspended bool `protobuf:"varint,1,opt,name=already_suspended,json=alreadySuspended,proto3" json:"already_suspended,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SuspendImportRPCResponse) Reset() {
	*x = SuspendImportRPCResponse{}
	mi := &file_import_sstpb_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SuspendImportRPCResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SuspendImportRPCResponse) ProtoMessage() {}

func (x *SuspendImportRPCResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SuspendImportRPCResponse.ProtoReflect.Descriptor instead.
func (*SuspendImportRPCResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{1}
}

func (x *SuspendImportRPCResponse) GetAlreadySuspended() bool {
	if x != nil {
		return x.AlreadySuspended
	}
	return false
}

type SwitchModeRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mode          SwitchMode             `protobuf:"varint,1,opt,name=mode,proto3,enum=import_sstpb.SwitchMode" json:"mode,omitempty"`
	Ranges        []*Range               `protobuf:"bytes,2,rep,name=ranges,proto3" json:"ranges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwitchModeRequest) Reset() {
	*x = SwitchModeRequest{}
	mi := &file_import_sstpb_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwitchModeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwitchModeRequest) ProtoMessage() {}

func (x *SwitchModeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwitchModeRequest.ProtoReflect.Descriptor instead.
func (*SwitchModeRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{2}
}

func (x *SwitchModeRequest) GetMode() SwitchMode {
	if x != nil {
		return x.Mode
	}
	return SwitchMode_Normal
}

func (x *SwitchModeRequest) GetRanges() []*Range {
	if x != nil {
		return x.Ranges
	}
	return nil
}

type SwitchModeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwitchModeResponse) Reset() {
	*x = SwitchModeResponse{}
	mi := &file_import_sstpb_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwitchModeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwitchModeResponse) ProtoMessage() {}

func (x *SwitchModeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwitchModeResponse.ProtoReflect.Descriptor instead.
func (*SwitchModeResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{3}
}

type GetModeRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetModeRequest) Reset() {
	*x = GetModeRequest{}
	mi := &file_import_sstpb_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetModeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetModeRequest) ProtoMessage() {}

func (x *GetModeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetModeRequest.ProtoReflect.Descriptor instead.
func (*GetModeRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{4}
}

type GetModeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mode          SwitchMode             `protobuf:"varint,1,opt,name=mode,proto3,enum=import_sstpb.SwitchMode" json:"mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetModeResponse) Reset() {
	*x = GetModeResponse{}
	mi := &file_import_sstpb_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetModeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetModeResponse) ProtoMessage() {}

func (x *GetModeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetModeResponse.ProtoReflect.Descriptor instead.
func (*GetModeResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{5}
}

func (x *GetModeResponse) GetMode() SwitchMode {
	if x != nil {
		return x.Mode
	}
	return SwitchMode_Normal
}

type Range struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         []byte                 `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End           []byte                 `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Range) Reset() {
	*x = Range{}
	mi := &file_import_sstpb_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Range) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Range) ProtoMessage() {}

func (x *Range) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Range.ProtoReflect.Descriptor instead.
func (*Range) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{6}
}

func (x *Range) GetStart() []byte {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *Range) GetEnd() []byte {
	if x != nil {
		return x.End
	}
	return nil
}

type SSTMeta struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Uuid            []byte                 `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Range           *Range                 `protobuf:"bytes,2,opt,name=range,proto3" json:"range,omitempty"`
	Crc32           uint32                 `protobuf:"varint,3,opt,name=crc32,proto3" json:"crc32,omitempty"`
	Length          uint64                 `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
	CfName          string                 `protobuf:"bytes,5,opt,name=cf_name,json=cfName,proto3" json:"cf_name,omitempty"`
	RegionId        uint64                 `protobuf:"varint,6,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	RegionEpoch     *metapb.RegionEpoch    `protobuf:"bytes,7,opt,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	EndKeyExclusive bool                   `protobuf:"varint,8,opt,name=end_key_exclusive,json=endKeyExclusive,proto3" json:"end_key_exclusive,omitempty"`
	// total_kvs and total_bytes is equivalent to PD's approximate_keys and approximate_size
	// set these values can save time from tikv upload keys and size to PD through Heartbeat.
	TotalKvs   uint64 `protobuf:"varint,9,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes uint64 `protobuf:"varint,10,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion kvrpcpb.APIVersion `protobuf:"varint,11,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// cipher_iv is used to encrypt/decrypt sst
	CipherIv      []byte `protobuf:"bytes,12,opt,name=cipher_iv,json=cipherIv,proto3" json:"cipher_iv,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSTMeta) Reset() {
	*x = SSTMeta{}
	mi := &file_import_sstpb_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSTMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSTMeta) ProtoMessage() {}

func (x *SSTMeta) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSTMeta.ProtoReflect.Descriptor instead.
func (*SSTMeta) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{7}
}

func (x *SSTMeta) GetUuid() []byte {
	if x != nil {
		return x.Uuid
	}
	return nil
}

func (x *SSTMeta) GetRange() *Range {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *SSTMeta) GetCrc32() uint32 {
	if x != nil {
		return x.Crc32
	}
	return 0
}

func (x *SSTMeta) GetLength() uint64 {
	if x != nil {
		return x.Length
	}
	return 0
}

func (x *SSTMeta) GetCfName() string {
	if x != nil {
		return x.CfName
	}
	return ""
}

func (x *SSTMeta) GetRegionId() uint64 {
	if x != nil {
		return x.RegionId
	}
	return 0
}

func (x *SSTMeta) GetRegionEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.RegionEpoch
	}
	return nil
}

func (x *SSTMeta) GetEndKeyExclusive() bool {
	if x != nil {
		return x.EndKeyExclusive
	}
	return false
}

func (x *SSTMeta) GetTotalKvs() uint64 {
	if x != nil {
		return x.TotalKvs
	}
	return 0
}

func (x *SSTMeta) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *SSTMeta) GetApiVersion() kvrpcpb.APIVersion {
	if x != nil {
		return x.ApiVersion
	}
	return kvrpcpb.APIVersion(0)
}

func (x *SSTMeta) GetCipherIv() []byte {
	if x != nil {
		return x.CipherIv
	}
	return nil
}

// A rewrite rule is applied on the *encoded* keys (the internal storage
// representation).
type RewriteRule struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	OldKeyPrefix []byte                 `protobuf:"bytes,1,opt,name=old_key_prefix,json=oldKeyPrefix,proto3" json:"old_key_prefix,omitempty"`
	NewKeyPrefix []byte                 `protobuf:"bytes,2,opt,name=new_key_prefix,json=newKeyPrefix,proto3" json:"new_key_prefix,omitempty"`
	// (Optional) Rewrite all keys in the range to use this timestamp.
	NewTimestamp uint64 `protobuf:"varint,3,opt,name=new_timestamp,json=newTimestamp,proto3" json:"new_timestamp,omitempty"`
	// (Optional) Skip keys with timestamps greater than this during download, useful for compacted SST backups.
	IgnoreAfterTimestamp uint64 `protobuf:"varint,4,opt,name=ignore_after_timestamp,json=ignoreAfterTimestamp,proto3" json:"ignore_after_timestamp,omitempty"`
	// (Optional) Skip write CF keys with timestamps less than this during download. Default CF keys are preserved.
	IgnoreBeforeTimestamp uint64 `protobuf:"varint,5,opt,name=ignore_before_timestamp,json=ignoreBeforeTimestamp,proto3" json:"ignore_before_timestamp,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *RewriteRule) Reset() {
	*x = RewriteRule{}
	mi := &file_import_sstpb_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RewriteRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RewriteRule) ProtoMessage() {}

func (x *RewriteRule) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RewriteRule.ProtoReflect.Descriptor instead.
func (*RewriteRule) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{8}
}

func (x *RewriteRule) GetOldKeyPrefix() []byte {
	if x != nil {
		return x.OldKeyPrefix
	}
	return nil
}

func (x *RewriteRule) GetNewKeyPrefix() []byte {
	if x != nil {
		return x.NewKeyPrefix
	}
	return nil
}

func (x *RewriteRule) GetNewTimestamp() uint64 {
	if x != nil {
		return x.NewTimestamp
	}
	return 0
}

func (x *RewriteRule) GetIgnoreAfterTimestamp() uint64 {
	if x != nil {
		return x.IgnoreAfterTimestamp
	}
	return 0
}

func (x *RewriteRule) GetIgnoreBeforeTimestamp() uint64 {
	if x != nil {
		return x.IgnoreBeforeTimestamp
	}
	return 0
}

type UploadRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Chunk:
	//
	//	*UploadRequest_Meta
	//	*UploadRequest_Data
	Chunk         isUploadRequest_Chunk `protobuf_oneof:"chunk"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadRequest) Reset() {
	*x = UploadRequest{}
	mi := &file_import_sstpb_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadRequest) ProtoMessage() {}

func (x *UploadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadRequest.ProtoReflect.Descriptor instead.
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{9}
}

func (x *UploadRequest) GetChunk() isUploadRequest_Chunk {
	if x != nil {
		return x.Chunk
	}
	return nil
}

func (x *UploadRequest) GetMeta() *SSTMeta {
	if x != nil {
		if x, ok := x.Chunk.(*UploadRequest_Meta); ok {
			return x.Meta
		}
	}
	return nil
}

func (x *UploadRequest) GetData() []byte {
	if x != nil {
		if x, ok := x.Chunk.(*UploadRequest_Data); ok {
			return x.Data
		}
	}
	return nil
}

type isUploadRequest_Chunk interface {
	isUploadRequest_Chunk()
}

type UploadRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,proto3,oneof"`
}

type UploadRequest_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*UploadRequest_Meta) isUploadRequest_Chunk() {}

func (*UploadRequest_Data) isUploadRequest_Chunk() {}

type UploadResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadResponse) Reset() {
	*x = UploadResponse{}
	mi := &file_import_sstpb_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadResponse) ProtoMessage() {}

func (x *UploadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadResponse.ProtoReflect.Descriptor instead.
func (*UploadResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{10}
}

type IngestRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *kvrpcpb.Context       `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Sst           *SSTMeta               `protobuf:"bytes,2,opt,name=sst,proto3" json:"sst,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IngestRequest) Reset() {
	*x = IngestRequest{}
	mi := &file_import_sstpb_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IngestRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IngestRequest) ProtoMessage() {}

func (x *IngestRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IngestRequest.ProtoReflect.Descriptor instead.
func (*IngestRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{11}
}

func (x *IngestRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *IngestRequest) GetSst() *SSTMeta {
	if x != nil {
		return x.Sst
	}
	return nil
}

type MultiIngestRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *kvrpcpb.Context       `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Ssts          []*SSTMeta             `protobuf:"bytes,2,rep,name=ssts,proto3" json:"ssts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiIngestRequest) Reset() {
	*x = MultiIngestRequest{}
	mi := &file_import_sstpb_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiIngestRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiIngestRequest) ProtoMessage() {}

func (x *MultiIngestRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiIngestRequest.ProtoReflect.Descriptor instead.
func (*MultiIngestRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{12}
}

func (x *MultiIngestRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *MultiIngestRequest) GetSsts() []*SSTMeta {
	if x != nil {
		return x.Ssts
	}
	return nil
}

type IngestResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         *errorpb.Error         `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IngestResponse) Reset() {
	*x = IngestResponse{}
	mi := &file_import_sstpb_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IngestResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IngestResponse) ProtoMessage() {}

func (x *IngestResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IngestResponse.ProtoReflect.Descriptor instead.
func (*IngestResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{13}
}

func (x *IngestResponse) GetError() *errorpb.Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type CompactRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Compact files in the range and above the output level.
	// Compact all files if the range is not specified.
	// Compact all files to the bottommost level if the output level is -1.
	Range         *Range           `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	OutputLevel   int32            `protobuf:"varint,2,opt,name=output_level,json=outputLevel,proto3" json:"output_level,omitempty"`
	Context       *kvrpcpb.Context `protobuf:"bytes,3,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactRequest) Reset() {
	*x = CompactRequest{}
	mi := &file_import_sstpb_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactRequest) ProtoMessage() {}

func (x *CompactRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactRequest.ProtoReflect.Descriptor instead.
func (*CompactRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{14}
}

func (x *CompactRequest) GetRange() *Range {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *CompactRequest) GetOutputLevel() int32 {
	if x != nil {
		return x.OutputLevel
	}
	return 0
}

func (x *CompactRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

type CompactResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactResponse) Reset() {
	*x = CompactResponse{}
	mi := &file_import_sstpb_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactResponse) ProtoMessage() {}

func (x *CompactResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactResponse.ProtoReflect.Descriptor instead.
func (*CompactResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{15}
}

type DownloadRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Map represents the map of <name, SSTMeta>.
	// We'll generate all SSTMeta into one SST File.
	Ssts map[string]*SSTMeta `protobuf:"bytes,1,rep,name=ssts,proto3" json:"ssts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// resolved_ts is used to merge related SST Files.
	ResolvedTs uint64 `protobuf:"varint,3,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts,omitempty"`
	// The file name of the SST file.
	Name string `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	// Performs a key prefix rewrite after downloading the SST file.
	// All keys in the SST will be rewritten as:
	//
	//	new_key = new_key_prefix + old_key[len(old_key_prefix)..]
	//
	// When used for TiDB, rewriting the prefix changes the table ID. Please
	// note that key-rewrite is applied on the origin keys in encoded
	// representation (the SST itself should still use data keys in encoded
	// representation).
	//
	// You need to ensure that the keys before and after rewriting are in the
	// same order, otherwise the RPC request will fail.
	SortedRewriteRules []*RewriteRule       `protobuf:"bytes,20,rep,name=sorted_rewrite_rules,json=sortedRewriteRules,proto3" json:"sorted_rewrite_rules,omitempty"`
	StorageBackend     *brpb.StorageBackend `protobuf:"bytes,14,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	// The identity for the stroage backend.
	// When this field presents, the storage would be cached.
	// If there is a cached storage, TiKV would use it driectly.
	StorageCacheId string `protobuf:"bytes,17,opt,name=storage_cache_id,json=storageCacheId,proto3" json:"storage_cache_id,omitempty"`
	IsRawKv        bool   `protobuf:"varint,15,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	// cipher_info is used to decrypt sst when download sst
	CipherInfo *brpb.CipherInfo `protobuf:"bytes,16,opt,name=cipher_info,json=cipherInfo,proto3" json:"cipher_info,omitempty"`
	// The type of the download request.
	RequestType   DownloadRequestType `protobuf:"varint,18,opt,name=request_type,json=requestType,proto3,enum=import_sstpb.DownloadRequestType" json:"request_type,omitempty"`
	Context       *kvrpcpb.Context    `protobuf:"bytes,19,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadRequest) Reset() {
	*x = DownloadRequest{}
	mi := &file_import_sstpb_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadRequest) ProtoMessage() {}

func (x *DownloadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadRequest.ProtoReflect.Descriptor instead.
func (*DownloadRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{16}
}

func (x *DownloadRequest) GetSsts() map[string]*SSTMeta {
	if x != nil {
		return x.Ssts
	}
	return nil
}

func (x *DownloadRequest) GetResolvedTs() uint64 {
	if x != nil {
		return x.ResolvedTs
	}
	return 0
}

func (x *DownloadRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DownloadRequest) GetSortedRewriteRules() []*RewriteRule {
	if x != nil {
		return x.SortedRewriteRules
	}
	return nil
}

func (x *DownloadRequest) GetStorageBackend() *brpb.StorageBackend {
	if x != nil {
		return x.StorageBackend
	}
	return nil
}

func (x *DownloadRequest) GetStorageCacheId() string {
	if x != nil {
		return x.StorageCacheId
	}
	return ""
}

func (x *DownloadRequest) GetIsRawKv() bool {
	if x != nil {
		return x.IsRawKv
	}
	return false
}

func (x *DownloadRequest) GetCipherInfo() *brpb.CipherInfo {
	if x != nil {
		return x.CipherInfo
	}
	return nil
}

func (x *DownloadRequest) GetRequestType() DownloadRequestType {
	if x != nil {
		return x.RequestType
	}
	return DownloadRequestType_Legacy
}

func (x *DownloadRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

// For now it is just used for distinguishing the error of the request with the error
// of gRPC, add more concrete types if it is necessary later.
type Error struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Message string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// We meet some internal errors of the store.
	StoreError    *errorpb.Error `protobuf:"bytes,2,opt,name=store_error,json=storeError,proto3" json:"store_error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Error) Reset() {
	*x = Error{}
	mi := &file_import_sstpb_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Error) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Error) ProtoMessage() {}

func (x *Error) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{17}
}

func (x *Error) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Error) GetStoreError() *errorpb.Error {
	if x != nil {
		return x.StoreError
	}
	return nil
}

type DownloadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the SST is empty. An empty SST is prohibited in TiKV, do not
	// ingest if this field is true.
	// (Deprecated, should be replaced by checking `length == 0` in the future)
	IsEmpty bool   `protobuf:"varint,2,opt,name=is_empty,json=isEmpty,proto3" json:"is_empty,omitempty"`
	Error   *Error `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	// The CRC32 checksum of the rewritten SST file (implementation can return
	// zero, indicating the CRC32 was not calculated).
	Crc32 uint32 `protobuf:"varint,4,opt,name=crc32,proto3" json:"crc32,omitempty"`
	// The actual length of the rewritten SST file.
	Length uint64 `protobuf:"varint,5,opt,name=length,proto3" json:"length,omitempty"`
	// This field only return when file-copy backup enabled.
	// Because it will merge many SST files in a download request.
	Ssts          []*SSTMeta `protobuf:"bytes,6,rep,name=ssts,proto3" json:"ssts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadResponse) Reset() {
	*x = DownloadResponse{}
	mi := &file_import_sstpb_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadResponse) ProtoMessage() {}

func (x *DownloadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadResponse.ProtoReflect.Descriptor instead.
func (*DownloadResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{18}
}

func (x *DownloadResponse) GetIsEmpty() bool {
	if x != nil {
		return x.IsEmpty
	}
	return false
}

func (x *DownloadResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *DownloadResponse) GetCrc32() uint32 {
	if x != nil {
		return x.Crc32
	}
	return 0
}

func (x *DownloadResponse) GetLength() uint64 {
	if x != nil {
		return x.Length
	}
	return 0
}

func (x *DownloadResponse) GetSsts() []*SSTMeta {
	if x != nil {
		return x.Ssts
	}
	return nil
}

type SetDownloadSpeedLimitRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The download speed limit (bytes/second). Set to 0 for unlimited speed.
	SpeedLimit    uint64 `protobuf:"varint,1,opt,name=speed_limit,json=speedLimit,proto3" json:"speed_limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetDownloadSpeedLimitRequest) Reset() {
	*x = SetDownloadSpeedLimitRequest{}
	mi := &file_import_sstpb_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetDownloadSpeedLimitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetDownloadSpeedLimitRequest) ProtoMessage() {}

func (x *SetDownloadSpeedLimitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetDownloadSpeedLimitRequest.ProtoReflect.Descriptor instead.
func (*SetDownloadSpeedLimitRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{19}
}

func (x *SetDownloadSpeedLimitRequest) GetSpeedLimit() uint64 {
	if x != nil {
		return x.SpeedLimit
	}
	return 0
}

type SetDownloadSpeedLimitResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetDownloadSpeedLimitResponse) Reset() {
	*x = SetDownloadSpeedLimitResponse{}
	mi := &file_import_sstpb_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetDownloadSpeedLimitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetDownloadSpeedLimitResponse) ProtoMessage() {}

func (x *SetDownloadSpeedLimitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetDownloadSpeedLimitResponse.ProtoReflect.Descriptor instead.
func (*SetDownloadSpeedLimitResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{20}
}

type Pair struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           []byte                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Op            Pair_OP                `protobuf:"varint,3,opt,name=op,proto3,enum=import_sstpb.Pair_OP" json:"op,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Pair) Reset() {
	*x = Pair{}
	mi := &file_import_sstpb_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Pair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Pair) ProtoMessage() {}

func (x *Pair) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Pair.ProtoReflect.Descriptor instead.
func (*Pair) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{21}
}

func (x *Pair) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *Pair) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Pair) GetOp() Pair_OP {
	if x != nil {
		return x.Op
	}
	return Pair_Put
}

type WriteBatch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CommitTs      uint64                 `protobuf:"varint,1,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Pairs         []*Pair                `protobuf:"bytes,2,rep,name=pairs,proto3" json:"pairs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WriteBatch) Reset() {
	*x = WriteBatch{}
	mi := &file_import_sstpb_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteBatch) ProtoMessage() {}

func (x *WriteBatch) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteBatch.ProtoReflect.Descriptor instead.
func (*WriteBatch) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{22}
}

func (x *WriteBatch) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

func (x *WriteBatch) GetPairs() []*Pair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

type WriteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Chunk:
	//
	//	*WriteRequest_Meta
	//	*WriteRequest_Batch
	Chunk         isWriteRequest_Chunk `protobuf_oneof:"chunk"`
	Context       *kvrpcpb.Context     `protobuf:"bytes,3,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WriteRequest) Reset() {
	*x = WriteRequest{}
	mi := &file_import_sstpb_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteRequest) ProtoMessage() {}

func (x *WriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteRequest.ProtoReflect.Descriptor instead.
func (*WriteRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{23}
}

func (x *WriteRequest) GetChunk() isWriteRequest_Chunk {
	if x != nil {
		return x.Chunk
	}
	return nil
}

func (x *WriteRequest) GetMeta() *SSTMeta {
	if x != nil {
		if x, ok := x.Chunk.(*WriteRequest_Meta); ok {
			return x.Meta
		}
	}
	return nil
}

func (x *WriteRequest) GetBatch() *WriteBatch {
	if x != nil {
		if x, ok := x.Chunk.(*WriteRequest_Batch); ok {
			return x.Batch
		}
	}
	return nil
}

func (x *WriteRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

type isWriteRequest_Chunk interface {
	isWriteRequest_Chunk()
}

type WriteRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,proto3,oneof"`
}

type WriteRequest_Batch struct {
	Batch *WriteBatch `protobuf:"bytes,2,opt,name=batch,proto3,oneof"`
}

func (*WriteRequest_Meta) isWriteRequest_Chunk() {}

func (*WriteRequest_Batch) isWriteRequest_Chunk() {}

type WriteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Metas         []*SSTMeta             `protobuf:"bytes,2,rep,name=metas,proto3" json:"metas,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WriteResponse) Reset() {
	*x = WriteResponse{}
	mi := &file_import_sstpb_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteResponse) ProtoMessage() {}

func (x *WriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteResponse.ProtoReflect.Descriptor instead.
func (*WriteResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{24}
}

func (x *WriteResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *WriteResponse) GetMetas() []*SSTMeta {
	if x != nil {
		return x.Metas
	}
	return nil
}

type RawWriteBatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Ttl   uint64                 `protobuf:"varint,1,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Pairs []*Pair                `protobuf:"bytes,2,rep,name=pairs,proto3" json:"pairs,omitempty"`
	// To be compatible with the key encoding of API V2.
	// This field should be generated from the client instead of the server,
	// since the message will be send to all the replicas of a region.
	// Otherwise, the underlying data generated by the server would be inconsistent which is hard to scale
	// for other features like MVCC over RawKV.
	Ts            uint64 `protobuf:"varint,3,opt,name=ts,proto3" json:"ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawWriteBatch) Reset() {
	*x = RawWriteBatch{}
	mi := &file_import_sstpb_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawWriteBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawWriteBatch) ProtoMessage() {}

func (x *RawWriteBatch) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawWriteBatch.ProtoReflect.Descriptor instead.
func (*RawWriteBatch) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{25}
}

func (x *RawWriteBatch) GetTtl() uint64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *RawWriteBatch) GetPairs() []*Pair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

func (x *RawWriteBatch) GetTs() uint64 {
	if x != nil {
		return x.Ts
	}
	return 0
}

type RawWriteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Chunk:
	//
	//	*RawWriteRequest_Meta
	//	*RawWriteRequest_Batch
	Chunk         isRawWriteRequest_Chunk `protobuf_oneof:"chunk"`
	Context       *kvrpcpb.Context        `protobuf:"bytes,3,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawWriteRequest) Reset() {
	*x = RawWriteRequest{}
	mi := &file_import_sstpb_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawWriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawWriteRequest) ProtoMessage() {}

func (x *RawWriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawWriteRequest.ProtoReflect.Descriptor instead.
func (*RawWriteRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{26}
}

func (x *RawWriteRequest) GetChunk() isRawWriteRequest_Chunk {
	if x != nil {
		return x.Chunk
	}
	return nil
}

func (x *RawWriteRequest) GetMeta() *SSTMeta {
	if x != nil {
		if x, ok := x.Chunk.(*RawWriteRequest_Meta); ok {
			return x.Meta
		}
	}
	return nil
}

func (x *RawWriteRequest) GetBatch() *RawWriteBatch {
	if x != nil {
		if x, ok := x.Chunk.(*RawWriteRequest_Batch); ok {
			return x.Batch
		}
	}
	return nil
}

func (x *RawWriteRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

type isRawWriteRequest_Chunk interface {
	isRawWriteRequest_Chunk()
}

type RawWriteRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,proto3,oneof"`
}

type RawWriteRequest_Batch struct {
	Batch *RawWriteBatch `protobuf:"bytes,2,opt,name=batch,proto3,oneof"`
}

func (*RawWriteRequest_Meta) isRawWriteRequest_Chunk() {}

func (*RawWriteRequest_Batch) isRawWriteRequest_Chunk() {}

type RawWriteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Metas         []*SSTMeta             `protobuf:"bytes,2,rep,name=metas,proto3" json:"metas,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawWriteResponse) Reset() {
	*x = RawWriteResponse{}
	mi := &file_import_sstpb_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawWriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawWriteResponse) ProtoMessage() {}

func (x *RawWriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawWriteResponse.ProtoReflect.Descriptor instead.
func (*RawWriteResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{27}
}

func (x *RawWriteResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *RawWriteResponse) GetMetas() []*SSTMeta {
	if x != nil {
		return x.Metas
	}
	return nil
}

type DuplicateDetectRequest struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Context  *kvrpcpb.Context       `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartKey []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte                 `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// Return only the keys found by scanning, not their values.
	KeyOnly bool `protobuf:"varint,4,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	// We only check the data whose timestamp is larger than `min_commit_ts`. `min_commit_ts` is exclueded.
	MinCommitTs   uint64 `protobuf:"varint,5,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DuplicateDetectRequest) Reset() {
	*x = DuplicateDetectRequest{}
	mi := &file_import_sstpb_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DuplicateDetectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DuplicateDetectRequest) ProtoMessage() {}

func (x *DuplicateDetectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DuplicateDetectRequest.ProtoReflect.Descriptor instead.
func (*DuplicateDetectRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{28}
}

func (x *DuplicateDetectRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *DuplicateDetectRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *DuplicateDetectRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *DuplicateDetectRequest) GetKeyOnly() bool {
	if x != nil {
		return x.KeyOnly
	}
	return false
}

func (x *DuplicateDetectRequest) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

type KvPair struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           []byte                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	CommitTs      uint64                 `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KvPair) Reset() {
	*x = KvPair{}
	mi := &file_import_sstpb_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KvPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KvPair) ProtoMessage() {}

func (x *KvPair) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KvPair.ProtoReflect.Descriptor instead.
func (*KvPair) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{29}
}

func (x *KvPair) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *KvPair) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *KvPair) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

type DuplicateDetectResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	KeyError    *Error                 `protobuf:"bytes,2,opt,name=key_error,json=keyError,proto3" json:"key_error,omitempty"`
	// The these keys will be in asc order (but commit time is in desc order),
	//
	//	and the content is just like following:
	//
	// [
	//
	//	{key: "key1", value: "value11", commit_ts: 1005},
	//	{key: "key1", value: "value12", commit_ts: 1004},
	//	{key: "key1", value: "value13", commit_ts: 1001},
	//	{key: "key2", value: "value21", commit_ts: 1004},
	//	{key: "key2", value: "value22", commit_ts: 1002},
	//	...
	//
	// ]
	Pairs         []*KvPair `protobuf:"bytes,3,rep,name=pairs,proto3" json:"pairs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DuplicateDetectResponse) Reset() {
	*x = DuplicateDetectResponse{}
	mi := &file_import_sstpb_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DuplicateDetectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DuplicateDetectResponse) ProtoMessage() {}

func (x *DuplicateDetectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DuplicateDetectResponse.ProtoReflect.Descriptor instead.
func (*DuplicateDetectResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{30}
}

func (x *DuplicateDetectResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *DuplicateDetectResponse) GetKeyError() *Error {
	if x != nil {
		return x.KeyError
	}
	return nil
}

func (x *DuplicateDetectResponse) GetPairs() []*KvPair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

type KVMeta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file name of the KV file.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// file offset, sometimes only need to get a part of data from the merged file
	RangeOffset uint64 `protobuf:"varint,11,opt,name=range_offset,json=rangeOffset,proto3" json:"range_offset,omitempty"`
	// file length for check.
	Length uint64 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	// range length of the merged file, if it exists.
	RangeLength uint64 `protobuf:"varint,12,opt,name=range_length,json=rangeLength,proto3" json:"range_length,omitempty"`
	// tell us which cf should apply. WRITE_CF or DEFAULT_CF e.g.
	Cf string `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	// is_delete represents whether we should delete the kv in tikv.
	// it may not be too much delete file. only rollBack operation will generate delete kv file.
	IsDelete bool `protobuf:"varint,4,opt,name=is_delete,json=isDelete,proto3" json:"is_delete,omitempty"`
	// the key ts space being smaller than start_ts can be filter.
	StartTs uint64 `protobuf:"varint,10,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// the key ts space large than restore_ts can be filter.
	RestoreTs uint64 `protobuf:"varint,5,opt,name=restore_ts,json=restoreTs,proto3" json:"restore_ts,omitempty"`
	StartKey  []byte `protobuf:"bytes,6,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey    []byte `protobuf:"bytes,7,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// used for checksum when download kv file.
	Sha256 []byte `protobuf:"bytes,8,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// the key ts space less than start_snapshot_ts can be filter.
	// Deprecated: this field 'start_snapshot_ts' is replaced by the field 'start_ts'.
	StartSnapshotTs uint64 `protobuf:"varint,9,opt,name=start_snapshot_ts,json=startSnapshotTs,proto3" json:"start_snapshot_ts,omitempty"`
	// the compression type for the file.
	CompressionType brpb.CompressionType `protobuf:"varint,13,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// encryption information of the kv file, not set if encryption is not enabled.
	FileEncryptionInfo *encryptionpb.FileEncryptionInfo `protobuf:"bytes,14,opt,name=file_encryption_info,json=fileEncryptionInfo,proto3" json:"file_encryption_info,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *KVMeta) Reset() {
	*x = KVMeta{}
	mi := &file_import_sstpb_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KVMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KVMeta) ProtoMessage() {}

func (x *KVMeta) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KVMeta.ProtoReflect.Descriptor instead.
func (*KVMeta) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{31}
}

func (x *KVMeta) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *KVMeta) GetRangeOffset() uint64 {
	if x != nil {
		return x.RangeOffset
	}
	return 0
}

func (x *KVMeta) GetLength() uint64 {
	if x != nil {
		return x.Length
	}
	return 0
}

func (x *KVMeta) GetRangeLength() uint64 {
	if x != nil {
		return x.RangeLength
	}
	return 0
}

func (x *KVMeta) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *KVMeta) GetIsDelete() bool {
	if x != nil {
		return x.IsDelete
	}
	return false
}

func (x *KVMeta) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *KVMeta) GetRestoreTs() uint64 {
	if x != nil {
		return x.RestoreTs
	}
	return 0
}

func (x *KVMeta) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *KVMeta) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *KVMeta) GetSha256() []byte {
	if x != nil {
		return x.Sha256
	}
	return nil
}

func (x *KVMeta) GetStartSnapshotTs() uint64 {
	if x != nil {
		return x.StartSnapshotTs
	}
	return 0
}

func (x *KVMeta) GetCompressionType() brpb.CompressionType {
	if x != nil {
		return x.CompressionType
	}
	return brpb.CompressionType(0)
}

func (x *KVMeta) GetFileEncryptionInfo() *encryptionpb.FileEncryptionInfo {
	if x != nil {
		return x.FileEncryptionInfo
	}
	return nil
}

type ApplyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The meta of the KV file.
	Meta  *KVMeta   `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	Metas []*KVMeta `protobuf:"bytes,12,rep,name=metas,proto3" json:"metas,omitempty"`
	// Performs a key prefix rewrite after downloading the file.
	// All keys in the files will be rewritten as:
	//
	//	new_key = new_key_prefix + old_key[len(old_key_prefix)..]
	//
	// When used for TiDB, rewriting the prefix changes the table ID. Please
	// note that key-rewrite is applied on the origin keys in encoded
	// representation.
	//
	// You need to ensure that the keys before and after rewriting are in the
	// same order, otherwise the RPC request will fail.
	RewriteRules []*RewriteRule `protobuf:"bytes,13,rep,name=rewrite_rules,json=rewriteRules,proto3" json:"rewrite_rules,omitempty"`
	// The identity for the stroage backend.
	// When this field presents, the storage would be cached.
	// If there is a cached storage, TiKV would use it driectly.
	StorageCacheId string               `protobuf:"bytes,5,opt,name=storage_cache_id,json=storageCacheId,proto3" json:"storage_cache_id,omitempty"`
	StorageBackend *brpb.StorageBackend `protobuf:"bytes,3,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	// context represents region info and it used to build raft commands.
	Context *kvrpcpb.Context `protobuf:"bytes,4,opt,name=context,proto3" json:"context,omitempty"`
	// plaintext data key to decrypt kv file if configured during log backup.
	CipherInfo *brpb.CipherInfo `protobuf:"bytes,11,opt,name=cipher_info,json=cipherInfo,proto3" json:"cipher_info,omitempty"`
	// master keys config used to decrypt data keys in restore if configured during log backup.
	MasterKeys    []*encryptionpb.MasterKey `protobuf:"bytes,14,rep,name=master_keys,json=masterKeys,proto3" json:"master_keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyRequest) Reset() {
	*x = ApplyRequest{}
	mi := &file_import_sstpb_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRequest) ProtoMessage() {}

func (x *ApplyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRequest.ProtoReflect.Descriptor instead.
func (*ApplyRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{32}
}

func (x *ApplyRequest) GetMeta() *KVMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

func (x *ApplyRequest) GetMetas() []*KVMeta {
	if x != nil {
		return x.Metas
	}
	return nil
}

func (x *ApplyRequest) GetRewriteRules() []*RewriteRule {
	if x != nil {
		return x.RewriteRules
	}
	return nil
}

func (x *ApplyRequest) GetStorageCacheId() string {
	if x != nil {
		return x.StorageCacheId
	}
	return ""
}

func (x *ApplyRequest) GetStorageBackend() *brpb.StorageBackend {
	if x != nil {
		return x.StorageBackend
	}
	return nil
}

func (x *ApplyRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *ApplyRequest) GetCipherInfo() *brpb.CipherInfo {
	if x != nil {
		return x.CipherInfo
	}
	return nil
}

func (x *ApplyRequest) GetMasterKeys() []*encryptionpb.MasterKey {
	if x != nil {
		return x.MasterKeys
	}
	return nil
}

type ApplyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         *Error                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyResponse) Reset() {
	*x = ApplyResponse{}
	mi := &file_import_sstpb_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyResponse) ProtoMessage() {}

func (x *ApplyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyResponse.ProtoReflect.Descriptor instead.
func (*ApplyResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{33}
}

func (x *ApplyResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type ClearRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// clear files in import directory with given prefix.
	Prefix        string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClearRequest) Reset() {
	*x = ClearRequest{}
	mi := &file_import_sstpb_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClearRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClearRequest) ProtoMessage() {}

func (x *ClearRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClearRequest.ProtoReflect.Descriptor instead.
func (*ClearRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{34}
}

func (x *ClearRequest) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

type ClearResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClearResponse) Reset() {
	*x = ClearResponse{}
	mi := &file_import_sstpb_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClearResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClearResponse) ProtoMessage() {}

func (x *ClearResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClearResponse.ProtoReflect.Descriptor instead.
func (*ClearResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{35}
}

func (x *ClearResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type AddPartitionRangeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Range *Range                 `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	// the number of seconds this range is valid.
	// After this duration, if this range is still not removed by
	// `RemoveForcePartitionRange`, tikv will automically remove it. So the client
	// should set a big enough value to avoid auto cleanup. But in general, 1h
	// should be a big enough value. If its value is 0, tikv will auto adjust it to 3600(1h).
	TtlSeconds    uint64 `protobuf:"varint,2,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddPartitionRangeRequest) Reset() {
	*x = AddPartitionRangeRequest{}
	mi := &file_import_sstpb_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddPartitionRangeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddPartitionRangeRequest) ProtoMessage() {}

func (x *AddPartitionRangeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddPartitionRangeRequest.ProtoReflect.Descriptor instead.
func (*AddPartitionRangeRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{36}
}

func (x *AddPartitionRangeRequest) GetRange() *Range {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *AddPartitionRangeRequest) GetTtlSeconds() uint64 {
	if x != nil {
		return x.TtlSeconds
	}
	return 0
}

type AddPartitionRangeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddPartitionRangeResponse) Reset() {
	*x = AddPartitionRangeResponse{}
	mi := &file_import_sstpb_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddPartitionRangeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddPartitionRangeResponse) ProtoMessage() {}

func (x *AddPartitionRangeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddPartitionRangeResponse.ProtoReflect.Descriptor instead.
func (*AddPartitionRangeResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{37}
}

type RemovePartitionRangeRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Range         *Range                 `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemovePartitionRangeRequest) Reset() {
	*x = RemovePartitionRangeRequest{}
	mi := &file_import_sstpb_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemovePartitionRangeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemovePartitionRangeRequest) ProtoMessage() {}

func (x *RemovePartitionRangeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemovePartitionRangeRequest.ProtoReflect.Descriptor instead.
func (*RemovePartitionRangeRequest) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{38}
}

func (x *RemovePartitionRangeRequest) GetRange() *Range {
	if x != nil {
		return x.Range
	}
	return nil
}

type RemovePartitionRangeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemovePartitionRangeResponse) Reset() {
	*x = RemovePartitionRangeResponse{}
	mi := &file_import_sstpb_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemovePartitionRangeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemovePartitionRangeResponse) ProtoMessage() {}

func (x *RemovePartitionRangeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_import_sstpb_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemovePartitionRangeResponse.ProtoReflect.Descriptor instead.
func (*RemovePartitionRangeResponse) Descriptor() ([]byte, []int) {
	return file_import_sstpb_proto_rawDescGZIP(), []int{39}
}

var File_import_sstpb_proto protoreflect.FileDescriptor

const file_import_sstpb_proto_rawDesc = "" +
	"\n" +
	"\x12import_sstpb.proto\x12\fimport_sstpb\x1a\fmetapb.proto\x1a\rerrorpb.proto\x1a\rkvrpcpb.proto\x1a\n" +
	"brpb.proto\x1a\x12encryptionpb.proto\x1a\x0frustproto.proto\"\x91\x01\n" +
	"\x17SuspendImportRPCRequest\x124\n" +
	"\x16should_suspend_imports\x18\x01 \x01(\bR\x14shouldSuspendImports\x12(\n" +
	"\x10duration_in_secs\x18\x02 \x01(\x04R\x0edurationInSecs\x12\x16\n" +
	"\x06caller\x18\x03 \x01(\tR\x06caller\"G\n" +
	"\x18SuspendImportRPCResponse\x12+\n" +
	"\x11already_suspended\x18\x01 \x01(\bR\x10alreadySuspended\"n\n" +
	"\x11SwitchModeRequest\x12,\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x18.import_sstpb.SwitchModeR\x04mode\x12+\n" +
	"\x06ranges\x18\x02 \x03(\v2\x13.import_sstpb.RangeR\x06ranges\"\x14\n" +
	"\x12SwitchModeResponse\"\x10\n" +
	"\x0eGetModeRequest\"?\n" +
	"\x0fGetModeResponse\x12,\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x18.import_sstpb.SwitchModeR\x04mode\"/\n" +
	"\x05Range\x12\x14\n" +
	"\x05start\x18\x01 \x01(\fR\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\fR\x03end\"\xa1\x03\n" +
	"\aSSTMeta\x12\x12\n" +
	"\x04uuid\x18\x01 \x01(\fR\x04uuid\x12)\n" +
	"\x05range\x18\x02 \x01(\v2\x13.import_sstpb.RangeR\x05range\x12\x14\n" +
	"\x05crc32\x18\x03 \x01(\rR\x05crc32\x12\x16\n" +
	"\x06length\x18\x04 \x01(\x04R\x06length\x12\x17\n" +
	"\acf_name\x18\x05 \x01(\tR\x06cfName\x12\x1b\n" +
	"\tregion_id\x18\x06 \x01(\x04R\bregionId\x126\n" +
	"\fregion_epoch\x18\a \x01(\v2\x13.metapb.RegionEpochR\vregionEpoch\x12*\n" +
	"\x11end_key_exclusive\x18\b \x01(\bR\x0fendKeyExclusive\x12\x1b\n" +
	"\ttotal_kvs\x18\t \x01(\x04R\btotalKvs\x12\x1f\n" +
	"\vtotal_bytes\x18\n" +
	" \x01(\x04R\n" +
	"totalBytes\x124\n" +
	"\vapi_version\x18\v \x01(\x0e2\x13.kvrpcpb.APIVersionR\n" +
	"apiVersion\x12\x1b\n" +
	"\tcipher_iv\x18\f \x01(\fR\bcipherIv\"\xec\x01\n" +
	"\vRewriteRule\x12$\n" +
	"\x0eold_key_prefix\x18\x01 \x01(\fR\foldKeyPrefix\x12$\n" +
	"\x0enew_key_prefix\x18\x02 \x01(\fR\fnewKeyPrefix\x12#\n" +
	"\rnew_timestamp\x18\x03 \x01(\x04R\fnewTimestamp\x124\n" +
	"\x16ignore_after_timestamp\x18\x04 \x01(\x04R\x14ignoreAfterTimestamp\x126\n" +
	"\x17ignore_before_timestamp\x18\x05 \x01(\x04R\x15ignoreBeforeTimestamp\"[\n" +
	"\rUploadRequest\x12+\n" +
	"\x04meta\x18\x01 \x01(\v2\x15.import_sstpb.SSTMetaH\x00R\x04meta\x12\x14\n" +
	"\x04data\x18\x02 \x01(\fH\x00R\x04dataB\a\n" +
	"\x05chunk\"\x10\n" +
	"\x0eUploadResponse\"d\n" +
	"\rIngestRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12'\n" +
	"\x03sst\x18\x02 \x01(\v2\x15.import_sstpb.SSTMetaR\x03sst\"k\n" +
	"\x12MultiIngestRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12)\n" +
	"\x04ssts\x18\x02 \x03(\v2\x15.import_sstpb.SSTMetaR\x04ssts\"6\n" +
	"\x0eIngestResponse\x12$\n" +
	"\x05error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\x05error\"\x8a\x01\n" +
	"\x0eCompactRequest\x12)\n" +
	"\x05range\x18\x01 \x01(\v2\x13.import_sstpb.RangeR\x05range\x12!\n" +
	"\foutput_level\x18\x02 \x01(\x05R\voutputLevel\x12*\n" +
	"\acontext\x18\x03 \x01(\v2\x10.kvrpcpb.ContextR\acontext\"\x11\n" +
	"\x0fCompactResponse\"\xd9\x04\n" +
	"\x0fDownloadRequest\x12;\n" +
	"\x04ssts\x18\x01 \x03(\v2'.import_sstpb.DownloadRequest.SstsEntryR\x04ssts\x12\x1f\n" +
	"\vresolved_ts\x18\x03 \x01(\x04R\n" +
	"resolvedTs\x12\x12\n" +
	"\x04name\x18\t \x01(\tR\x04name\x12K\n" +
	"\x14sorted_rewrite_rules\x18\x14 \x03(\v2\x19.import_sstpb.RewriteRuleR\x12sortedRewriteRules\x12?\n" +
	"\x0fstorage_backend\x18\x0e \x01(\v2\x16.backup.StorageBackendR\x0estorageBackend\x12(\n" +
	"\x10storage_cache_id\x18\x11 \x01(\tR\x0estorageCacheId\x12\x1a\n" +
	"\tis_raw_kv\x18\x0f \x01(\bR\aisRawKv\x123\n" +
	"\vcipher_info\x18\x10 \x01(\v2\x12.backup.CipherInfoR\n" +
	"cipherInfo\x12D\n" +
	"\frequest_type\x18\x12 \x01(\x0e2!.import_sstpb.DownloadRequestTypeR\vrequestType\x12*\n" +
	"\acontext\x18\x13 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x1aN\n" +
	"\tSstsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12+\n" +
	"\x05value\x18\x02 \x01(\v2\x15.import_sstpb.SSTMetaR\x05value:\x028\x01J\x04\b\b\x10\tR\x03url\"R\n" +
	"\x05Error\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\x12/\n" +
	"\vstore_error\x18\x02 \x01(\v2\x0e.errorpb.ErrorR\n" +
	"storeError\"\xb1\x01\n" +
	"\x10DownloadResponse\x12\x19\n" +
	"\bis_empty\x18\x02 \x01(\bR\aisEmpty\x12)\n" +
	"\x05error\x18\x03 \x01(\v2\x13.import_sstpb.ErrorR\x05error\x12\x14\n" +
	"\x05crc32\x18\x04 \x01(\rR\x05crc32\x12\x16\n" +
	"\x06length\x18\x05 \x01(\x04R\x06length\x12)\n" +
	"\x04ssts\x18\x06 \x03(\v2\x15.import_sstpb.SSTMetaR\x04ssts\"?\n" +
	"\x1cSetDownloadSpeedLimitRequest\x12\x1f\n" +
	"\vspeed_limit\x18\x01 \x01(\x04R\n" +
	"speedLimit\"\x1f\n" +
	"\x1dSetDownloadSpeedLimitResponse\"p\n" +
	"\x04Pair\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\x12%\n" +
	"\x02op\x18\x03 \x01(\x0e2\x15.import_sstpb.Pair.OPR\x02op\"\x19\n" +
	"\x02OP\x12\a\n" +
	"\x03Put\x10\x00\x12\n" +
	"\n" +
	"\x06Delete\x10\x01\"S\n" +
	"\n" +
	"WriteBatch\x12\x1b\n" +
	"\tcommit_ts\x18\x01 \x01(\x04R\bcommitTs\x12(\n" +
	"\x05pairs\x18\x02 \x03(\v2\x12.import_sstpb.PairR\x05pairs\"\xa2\x01\n" +
	"\fWriteRequest\x12+\n" +
	"\x04meta\x18\x01 \x01(\v2\x15.import_sstpb.SSTMetaH\x00R\x04meta\x120\n" +
	"\x05batch\x18\x02 \x01(\v2\x18.import_sstpb.WriteBatchH\x00R\x05batch\x12*\n" +
	"\acontext\x18\x03 \x01(\v2\x10.kvrpcpb.ContextR\acontextB\a\n" +
	"\x05chunk\"g\n" +
	"\rWriteResponse\x12)\n" +
	"\x05error\x18\x01 \x01(\v2\x13.import_sstpb.ErrorR\x05error\x12+\n" +
	"\x05metas\x18\x02 \x03(\v2\x15.import_sstpb.SSTMetaR\x05metas\"[\n" +
	"\rRawWriteBatch\x12\x10\n" +
	"\x03ttl\x18\x01 \x01(\x04R\x03ttl\x12(\n" +
	"\x05pairs\x18\x02 \x03(\v2\x12.import_sstpb.PairR\x05pairs\x12\x0e\n" +
	"\x02ts\x18\x03 \x01(\x04R\x02ts\"\xa8\x01\n" +
	"\x0fRawWriteRequest\x12+\n" +
	"\x04meta\x18\x01 \x01(\v2\x15.import_sstpb.SSTMetaH\x00R\x04meta\x123\n" +
	"\x05batch\x18\x02 \x01(\v2\x1b.import_sstpb.RawWriteBatchH\x00R\x05batch\x12*\n" +
	"\acontext\x18\x03 \x01(\v2\x10.kvrpcpb.ContextR\acontextB\a\n" +
	"\x05chunk\"j\n" +
	"\x10RawWriteResponse\x12)\n" +
	"\x05error\x18\x01 \x01(\v2\x13.import_sstpb.ErrorR\x05error\x12+\n" +
	"\x05metas\x18\x02 \x03(\v2\x15.import_sstpb.SSTMetaR\x05metas\"\xb9\x01\n" +
	"\x16DuplicateDetectRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x03 \x01(\fR\x06endKey\x12\x19\n" +
	"\bkey_only\x18\x04 \x01(\bR\akeyOnly\x12\"\n" +
	"\rmin_commit_ts\x18\x05 \x01(\x04R\vminCommitTs\"M\n" +
	"\x06KvPair\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\x12\x1b\n" +
	"\tcommit_ts\x18\x03 \x01(\x04R\bcommitTs\"\xaa\x01\n" +
	"\x17DuplicateDetectResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x120\n" +
	"\tkey_error\x18\x02 \x01(\v2\x13.import_sstpb.ErrorR\bkeyError\x12*\n" +
	"\x05pairs\x18\x03 \x03(\v2\x14.import_sstpb.KvPairR\x05pairs\"\xf3\x03\n" +
	"\x06KVMeta\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\frange_offset\x18\v \x01(\x04R\vrangeOffset\x12\x16\n" +
	"\x06length\x18\x02 \x01(\x04R\x06length\x12!\n" +
	"\frange_length\x18\f \x01(\x04R\vrangeLength\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\x12\x1b\n" +
	"\tis_delete\x18\x04 \x01(\bR\bisDelete\x12\x19\n" +
	"\bstart_ts\x18\n" +
	" \x01(\x04R\astartTs\x12\x1d\n" +
	"\n" +
	"restore_ts\x18\x05 \x01(\x04R\trestoreTs\x12\x1b\n" +
	"\tstart_key\x18\x06 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\a \x01(\fR\x06endKey\x12\x16\n" +
	"\x06sha256\x18\b \x01(\fR\x06sha256\x12*\n" +
	"\x11start_snapshot_ts\x18\t \x01(\x04R\x0fstartSnapshotTs\x12B\n" +
	"\x10compression_type\x18\r \x01(\x0e2\x17.backup.CompressionTypeR\x0fcompressionType\x12R\n" +
	"\x14file_encryption_info\x18\x0e \x01(\v2 .encryptionpb.FileEncryptionInfoR\x12fileEncryptionInfo\"\xaa\x03\n" +
	"\fApplyRequest\x12(\n" +
	"\x04meta\x18\x01 \x01(\v2\x14.import_sstpb.KVMetaR\x04meta\x12*\n" +
	"\x05metas\x18\f \x03(\v2\x14.import_sstpb.KVMetaR\x05metas\x12>\n" +
	"\rrewrite_rules\x18\r \x03(\v2\x19.import_sstpb.RewriteRuleR\frewriteRules\x12(\n" +
	"\x10storage_cache_id\x18\x05 \x01(\tR\x0estorageCacheId\x12?\n" +
	"\x0fstorage_backend\x18\x03 \x01(\v2\x16.backup.StorageBackendR\x0estorageBackend\x12*\n" +
	"\acontext\x18\x04 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x123\n" +
	"\vcipher_info\x18\v \x01(\v2\x12.backup.CipherInfoR\n" +
	"cipherInfo\x128\n" +
	"\vmaster_keys\x18\x0e \x03(\v2\x17.encryptionpb.MasterKeyR\n" +
	"masterKeys\":\n" +
	"\rApplyResponse\x12)\n" +
	"\x05error\x18\x02 \x01(\v2\x13.import_sstpb.ErrorR\x05error\"&\n" +
	"\fClearRequest\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\":\n" +
	"\rClearResponse\x12)\n" +
	"\x05error\x18\x01 \x01(\v2\x13.import_sstpb.ErrorR\x05error\"f\n" +
	"\x18AddPartitionRangeRequest\x12)\n" +
	"\x05range\x18\x01 \x01(\v2\x13.import_sstpb.RangeR\x05range\x12\x1f\n" +
	"\vttl_seconds\x18\x02 \x01(\x04R\n" +
	"ttlSeconds\"\x1b\n" +
	"\x19AddPartitionRangeResponse\"H\n" +
	"\x1bRemovePartitionRangeRequest\x12)\n" +
	"\x05range\x18\x01 \x01(\v2\x13.import_sstpb.RangeR\x05range\"\x1e\n" +
	"\x1cRemovePartitionRangeResponse*$\n" +
	"\n" +
	"SwitchMode\x12\n" +
	"\n" +
	"\x06Normal\x10\x00\x12\n" +
	"\n" +
	"\x06Import\x10\x01*/\n" +
	"\x13DownloadRequestType\x12\n" +
	"\n" +
	"\x06Legacy\x10\x00\x12\f\n" +
	"\bKeyspace\x10\x012\xb4\v\n" +
	"\tImportSST\x12Q\n" +
	"\n" +
	"SwitchMode\x12\x1f.import_sstpb.SwitchModeRequest\x1a .import_sstpb.SwitchModeResponse\"\x00\x12H\n" +
	"\aGetMode\x12\x1c.import_sstpb.GetModeRequest\x1a\x1d.import_sstpb.GetModeResponse\"\x00\x12G\n" +
	"\x06Upload\x12\x1b.import_sstpb.UploadRequest\x1a\x1c.import_sstpb.UploadResponse\"\x00(\x01\x12E\n" +
	"\x06Ingest\x12\x1b.import_sstpb.IngestRequest\x1a\x1c.import_sstpb.IngestResponse\"\x00\x12H\n" +
	"\aCompact\x12\x1c.import_sstpb.CompactRequest\x1a\x1d.import_sstpb.CompactResponse\"\x00\x12r\n" +
	"\x15SetDownloadSpeedLimit\x12*.import_sstpb.SetDownloadSpeedLimitRequest\x1a+.import_sstpb.SetDownloadSpeedLimitResponse\"\x00\x12K\n" +
	"\bDownload\x12\x1d.import_sstpb.DownloadRequest\x1a\x1e.import_sstpb.DownloadResponse\"\x00\x12P\n" +
	"\rBatchDownload\x12\x1d.import_sstpb.DownloadRequest\x1a\x1e.import_sstpb.DownloadResponse\"\x00\x12D\n" +
	"\x05Write\x12\x1a.import_sstpb.WriteRequest\x1a\x1b.import_sstpb.WriteResponse\"\x00(\x01\x12M\n" +
	"\bRawWrite\x12\x1d.import_sstpb.RawWriteRequest\x1a\x1e.import_sstpb.RawWriteResponse\"\x00(\x01\x12O\n" +
	"\vMultiIngest\x12 .import_sstpb.MultiIngestRequest\x1a\x1c.import_sstpb.IngestResponse\"\x00\x12b\n" +
	"\x0fDuplicateDetect\x12$.import_sstpb.DuplicateDetectRequest\x1a%.import_sstpb.DuplicateDetectResponse\"\x000\x01\x12B\n" +
	"\x05Apply\x12\x1a.import_sstpb.ApplyRequest\x1a\x1b.import_sstpb.ApplyResponse\"\x00\x12G\n" +
	"\n" +
	"ClearFiles\x12\x1a.import_sstpb.ClearRequest\x1a\x1b.import_sstpb.ClearResponse\"\x00\x12c\n" +
	"\x10SuspendImportRPC\x12%.import_sstpb.SuspendImportRPCRequest\x1a&.import_sstpb.SuspendImportRPCResponse\"\x00\x12k\n" +
	"\x16AddForcePartitionRange\x12&.import_sstpb.AddPartitionRangeRequest\x1a'.import_sstpb.AddPartitionRangeResponse\"\x00\x12t\n" +
	"\x19RemoveForcePartitionRange\x12).import_sstpb.RemovePartitionRangeRequest\x1a*.import_sstpb.RemovePartitionRangeResponse\"\x00B\x16\b\x01\n" +
	"\x10org.tikv.kvprotob\x06proto3"

var (
	file_import_sstpb_proto_rawDescOnce sync.Once
	file_import_sstpb_proto_rawDescData []byte
)

func file_import_sstpb_proto_rawDescGZIP() []byte {
	file_import_sstpb_proto_rawDescOnce.Do(func() {
		file_import_sstpb_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_import_sstpb_proto_rawDesc), len(file_import_sstpb_proto_rawDesc)))
	})
	return file_import_sstpb_proto_rawDescData
}

var file_import_sstpb_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_import_sstpb_proto_msgTypes = make([]protoimpl.MessageInfo, 41)
var file_import_sstpb_proto_goTypes = []any{
	(SwitchMode)(0),                         // 0: import_sstpb.SwitchMode
	(DownloadRequestType)(0),                // 1: import_sstpb.DownloadRequestType
	(Pair_OP)(0),                            // 2: import_sstpb.Pair.OP
	(*SuspendImportRPCRequest)(nil),         // 3: import_sstpb.SuspendImportRPCRequest
	(*SuspendImportRPCResponse)(nil),        // 4: import_sstpb.SuspendImportRPCResponse
	(*SwitchModeRequest)(nil),               // 5: import_sstpb.SwitchModeRequest
	(*SwitchModeResponse)(nil),              // 6: import_sstpb.SwitchModeResponse
	(*GetModeRequest)(nil),                  // 7: import_sstpb.GetModeRequest
	(*GetModeResponse)(nil),                 // 8: import_sstpb.GetModeResponse
	(*Range)(nil),                           // 9: import_sstpb.Range
	(*SSTMeta)(nil),                         // 10: import_sstpb.SSTMeta
	(*RewriteRule)(nil),                     // 11: import_sstpb.RewriteRule
	(*UploadRequest)(nil),                   // 12: import_sstpb.UploadRequest
	(*UploadResponse)(nil),                  // 13: import_sstpb.UploadResponse
	(*IngestRequest)(nil),                   // 14: import_sstpb.IngestRequest
	(*MultiIngestRequest)(nil),              // 15: import_sstpb.MultiIngestRequest
	(*IngestResponse)(nil),                  // 16: import_sstpb.IngestResponse
	(*CompactRequest)(nil),                  // 17: import_sstpb.CompactRequest
	(*CompactResponse)(nil),                 // 18: import_sstpb.CompactResponse
	(*DownloadRequest)(nil),                 // 19: import_sstpb.DownloadRequest
	(*Error)(nil),                           // 20: import_sstpb.Error
	(*DownloadResponse)(nil),                // 21: import_sstpb.DownloadResponse
	(*SetDownloadSpeedLimitRequest)(nil),    // 22: import_sstpb.SetDownloadSpeedLimitRequest
	(*SetDownloadSpeedLimitResponse)(nil),   // 23: import_sstpb.SetDownloadSpeedLimitResponse
	(*Pair)(nil),                            // 24: import_sstpb.Pair
	(*WriteBatch)(nil),                      // 25: import_sstpb.WriteBatch
	(*WriteRequest)(nil),                    // 26: import_sstpb.WriteRequest
	(*WriteResponse)(nil),                   // 27: import_sstpb.WriteResponse
	(*RawWriteBatch)(nil),                   // 28: import_sstpb.RawWriteBatch
	(*RawWriteRequest)(nil),                 // 29: import_sstpb.RawWriteRequest
	(*RawWriteResponse)(nil),                // 30: import_sstpb.RawWriteResponse
	(*DuplicateDetectRequest)(nil),          // 31: import_sstpb.DuplicateDetectRequest
	(*KvPair)(nil),                          // 32: import_sstpb.KvPair
	(*DuplicateDetectResponse)(nil),         // 33: import_sstpb.DuplicateDetectResponse
	(*KVMeta)(nil),                          // 34: import_sstpb.KVMeta
	(*ApplyRequest)(nil),                    // 35: import_sstpb.ApplyRequest
	(*ApplyResponse)(nil),                   // 36: import_sstpb.ApplyResponse
	(*ClearRequest)(nil),                    // 37: import_sstpb.ClearRequest
	(*ClearResponse)(nil),                   // 38: import_sstpb.ClearResponse
	(*AddPartitionRangeRequest)(nil),        // 39: import_sstpb.AddPartitionRangeRequest
	(*AddPartitionRangeResponse)(nil),       // 40: import_sstpb.AddPartitionRangeResponse
	(*RemovePartitionRangeRequest)(nil),     // 41: import_sstpb.RemovePartitionRangeRequest
	(*RemovePartitionRangeResponse)(nil),    // 42: import_sstpb.RemovePartitionRangeResponse
	nil,                                     // 43: import_sstpb.DownloadRequest.SstsEntry
	(*metapb.RegionEpoch)(nil),              // 44: metapb.RegionEpoch
	(kvrpcpb.APIVersion)(0),                 // 45: kvrpcpb.APIVersion
	(*kvrpcpb.Context)(nil),                 // 46: kvrpcpb.Context
	(*errorpb.Error)(nil),                   // 47: errorpb.Error
	(*brpb.StorageBackend)(nil),             // 48: backup.StorageBackend
	(*brpb.CipherInfo)(nil),                 // 49: backup.CipherInfo
	(brpb.CompressionType)(0),               // 50: backup.CompressionType
	(*encryptionpb.FileEncryptionInfo)(nil), // 51: encryptionpb.FileEncryptionInfo
	(*encryptionpb.MasterKey)(nil),          // 52: encryptionpb.MasterKey
}
var file_import_sstpb_proto_depIdxs = []int32{
	0,  // 0: import_sstpb.SwitchModeRequest.mode:type_name -> import_sstpb.SwitchMode
	9,  // 1: import_sstpb.SwitchModeRequest.ranges:type_name -> import_sstpb.Range
	0,  // 2: import_sstpb.GetModeResponse.mode:type_name -> import_sstpb.SwitchMode
	9,  // 3: import_sstpb.SSTMeta.range:type_name -> import_sstpb.Range
	44, // 4: import_sstpb.SSTMeta.region_epoch:type_name -> metapb.RegionEpoch
	45, // 5: import_sstpb.SSTMeta.api_version:type_name -> kvrpcpb.APIVersion
	10, // 6: import_sstpb.UploadRequest.meta:type_name -> import_sstpb.SSTMeta
	46, // 7: import_sstpb.IngestRequest.context:type_name -> kvrpcpb.Context
	10, // 8: import_sstpb.IngestRequest.sst:type_name -> import_sstpb.SSTMeta
	46, // 9: import_sstpb.MultiIngestRequest.context:type_name -> kvrpcpb.Context
	10, // 10: import_sstpb.MultiIngestRequest.ssts:type_name -> import_sstpb.SSTMeta
	47, // 11: import_sstpb.IngestResponse.error:type_name -> errorpb.Error
	9,  // 12: import_sstpb.CompactRequest.range:type_name -> import_sstpb.Range
	46, // 13: import_sstpb.CompactRequest.context:type_name -> kvrpcpb.Context
	43, // 14: import_sstpb.DownloadRequest.ssts:type_name -> import_sstpb.DownloadRequest.SstsEntry
	11, // 15: import_sstpb.DownloadRequest.sorted_rewrite_rules:type_name -> import_sstpb.RewriteRule
	48, // 16: import_sstpb.DownloadRequest.storage_backend:type_name -> backup.StorageBackend
	49, // 17: import_sstpb.DownloadRequest.cipher_info:type_name -> backup.CipherInfo
	1,  // 18: import_sstpb.DownloadRequest.request_type:type_name -> import_sstpb.DownloadRequestType
	46, // 19: import_sstpb.DownloadRequest.context:type_name -> kvrpcpb.Context
	47, // 20: import_sstpb.Error.store_error:type_name -> errorpb.Error
	20, // 21: import_sstpb.DownloadResponse.error:type_name -> import_sstpb.Error
	10, // 22: import_sstpb.DownloadResponse.ssts:type_name -> import_sstpb.SSTMeta
	2,  // 23: import_sstpb.Pair.op:type_name -> import_sstpb.Pair.OP
	24, // 24: import_sstpb.WriteBatch.pairs:type_name -> import_sstpb.Pair
	10, // 25: import_sstpb.WriteRequest.meta:type_name -> import_sstpb.SSTMeta
	25, // 26: import_sstpb.WriteRequest.batch:type_name -> import_sstpb.WriteBatch
	46, // 27: import_sstpb.WriteRequest.context:type_name -> kvrpcpb.Context
	20, // 28: import_sstpb.WriteResponse.error:type_name -> import_sstpb.Error
	10, // 29: import_sstpb.WriteResponse.metas:type_name -> import_sstpb.SSTMeta
	24, // 30: import_sstpb.RawWriteBatch.pairs:type_name -> import_sstpb.Pair
	10, // 31: import_sstpb.RawWriteRequest.meta:type_name -> import_sstpb.SSTMeta
	28, // 32: import_sstpb.RawWriteRequest.batch:type_name -> import_sstpb.RawWriteBatch
	46, // 33: import_sstpb.RawWriteRequest.context:type_name -> kvrpcpb.Context
	20, // 34: import_sstpb.RawWriteResponse.error:type_name -> import_sstpb.Error
	10, // 35: import_sstpb.RawWriteResponse.metas:type_name -> import_sstpb.SSTMeta
	46, // 36: import_sstpb.DuplicateDetectRequest.context:type_name -> kvrpcpb.Context
	47, // 37: import_sstpb.DuplicateDetectResponse.region_error:type_name -> errorpb.Error
	20, // 38: import_sstpb.DuplicateDetectResponse.key_error:type_name -> import_sstpb.Error
	32, // 39: import_sstpb.DuplicateDetectResponse.pairs:type_name -> import_sstpb.KvPair
	50, // 40: import_sstpb.KVMeta.compression_type:type_name -> backup.CompressionType
	51, // 41: import_sstpb.KVMeta.file_encryption_info:type_name -> encryptionpb.FileEncryptionInfo
	34, // 42: import_sstpb.ApplyRequest.meta:type_name -> import_sstpb.KVMeta
	34, // 43: import_sstpb.ApplyRequest.metas:type_name -> import_sstpb.KVMeta
	11, // 44: import_sstpb.ApplyRequest.rewrite_rules:type_name -> import_sstpb.RewriteRule
	48, // 45: import_sstpb.ApplyRequest.storage_backend:type_name -> backup.StorageBackend
	46, // 46: import_sstpb.ApplyRequest.context:type_name -> kvrpcpb.Context
	49, // 47: import_sstpb.ApplyRequest.cipher_info:type_name -> backup.CipherInfo
	52, // 48: import_sstpb.ApplyRequest.master_keys:type_name -> encryptionpb.MasterKey
	20, // 49: import_sstpb.ApplyResponse.error:type_name -> import_sstpb.Error
	20, // 50: import_sstpb.ClearResponse.error:type_name -> import_sstpb.Error
	9,  // 51: import_sstpb.AddPartitionRangeRequest.range:type_name -> import_sstpb.Range
	9,  // 52: import_sstpb.RemovePartitionRangeRequest.range:type_name -> import_sstpb.Range
	10, // 53: import_sstpb.DownloadRequest.SstsEntry.value:type_name -> import_sstpb.SSTMeta
	5,  // 54: import_sstpb.ImportSST.SwitchMode:input_type -> import_sstpb.SwitchModeRequest
	7,  // 55: import_sstpb.ImportSST.GetMode:input_type -> import_sstpb.GetModeRequest
	12, // 56: import_sstpb.ImportSST.Upload:input_type -> import_sstpb.UploadRequest
	14, // 57: import_sstpb.ImportSST.Ingest:input_type -> import_sstpb.IngestRequest
	17, // 58: import_sstpb.ImportSST.Compact:input_type -> import_sstpb.CompactRequest
	22, // 59: import_sstpb.ImportSST.SetDownloadSpeedLimit:input_type -> import_sstpb.SetDownloadSpeedLimitRequest
	19, // 60: import_sstpb.ImportSST.Download:input_type -> import_sstpb.DownloadRequest
	19, // 61: import_sstpb.ImportSST.BatchDownload:input_type -> import_sstpb.DownloadRequest
	26, // 62: import_sstpb.ImportSST.Write:input_type -> import_sstpb.WriteRequest
	29, // 63: import_sstpb.ImportSST.RawWrite:input_type -> import_sstpb.RawWriteRequest
	15, // 64: import_sstpb.ImportSST.MultiIngest:input_type -> import_sstpb.MultiIngestRequest
	31, // 65: import_sstpb.ImportSST.DuplicateDetect:input_type -> import_sstpb.DuplicateDetectRequest
	35, // 66: import_sstpb.ImportSST.Apply:input_type -> import_sstpb.ApplyRequest
	37, // 67: import_sstpb.ImportSST.ClearFiles:input_type -> import_sstpb.ClearRequest
	3,  // 68: import_sstpb.ImportSST.SuspendImportRPC:input_type -> import_sstpb.SuspendImportRPCRequest
	39, // 69: import_sstpb.ImportSST.AddForcePartitionRange:input_type -> import_sstpb.AddPartitionRangeRequest
	41, // 70: import_sstpb.ImportSST.RemoveForcePartitionRange:input_type -> import_sstpb.RemovePartitionRangeRequest
	6,  // 71: import_sstpb.ImportSST.SwitchMode:output_type -> import_sstpb.SwitchModeResponse
	8,  // 72: import_sstpb.ImportSST.GetMode:output_type -> import_sstpb.GetModeResponse
	13, // 73: import_sstpb.ImportSST.Upload:output_type -> import_sstpb.UploadResponse
	16, // 74: import_sstpb.ImportSST.Ingest:output_type -> import_sstpb.IngestResponse
	18, // 75: import_sstpb.ImportSST.Compact:output_type -> import_sstpb.CompactResponse
	23, // 76: import_sstpb.ImportSST.SetDownloadSpeedLimit:output_type -> import_sstpb.SetDownloadSpeedLimitResponse
	21, // 77: import_sstpb.ImportSST.Download:output_type -> import_sstpb.DownloadResponse
	21, // 78: import_sstpb.ImportSST.BatchDownload:output_type -> import_sstpb.DownloadResponse
	27, // 79: import_sstpb.ImportSST.Write:output_type -> import_sstpb.WriteResponse
	30, // 80: import_sstpb.ImportSST.RawWrite:output_type -> import_sstpb.RawWriteResponse
	16, // 81: import_sstpb.ImportSST.MultiIngest:output_type -> import_sstpb.IngestResponse
	33, // 82: import_sstpb.ImportSST.DuplicateDetect:output_type -> import_sstpb.DuplicateDetectResponse
	36, // 83: import_sstpb.ImportSST.Apply:output_type -> import_sstpb.ApplyResponse
	38, // 84: import_sstpb.ImportSST.ClearFiles:output_type -> import_sstpb.ClearResponse
	4,  // 85: import_sstpb.ImportSST.SuspendImportRPC:output_type -> import_sstpb.SuspendImportRPCResponse
	40, // 86: import_sstpb.ImportSST.AddForcePartitionRange:output_type -> import_sstpb.AddPartitionRangeResponse
	42, // 87: import_sstpb.ImportSST.RemoveForcePartitionRange:output_type -> import_sstpb.RemovePartitionRangeResponse
	71, // [71:88] is the sub-list for method output_type
	54, // [54:71] is the sub-list for method input_type
	54, // [54:54] is the sub-list for extension type_name
	54, // [54:54] is the sub-list for extension extendee
	0,  // [0:54] is the sub-list for field type_name
}

func init() { file_import_sstpb_proto_init() }
func file_import_sstpb_proto_init() {
	if File_import_sstpb_proto != nil {
		return
	}
	file_import_sstpb_proto_msgTypes[9].OneofWrappers = []any{
		(*UploadRequest_Meta)(nil),
		(*UploadRequest_Data)(nil),
	}
	file_import_sstpb_proto_msgTypes[23].OneofWrappers = []any{
		(*WriteRequest_Meta)(nil),
		(*WriteRequest_Batch)(nil),
	}
	file_import_sstpb_proto_msgTypes[26].OneofWrappers = []any{
		(*RawWriteRequest_Meta)(nil),
		(*RawWriteRequest_Batch)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_import_sstpb_proto_rawDesc), len(file_import_sstpb_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   41,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_import_sstpb_proto_goTypes,
		DependencyIndexes: file_import_sstpb_proto_depIdxs,
		EnumInfos:         file_import_sstpb_proto_enumTypes,
		MessageInfos:      file_import_sstpb_proto_msgTypes,
	}.Build()
	File_import_sstpb_proto = out.File
	file_import_sstpb_proto_goTypes = nil
	file_import_sstpb_proto_depIdxs = nil
}
