// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: import_sstpb.proto

package import_sstpb

import (
	"context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ImportSST_SwitchMode_FullMethodName                = "/import_sstpb.ImportSST/SwitchMode"
	ImportSST_GetMode_FullMethodName                   = "/import_sstpb.ImportSST/GetMode"
	ImportSST_Upload_FullMethodName                    = "/import_sstpb.ImportSST/Upload"
	ImportSST_Ingest_FullMethodName                    = "/import_sstpb.ImportSST/Ingest"
	ImportSST_Compact_FullMethodName                   = "/import_sstpb.ImportSST/Compact"
	ImportSST_SetDownloadSpeedLimit_FullMethodName     = "/import_sstpb.ImportSST/SetDownloadSpeedLimit"
	ImportSST_Download_FullMethodName                  = "/import_sstpb.ImportSST/Download"
	ImportSST_BatchDownload_FullMethodName             = "/import_sstpb.ImportSST/BatchDownload"
	ImportSST_Write_FullMethodName                     = "/import_sstpb.ImportSST/Write"
	ImportSST_RawWrite_FullMethodName                  = "/import_sstpb.ImportSST/RawWrite"
	ImportSST_MultiIngest_FullMethodName               = "/import_sstpb.ImportSST/MultiIngest"
	ImportSST_DuplicateDetect_FullMethodName           = "/import_sstpb.ImportSST/DuplicateDetect"
	ImportSST_Apply_FullMethodName                     = "/import_sstpb.ImportSST/Apply"
	ImportSST_ClearFiles_FullMethodName                = "/import_sstpb.ImportSST/ClearFiles"
	ImportSST_SuspendImportRPC_FullMethodName          = "/import_sstpb.ImportSST/SuspendImportRPC"
	ImportSST_AddForcePartitionRange_FullMethodName    = "/import_sstpb.ImportSST/AddForcePartitionRange"
	ImportSST_RemoveForcePartitionRange_FullMethodName = "/import_sstpb.ImportSST/RemoveForcePartitionRange"
)

// ImportSSTClient is the client API for ImportSST service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ImportSST provides a service to import a generated SST file to a region in TiKV.
//
// In order to import an SST file to a region, the user should:
// 1. Retrieve the meta of the region according to the SST file's range.
// 2. Upload the SST file to the servers where the region's peers locate in.
// 3. Issue an ingest request to the region's leader with the SST file's metadata.
//
// It's the user's responsibility to make sure that the SST file is uploaded to
// the servers where the region's peers locate in, before issue the ingest
// request to the region's leader. However, the region can be scheduled (so the
// location of the region's peers will be changed) or split/merged (so the range
// of the region will be changed), after the SST file is uploaded, but before
// the SST file is ingested. So, the region's epoch is provided in the SST
// file's metadata, to guarantee that the region's epoch must be the same
// between the SST file is uploaded and ingested later.
type ImportSSTClient interface {
	// Switch to normal/import mode.
	SwitchMode(ctx context.Context, in *SwitchModeRequest, opts ...grpc.CallOption) (*SwitchModeResponse, error)
	// Get import mode(normal/import).
	GetMode(ctx context.Context, in *GetModeRequest, opts ...grpc.CallOption) (*GetModeResponse, error)
	// Upload an SST file to a server.
	Upload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[UploadRequest, UploadResponse], error)
	// Ingest an uploaded SST file to a region.
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
	// Compact the specific range for better performance.
	Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error)
	SetDownloadSpeedLimit(ctx context.Context, in *SetDownloadSpeedLimitRequest, opts ...grpc.CallOption) (*SetDownloadSpeedLimitResponse, error)
	// Download an SST file from an external storage, and performs key-rewrite
	// after downloading.
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error)
	// Batch download SST files from an external storage, and performs key-rewrite
	// after downloading.
	BatchDownload(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error)
	// Open a write stream to generate sst files
	Write(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[WriteRequest, WriteResponse], error)
	RawWrite(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[RawWriteRequest, RawWriteResponse], error)
	// Ingest Multiple files in one request
	MultiIngest(ctx context.Context, in *MultiIngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
	// Collect duplicate data from TiKV.
	DuplicateDetect(ctx context.Context, in *DuplicateDetectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DuplicateDetectResponse], error)
	// Apply download & apply increment kv files to TiKV.
	Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
	// ClearFiles clear applied file after restore succeed.
	ClearFiles(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*ClearResponse, error)
	// Suspend ingest for data listeners don't support catching import data.
	SuspendImportRPC(ctx context.Context, in *SuspendImportRPCRequest, opts ...grpc.CallOption) (*SuspendImportRPCResponse, error)
	// AddForcePartitionRange marks a range in tikv that any compact overlaps with this range
	// should generates SST files partitioned at region boundaries as well as this range boundary.
	// TiKV will also try to do manual compact(if needed) after setting this range to eusure
	// any incoming SST under this range can be ingested into the bottom level if there is no real kv overlap.
	AddForcePartitionRange(ctx context.Context, in *AddPartitionRangeRequest, opts ...grpc.CallOption) (*AddPartitionRangeResponse, error)
	// Remove the force partition range after the task is finished. If this function is not called,
	// tikv will cleanup the range after TTL to ensure it can be cleaned eventually.
	RemoveForcePartitionRange(ctx context.Context, in *RemovePartitionRangeRequest, opts ...grpc.CallOption) (*RemovePartitionRangeResponse, error)
}

type importSSTClient struct {
	cc grpc.ClientConnInterface
}

func NewImportSSTClient(cc grpc.ClientConnInterface) ImportSSTClient {
	return &importSSTClient{cc}
}

func (c *importSSTClient) SwitchMode(ctx context.Context, in *SwitchModeRequest, opts ...grpc.CallOption) (*SwitchModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwitchModeResponse)
	err := c.cc.Invoke(ctx, ImportSST_SwitchMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) GetMode(ctx context.Context, in *GetModeRequest, opts ...grpc.CallOption) (*GetModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModeResponse)
	err := c.cc.Invoke(ctx, ImportSST_GetMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Upload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[UploadRequest, UploadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ImportSST_ServiceDesc.Streams[0], ImportSST_Upload_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[UploadRequest, UploadResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImportSST_UploadClient = grpc.ClientStreamingClient[UploadRequest, UploadResponse]

func (c *importSSTClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, ImportSST_Ingest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompactResponse)
	err := c.cc.Invoke(ctx, ImportSST_Compact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) SetDownloadSpeedLimit(ctx context.Context, in *SetDownloadSpeedLimitRequest, opts ...grpc.CallOption) (*SetDownloadSpeedLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDownloadSpeedLimitResponse)
	err := c.cc.Invoke(ctx, ImportSST_SetDownloadSpeedLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DownloadResponse)
	err := c.cc.Invoke(ctx, ImportSST_Download_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) BatchDownload(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DownloadResponse)
	err := c.cc.Invoke(ctx, ImportSST_BatchDownload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Write(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[WriteRequest, WriteResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ImportSST_ServiceDesc.Streams[1], ImportSST_Write_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WriteRequest, WriteResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImportSST_WriteClient = grpc.ClientStreamingClient[WriteRequest, WriteResponse]

func (c *importSSTClient) RawWrite(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[RawWriteRequest, RawWriteResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ImportSST_ServiceDesc.Streams[2], ImportSST_RawWrite_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RawWriteRequest, RawWriteResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImportSST_RawWriteClient = grpc.ClientStreamingClient[RawWriteRequest, RawWriteResponse]

func (c *importSSTClient) MultiIngest(ctx context.Context, in *MultiIngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, ImportSST_MultiIngest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) DuplicateDetect(ctx context.Context, in *DuplicateDetectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DuplicateDetectResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ImportSST_ServiceDesc.Streams[3], ImportSST_DuplicateDetect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DuplicateDetectRequest, DuplicateDetectResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImportSST_DuplicateDetectClient = grpc.ServerStreamingClient[DuplicateDetectResponse]

func (c *importSSTClient) Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyResponse)
	err := c.cc.Invoke(ctx, ImportSST_Apply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) ClearFiles(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*ClearResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearResponse)
	err := c.cc.Invoke(ctx, ImportSST_ClearFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) SuspendImportRPC(ctx context.Context, in *SuspendImportRPCRequest, opts ...grpc.CallOption) (*SuspendImportRPCResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SuspendImportRPCResponse)
	err := c.cc.Invoke(ctx, ImportSST_SuspendImportRPC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) AddForcePartitionRange(ctx context.Context, in *AddPartitionRangeRequest, opts ...grpc.CallOption) (*AddPartitionRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddPartitionRangeResponse)
	err := c.cc.Invoke(ctx, ImportSST_AddForcePartitionRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) RemoveForcePartitionRange(ctx context.Context, in *RemovePartitionRangeRequest, opts ...grpc.CallOption) (*RemovePartitionRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemovePartitionRangeResponse)
	err := c.cc.Invoke(ctx, ImportSST_RemoveForcePartitionRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImportSSTServer is the server API for ImportSST service.
// All implementations must embed UnimplementedImportSSTServer
// for forward compatibility.
//
// ImportSST provides a service to import a generated SST file to a region in TiKV.
//
// In order to import an SST file to a region, the user should:
// 1. Retrieve the meta of the region according to the SST file's range.
// 2. Upload the SST file to the servers where the region's peers locate in.
// 3. Issue an ingest request to the region's leader with the SST file's metadata.
//
// It's the user's responsibility to make sure that the SST file is uploaded to
// the servers where the region's peers locate in, before issue the ingest
// request to the region's leader. However, the region can be scheduled (so the
// location of the region's peers will be changed) or split/merged (so the range
// of the region will be changed), after the SST file is uploaded, but before
// the SST file is ingested. So, the region's epoch is provided in the SST
// file's metadata, to guarantee that the region's epoch must be the same
// between the SST file is uploaded and ingested later.
type ImportSSTServer interface {
	// Switch to normal/import mode.
	SwitchMode(context.Context, *SwitchModeRequest) (*SwitchModeResponse, error)
	// Get import mode(normal/import).
	GetMode(context.Context, *GetModeRequest) (*GetModeResponse, error)
	// Upload an SST file to a server.
	Upload(grpc.ClientStreamingServer[UploadRequest, UploadResponse]) error
	// Ingest an uploaded SST file to a region.
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
	// Compact the specific range for better performance.
	Compact(context.Context, *CompactRequest) (*CompactResponse, error)
	SetDownloadSpeedLimit(context.Context, *SetDownloadSpeedLimitRequest) (*SetDownloadSpeedLimitResponse, error)
	// Download an SST file from an external storage, and performs key-rewrite
	// after downloading.
	Download(context.Context, *DownloadRequest) (*DownloadResponse, error)
	// Batch download SST files from an external storage, and performs key-rewrite
	// after downloading.
	BatchDownload(context.Context, *DownloadRequest) (*DownloadResponse, error)
	// Open a write stream to generate sst files
	Write(grpc.ClientStreamingServer[WriteRequest, WriteResponse]) error
	RawWrite(grpc.ClientStreamingServer[RawWriteRequest, RawWriteResponse]) error
	// Ingest Multiple files in one request
	MultiIngest(context.Context, *MultiIngestRequest) (*IngestResponse, error)
	// Collect duplicate data from TiKV.
	DuplicateDetect(*DuplicateDetectRequest, grpc.ServerStreamingServer[DuplicateDetectResponse]) error
	// Apply download & apply increment kv files to TiKV.
	Apply(context.Context, *ApplyRequest) (*ApplyResponse, error)
	// ClearFiles clear applied file after restore succeed.
	ClearFiles(context.Context, *ClearRequest) (*ClearResponse, error)
	// Suspend ingest for data listeners don't support catching import data.
	SuspendImportRPC(context.Context, *SuspendImportRPCRequest) (*SuspendImportRPCResponse, error)
	// AddForcePartitionRange marks a range in tikv that any compact overlaps with this range
	// should generates SST files partitioned at region boundaries as well as this range boundary.
	// TiKV will also try to do manual compact(if needed) after setting this range to eusure
	// any incoming SST under this range can be ingested into the bottom level if there is no real kv overlap.
	AddForcePartitionRange(context.Context, *AddPartitionRangeRequest) (*AddPartitionRangeResponse, error)
	// Remove the force partition range after the task is finished. If this function is not called,
	// tikv will cleanup the range after TTL to ensure it can be cleaned eventually.
	RemoveForcePartitionRange(context.Context, *RemovePartitionRangeRequest) (*RemovePartitionRangeResponse, error)
	mustEmbedUnimplementedImportSSTServer()
}

// UnimplementedImportSSTServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImportSSTServer struct{}

func (UnimplementedImportSSTServer) SwitchMode(context.Context, *SwitchModeRequest) (*SwitchModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwitchMode not implemented")
}
func (UnimplementedImportSSTServer) GetMode(context.Context, *GetModeRequest) (*GetModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMode not implemented")
}
func (UnimplementedImportSSTServer) Upload(grpc.ClientStreamingServer[UploadRequest, UploadResponse]) error {
	return status.Error(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedImportSSTServer) Ingest(context.Context, *IngestRequest) (*IngestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ingest not implemented")
}
func (UnimplementedImportSSTServer) Compact(context.Context, *CompactRequest) (*CompactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Compact not implemented")
}
func (UnimplementedImportSSTServer) SetDownloadSpeedLimit(context.Context, *SetDownloadSpeedLimitRequest) (*SetDownloadSpeedLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDownloadSpeedLimit not implemented")
}
func (UnimplementedImportSSTServer) Download(context.Context, *DownloadRequest) (*DownloadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Download not implemented")
}
func (UnimplementedImportSSTServer) BatchDownload(context.Context, *DownloadRequest) (*DownloadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchDownload not implemented")
}
func (UnimplementedImportSSTServer) Write(grpc.ClientStreamingServer[WriteRequest, WriteResponse]) error {
	return status.Error(codes.Unimplemented, "method Write not implemented")
}
func (UnimplementedImportSSTServer) RawWrite(grpc.ClientStreamingServer[RawWriteRequest, RawWriteResponse]) error {
	return status.Error(codes.Unimplemented, "method RawWrite not implemented")
}
func (UnimplementedImportSSTServer) MultiIngest(context.Context, *MultiIngestRequest) (*IngestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MultiIngest not implemented")
}
func (UnimplementedImportSSTServer) DuplicateDetect(*DuplicateDetectRequest, grpc.ServerStreamingServer[DuplicateDetectResponse]) error {
	return status.Error(codes.Unimplemented, "method DuplicateDetect not implemented")
}
func (UnimplementedImportSSTServer) Apply(context.Context, *ApplyRequest) (*ApplyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Apply not implemented")
}
func (UnimplementedImportSSTServer) ClearFiles(context.Context, *ClearRequest) (*ClearResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearFiles not implemented")
}
func (UnimplementedImportSSTServer) SuspendImportRPC(context.Context, *SuspendImportRPCRequest) (*SuspendImportRPCResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SuspendImportRPC not implemented")
}
func (UnimplementedImportSSTServer) AddForcePartitionRange(context.Context, *AddPartitionRangeRequest) (*AddPartitionRangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddForcePartitionRange not implemented")
}
func (UnimplementedImportSSTServer) RemoveForcePartitionRange(context.Context, *RemovePartitionRangeRequest) (*RemovePartitionRangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveForcePartitionRange not implemented")
}
func (UnimplementedImportSSTServer) mustEmbedUnimplementedImportSSTServer() {}
func (UnimplementedImportSSTServer) testEmbeddedByValue()                   {}

// UnsafeImportSSTServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImportSSTServer will
// result in compilation errors.
type UnsafeImportSSTServer interface {
	mustEmbedUnimplementedImportSSTServer()
}

func RegisterImportSSTServer(s grpc.ServiceRegistrar, srv ImportSSTServer) {
	// If the following call panics, it indicates UnimplementedImportSSTServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ImportSST_ServiceDesc, srv)
}

func _ImportSST_SwitchMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).SwitchMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_SwitchMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).SwitchMode(ctx, req.(*SwitchModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_GetMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).GetMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_GetMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).GetMode(ctx, req.(*GetModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).Upload(&grpc.GenericServerStream[UploadRequest, UploadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImportSST_UploadServer = grpc.ClientStreamingServer[UploadRequest, UploadResponse]

func _ImportSST_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_Ingest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_Compact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Compact(ctx, req.(*CompactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_SetDownloadSpeedLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDownloadSpeedLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).SetDownloadSpeedLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_SetDownloadSpeedLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).SetDownloadSpeedLimit(ctx, req.(*SetDownloadSpeedLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_Download_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Download(ctx, req.(*DownloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_BatchDownload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).BatchDownload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_BatchDownload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).BatchDownload(ctx, req.(*DownloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).Write(&grpc.GenericServerStream[WriteRequest, WriteResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImportSST_WriteServer = grpc.ClientStreamingServer[WriteRequest, WriteResponse]

func _ImportSST_RawWrite_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).RawWrite(&grpc.GenericServerStream[RawWriteRequest, RawWriteResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImportSST_RawWriteServer = grpc.ClientStreamingServer[RawWriteRequest, RawWriteResponse]

func _ImportSST_MultiIngest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultiIngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).MultiIngest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_MultiIngest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).MultiIngest(ctx, req.(*MultiIngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_DuplicateDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DuplicateDetectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImportSSTServer).DuplicateDetect(m, &grpc.GenericServerStream[DuplicateDetectRequest, DuplicateDetectResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImportSST_DuplicateDetectServer = grpc.ServerStreamingServer[DuplicateDetectResponse]

func _ImportSST_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_Apply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Apply(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_ClearFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).ClearFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_ClearFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).ClearFiles(ctx, req.(*ClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_SuspendImportRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendImportRPCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).SuspendImportRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_SuspendImportRPC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).SuspendImportRPC(ctx, req.(*SuspendImportRPCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_AddForcePartitionRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPartitionRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).AddForcePartitionRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_AddForcePartitionRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).AddForcePartitionRange(ctx, req.(*AddPartitionRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_RemoveForcePartitionRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePartitionRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).RemoveForcePartitionRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImportSST_RemoveForcePartitionRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).RemoveForcePartitionRange(ctx, req.(*RemovePartitionRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ImportSST_ServiceDesc is the grpc.ServiceDesc for ImportSST service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImportSST_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "import_sstpb.ImportSST",
	HandlerType: (*ImportSSTServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SwitchMode",
			Handler:    _ImportSST_SwitchMode_Handler,
		},
		{
			MethodName: "GetMode",
			Handler:    _ImportSST_GetMode_Handler,
		},
		{
			MethodName: "Ingest",
			Handler:    _ImportSST_Ingest_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _ImportSST_Compact_Handler,
		},
		{
			MethodName: "SetDownloadSpeedLimit",
			Handler:    _ImportSST_SetDownloadSpeedLimit_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _ImportSST_Download_Handler,
		},
		{
			MethodName: "BatchDownload",
			Handler:    _ImportSST_BatchDownload_Handler,
		},
		{
			MethodName: "MultiIngest",
			Handler:    _ImportSST_MultiIngest_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _ImportSST_Apply_Handler,
		},
		{
			MethodName: "ClearFiles",
			Handler:    _ImportSST_ClearFiles_Handler,
		},
		{
			MethodName: "SuspendImportRPC",
			Handler:    _ImportSST_SuspendImportRPC_Handler,
		},
		{
			MethodName: "AddForcePartitionRange",
			Handler:    _ImportSST_AddForcePartitionRange_Handler,
		},
		{
			MethodName: "RemoveForcePartitionRange",
			Handler:    _ImportSST_RemoveForcePartitionRange_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _ImportSST_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Write",
			Handler:       _ImportSST_Write_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "RawWrite",
			Handler:       _ImportSST_RawWrite_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DuplicateDetect",
			Handler:       _ImportSST_DuplicateDetect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "import_sstpb.proto",
}
