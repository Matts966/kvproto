// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: pdpb.proto

package pdpb

import (
	"context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PD_GetClusterInfo_FullMethodName           = "/pdpb.PD/GetClusterInfo"
	PD_GetMembers_FullMethodName               = "/pdpb.PD/GetMembers"
	PD_Tso_FullMethodName                      = "/pdpb.PD/Tso"
	PD_Bootstrap_FullMethodName                = "/pdpb.PD/Bootstrap"
	PD_IsBootstrapped_FullMethodName           = "/pdpb.PD/IsBootstrapped"
	PD_AllocID_FullMethodName                  = "/pdpb.PD/AllocID"
	PD_IsSnapshotRecovering_FullMethodName     = "/pdpb.PD/IsSnapshotRecovering"
	PD_GetStore_FullMethodName                 = "/pdpb.PD/GetStore"
	PD_PutStore_FullMethodName                 = "/pdpb.PD/PutStore"
	PD_GetAllStores_FullMethodName             = "/pdpb.PD/GetAllStores"
	PD_StoreHeartbeat_FullMethodName           = "/pdpb.PD/StoreHeartbeat"
	PD_RegionHeartbeat_FullMethodName          = "/pdpb.PD/RegionHeartbeat"
	PD_GetRegion_FullMethodName                = "/pdpb.PD/GetRegion"
	PD_GetPrevRegion_FullMethodName            = "/pdpb.PD/GetPrevRegion"
	PD_GetRegionByID_FullMethodName            = "/pdpb.PD/GetRegionByID"
	PD_QueryRegion_FullMethodName              = "/pdpb.PD/QueryRegion"
	PD_ScanRegions_FullMethodName              = "/pdpb.PD/ScanRegions"
	PD_BatchScanRegions_FullMethodName         = "/pdpb.PD/BatchScanRegions"
	PD_AskSplit_FullMethodName                 = "/pdpb.PD/AskSplit"
	PD_ReportSplit_FullMethodName              = "/pdpb.PD/ReportSplit"
	PD_AskBatchSplit_FullMethodName            = "/pdpb.PD/AskBatchSplit"
	PD_ReportBatchSplit_FullMethodName         = "/pdpb.PD/ReportBatchSplit"
	PD_GetClusterConfig_FullMethodName         = "/pdpb.PD/GetClusterConfig"
	PD_PutClusterConfig_FullMethodName         = "/pdpb.PD/PutClusterConfig"
	PD_ScatterRegion_FullMethodName            = "/pdpb.PD/ScatterRegion"
	PD_GetGCSafePoint_FullMethodName           = "/pdpb.PD/GetGCSafePoint"
	PD_UpdateGCSafePoint_FullMethodName        = "/pdpb.PD/UpdateGCSafePoint"
	PD_UpdateServiceGCSafePoint_FullMethodName = "/pdpb.PD/UpdateServiceGCSafePoint"
	PD_GetGCSafePointV2_FullMethodName         = "/pdpb.PD/GetGCSafePointV2"
	PD_WatchGCSafePointV2_FullMethodName       = "/pdpb.PD/WatchGCSafePointV2"
	PD_UpdateGCSafePointV2_FullMethodName      = "/pdpb.PD/UpdateGCSafePointV2"
	PD_UpdateServiceSafePointV2_FullMethodName = "/pdpb.PD/UpdateServiceSafePointV2"
	PD_GetAllGCSafePointV2_FullMethodName      = "/pdpb.PD/GetAllGCSafePointV2"
	PD_AdvanceGCSafePoint_FullMethodName       = "/pdpb.PD/AdvanceGCSafePoint"
	PD_AdvanceTxnSafePoint_FullMethodName      = "/pdpb.PD/AdvanceTxnSafePoint"
	PD_SetGCBarrier_FullMethodName             = "/pdpb.PD/SetGCBarrier"
	PD_DeleteGCBarrier_FullMethodName          = "/pdpb.PD/DeleteGCBarrier"
	PD_SetGlobalGCBarrier_FullMethodName       = "/pdpb.PD/SetGlobalGCBarrier"
	PD_DeleteGlobalGCBarrier_FullMethodName    = "/pdpb.PD/DeleteGlobalGCBarrier"
	PD_GetGCState_FullMethodName               = "/pdpb.PD/GetGCState"
	PD_GetAllKeyspacesGCStates_FullMethodName  = "/pdpb.PD/GetAllKeyspacesGCStates"
	PD_SyncRegions_FullMethodName              = "/pdpb.PD/SyncRegions"
	PD_GetOperator_FullMethodName              = "/pdpb.PD/GetOperator"
	PD_SyncMaxTS_FullMethodName                = "/pdpb.PD/SyncMaxTS"
	PD_SplitRegions_FullMethodName             = "/pdpb.PD/SplitRegions"
	PD_SplitAndScatterRegions_FullMethodName   = "/pdpb.PD/SplitAndScatterRegions"
	PD_GetDCLocationInfo_FullMethodName        = "/pdpb.PD/GetDCLocationInfo"
	PD_StoreGlobalConfig_FullMethodName        = "/pdpb.PD/StoreGlobalConfig"
	PD_LoadGlobalConfig_FullMethodName         = "/pdpb.PD/LoadGlobalConfig"
	PD_WatchGlobalConfig_FullMethodName        = "/pdpb.PD/WatchGlobalConfig"
	PD_ReportBuckets_FullMethodName            = "/pdpb.PD/ReportBuckets"
	PD_ReportMinResolvedTS_FullMethodName      = "/pdpb.PD/ReportMinResolvedTS"
	PD_SetExternalTimestamp_FullMethodName     = "/pdpb.PD/SetExternalTimestamp"
	PD_GetExternalTimestamp_FullMethodName     = "/pdpb.PD/GetExternalTimestamp"
	PD_GetMinTS_FullMethodName                 = "/pdpb.PD/GetMinTS"
)

// PDClient is the client API for PD service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PDClient interface {
	// GetClusterInfo get the information of this cluster. It does not require
	// the cluster_id in request matchs the id of this cluster.
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	// GetMembers get the member list of this cluster. It does not require
	// the cluster_id in request matchs the id of this cluster.
	GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*GetMembersResponse, error)
	Tso(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[TsoRequest, TsoResponse], error)
	Bootstrap(ctx context.Context, in *BootstrapRequest, opts ...grpc.CallOption) (*BootstrapResponse, error)
	IsBootstrapped(ctx context.Context, in *IsBootstrappedRequest, opts ...grpc.CallOption) (*IsBootstrappedResponse, error)
	AllocID(ctx context.Context, in *AllocIDRequest, opts ...grpc.CallOption) (*AllocIDResponse, error)
	IsSnapshotRecovering(ctx context.Context, in *IsSnapshotRecoveringRequest, opts ...grpc.CallOption) (*IsSnapshotRecoveringResponse, error)
	GetStore(ctx context.Context, in *GetStoreRequest, opts ...grpc.CallOption) (*GetStoreResponse, error)
	PutStore(ctx context.Context, in *PutStoreRequest, opts ...grpc.CallOption) (*PutStoreResponse, error)
	GetAllStores(ctx context.Context, in *GetAllStoresRequest, opts ...grpc.CallOption) (*GetAllStoresResponse, error)
	StoreHeartbeat(ctx context.Context, in *StoreHeartbeatRequest, opts ...grpc.CallOption) (*StoreHeartbeatResponse, error)
	RegionHeartbeat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[RegionHeartbeatRequest, RegionHeartbeatResponse], error)
	GetRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*GetRegionResponse, error)
	GetPrevRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*GetRegionResponse, error)
	GetRegionByID(ctx context.Context, in *GetRegionByIDRequest, opts ...grpc.CallOption) (*GetRegionResponse, error)
	QueryRegion(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[QueryRegionRequest, QueryRegionResponse], error)
	// Deprecated: use BatchScanRegions instead.
	ScanRegions(ctx context.Context, in *ScanRegionsRequest, opts ...grpc.CallOption) (*ScanRegionsResponse, error)
	BatchScanRegions(ctx context.Context, in *BatchScanRegionsRequest, opts ...grpc.CallOption) (*BatchScanRegionsResponse, error)
	// Deprecated: Do not use.
	AskSplit(ctx context.Context, in *AskSplitRequest, opts ...grpc.CallOption) (*AskSplitResponse, error)
	// Deprecated: Do not use.
	ReportSplit(ctx context.Context, in *ReportSplitRequest, opts ...grpc.CallOption) (*ReportSplitResponse, error)
	AskBatchSplit(ctx context.Context, in *AskBatchSplitRequest, opts ...grpc.CallOption) (*AskBatchSplitResponse, error)
	ReportBatchSplit(ctx context.Context, in *ReportBatchSplitRequest, opts ...grpc.CallOption) (*ReportBatchSplitResponse, error)
	GetClusterConfig(ctx context.Context, in *GetClusterConfigRequest, opts ...grpc.CallOption) (*GetClusterConfigResponse, error)
	PutClusterConfig(ctx context.Context, in *PutClusterConfigRequest, opts ...grpc.CallOption) (*PutClusterConfigResponse, error)
	ScatterRegion(ctx context.Context, in *ScatterRegionRequest, opts ...grpc.CallOption) (*ScatterRegionResponse, error)
	GetGCSafePoint(ctx context.Context, in *GetGCSafePointRequest, opts ...grpc.CallOption) (*GetGCSafePointResponse, error)
	UpdateGCSafePoint(ctx context.Context, in *UpdateGCSafePointRequest, opts ...grpc.CallOption) (*UpdateGCSafePointResponse, error)
	UpdateServiceGCSafePoint(ctx context.Context, in *UpdateServiceGCSafePointRequest, opts ...grpc.CallOption) (*UpdateServiceGCSafePointResponse, error)
	GetGCSafePointV2(ctx context.Context, in *GetGCSafePointV2Request, opts ...grpc.CallOption) (*GetGCSafePointV2Response, error)
	WatchGCSafePointV2(ctx context.Context, in *WatchGCSafePointV2Request, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchGCSafePointV2Response], error)
	UpdateGCSafePointV2(ctx context.Context, in *UpdateGCSafePointV2Request, opts ...grpc.CallOption) (*UpdateGCSafePointV2Response, error)
	UpdateServiceSafePointV2(ctx context.Context, in *UpdateServiceSafePointV2Request, opts ...grpc.CallOption) (*UpdateServiceSafePointV2Response, error)
	GetAllGCSafePointV2(ctx context.Context, in *GetAllGCSafePointV2Request, opts ...grpc.CallOption) (*GetAllGCSafePointV2Response, error)
	AdvanceGCSafePoint(ctx context.Context, in *AdvanceGCSafePointRequest, opts ...grpc.CallOption) (*AdvanceGCSafePointResponse, error)
	AdvanceTxnSafePoint(ctx context.Context, in *AdvanceTxnSafePointRequest, opts ...grpc.CallOption) (*AdvanceTxnSafePointResponse, error)
	SetGCBarrier(ctx context.Context, in *SetGCBarrierRequest, opts ...grpc.CallOption) (*SetGCBarrierResponse, error)
	DeleteGCBarrier(ctx context.Context, in *DeleteGCBarrierRequest, opts ...grpc.CallOption) (*DeleteGCBarrierResponse, error)
	SetGlobalGCBarrier(ctx context.Context, in *SetGlobalGCBarrierRequest, opts ...grpc.CallOption) (*SetGlobalGCBarrierResponse, error)
	DeleteGlobalGCBarrier(ctx context.Context, in *DeleteGlobalGCBarrierRequest, opts ...grpc.CallOption) (*DeleteGlobalGCBarrierResponse, error)
	GetGCState(ctx context.Context, in *GetGCStateRequest, opts ...grpc.CallOption) (*GetGCStateResponse, error)
	GetAllKeyspacesGCStates(ctx context.Context, in *GetAllKeyspacesGCStatesRequest, opts ...grpc.CallOption) (*GetAllKeyspacesGCStatesResponse, error)
	SyncRegions(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SyncRegionRequest, SyncRegionResponse], error)
	GetOperator(ctx context.Context, in *GetOperatorRequest, opts ...grpc.CallOption) (*GetOperatorResponse, error)
	SyncMaxTS(ctx context.Context, in *SyncMaxTSRequest, opts ...grpc.CallOption) (*SyncMaxTSResponse, error)
	SplitRegions(ctx context.Context, in *SplitRegionsRequest, opts ...grpc.CallOption) (*SplitRegionsResponse, error)
	SplitAndScatterRegions(ctx context.Context, in *SplitAndScatterRegionsRequest, opts ...grpc.CallOption) (*SplitAndScatterRegionsResponse, error)
	GetDCLocationInfo(ctx context.Context, in *GetDCLocationInfoRequest, opts ...grpc.CallOption) (*GetDCLocationInfoResponse, error)
	StoreGlobalConfig(ctx context.Context, in *StoreGlobalConfigRequest, opts ...grpc.CallOption) (*StoreGlobalConfigResponse, error)
	LoadGlobalConfig(ctx context.Context, in *LoadGlobalConfigRequest, opts ...grpc.CallOption) (*LoadGlobalConfigResponse, error)
	WatchGlobalConfig(ctx context.Context, in *WatchGlobalConfigRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchGlobalConfigResponse], error)
	ReportBuckets(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ReportBucketsRequest, ReportBucketsResponse], error)
	ReportMinResolvedTS(ctx context.Context, in *ReportMinResolvedTsRequest, opts ...grpc.CallOption) (*ReportMinResolvedTsResponse, error)
	SetExternalTimestamp(ctx context.Context, in *SetExternalTimestampRequest, opts ...grpc.CallOption) (*SetExternalTimestampResponse, error)
	GetExternalTimestamp(ctx context.Context, in *GetExternalTimestampRequest, opts ...grpc.CallOption) (*GetExternalTimestampResponse, error)
	// Get the minimum timestamp across all keyspace groups from API server
	// TODO: Currently, we need to ask API server to get the minimum timestamp.
	// Once we support service discovery, we can remove it.
	GetMinTS(ctx context.Context, in *GetMinTSRequest, opts ...grpc.CallOption) (*GetMinTSResponse, error)
}

type pDClient struct {
	cc grpc.ClientConnInterface
}

func NewPDClient(cc grpc.ClientConnInterface) PDClient {
	return &pDClient{cc}
}

func (c *pDClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, PD_GetClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*GetMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMembersResponse)
	err := c.cc.Invoke(ctx, PD_GetMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) Tso(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[TsoRequest, TsoResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PD_ServiceDesc.Streams[0], PD_Tso_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TsoRequest, TsoResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_TsoClient = grpc.BidiStreamingClient[TsoRequest, TsoResponse]

func (c *pDClient) Bootstrap(ctx context.Context, in *BootstrapRequest, opts ...grpc.CallOption) (*BootstrapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BootstrapResponse)
	err := c.cc.Invoke(ctx, PD_Bootstrap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) IsBootstrapped(ctx context.Context, in *IsBootstrappedRequest, opts ...grpc.CallOption) (*IsBootstrappedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsBootstrappedResponse)
	err := c.cc.Invoke(ctx, PD_IsBootstrapped_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) AllocID(ctx context.Context, in *AllocIDRequest, opts ...grpc.CallOption) (*AllocIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllocIDResponse)
	err := c.cc.Invoke(ctx, PD_AllocID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) IsSnapshotRecovering(ctx context.Context, in *IsSnapshotRecoveringRequest, opts ...grpc.CallOption) (*IsSnapshotRecoveringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsSnapshotRecoveringResponse)
	err := c.cc.Invoke(ctx, PD_IsSnapshotRecovering_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetStore(ctx context.Context, in *GetStoreRequest, opts ...grpc.CallOption) (*GetStoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStoreResponse)
	err := c.cc.Invoke(ctx, PD_GetStore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) PutStore(ctx context.Context, in *PutStoreRequest, opts ...grpc.CallOption) (*PutStoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PutStoreResponse)
	err := c.cc.Invoke(ctx, PD_PutStore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetAllStores(ctx context.Context, in *GetAllStoresRequest, opts ...grpc.CallOption) (*GetAllStoresResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllStoresResponse)
	err := c.cc.Invoke(ctx, PD_GetAllStores_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) StoreHeartbeat(ctx context.Context, in *StoreHeartbeatRequest, opts ...grpc.CallOption) (*StoreHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreHeartbeatResponse)
	err := c.cc.Invoke(ctx, PD_StoreHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) RegionHeartbeat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[RegionHeartbeatRequest, RegionHeartbeatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PD_ServiceDesc.Streams[1], PD_RegionHeartbeat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RegionHeartbeatRequest, RegionHeartbeatResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_RegionHeartbeatClient = grpc.BidiStreamingClient[RegionHeartbeatRequest, RegionHeartbeatResponse]

func (c *pDClient) GetRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*GetRegionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegionResponse)
	err := c.cc.Invoke(ctx, PD_GetRegion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetPrevRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*GetRegionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegionResponse)
	err := c.cc.Invoke(ctx, PD_GetPrevRegion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetRegionByID(ctx context.Context, in *GetRegionByIDRequest, opts ...grpc.CallOption) (*GetRegionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegionResponse)
	err := c.cc.Invoke(ctx, PD_GetRegionByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) QueryRegion(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[QueryRegionRequest, QueryRegionResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PD_ServiceDesc.Streams[2], PD_QueryRegion_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[QueryRegionRequest, QueryRegionResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_QueryRegionClient = grpc.BidiStreamingClient[QueryRegionRequest, QueryRegionResponse]

func (c *pDClient) ScanRegions(ctx context.Context, in *ScanRegionsRequest, opts ...grpc.CallOption) (*ScanRegionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScanRegionsResponse)
	err := c.cc.Invoke(ctx, PD_ScanRegions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) BatchScanRegions(ctx context.Context, in *BatchScanRegionsRequest, opts ...grpc.CallOption) (*BatchScanRegionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchScanRegionsResponse)
	err := c.cc.Invoke(ctx, PD_BatchScanRegions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *pDClient) AskSplit(ctx context.Context, in *AskSplitRequest, opts ...grpc.CallOption) (*AskSplitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AskSplitResponse)
	err := c.cc.Invoke(ctx, PD_AskSplit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *pDClient) ReportSplit(ctx context.Context, in *ReportSplitRequest, opts ...grpc.CallOption) (*ReportSplitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportSplitResponse)
	err := c.cc.Invoke(ctx, PD_ReportSplit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) AskBatchSplit(ctx context.Context, in *AskBatchSplitRequest, opts ...grpc.CallOption) (*AskBatchSplitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AskBatchSplitResponse)
	err := c.cc.Invoke(ctx, PD_AskBatchSplit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) ReportBatchSplit(ctx context.Context, in *ReportBatchSplitRequest, opts ...grpc.CallOption) (*ReportBatchSplitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportBatchSplitResponse)
	err := c.cc.Invoke(ctx, PD_ReportBatchSplit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetClusterConfig(ctx context.Context, in *GetClusterConfigRequest, opts ...grpc.CallOption) (*GetClusterConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterConfigResponse)
	err := c.cc.Invoke(ctx, PD_GetClusterConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) PutClusterConfig(ctx context.Context, in *PutClusterConfigRequest, opts ...grpc.CallOption) (*PutClusterConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PutClusterConfigResponse)
	err := c.cc.Invoke(ctx, PD_PutClusterConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) ScatterRegion(ctx context.Context, in *ScatterRegionRequest, opts ...grpc.CallOption) (*ScatterRegionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScatterRegionResponse)
	err := c.cc.Invoke(ctx, PD_ScatterRegion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetGCSafePoint(ctx context.Context, in *GetGCSafePointRequest, opts ...grpc.CallOption) (*GetGCSafePointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGCSafePointResponse)
	err := c.cc.Invoke(ctx, PD_GetGCSafePoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) UpdateGCSafePoint(ctx context.Context, in *UpdateGCSafePointRequest, opts ...grpc.CallOption) (*UpdateGCSafePointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGCSafePointResponse)
	err := c.cc.Invoke(ctx, PD_UpdateGCSafePoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) UpdateServiceGCSafePoint(ctx context.Context, in *UpdateServiceGCSafePointRequest, opts ...grpc.CallOption) (*UpdateServiceGCSafePointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateServiceGCSafePointResponse)
	err := c.cc.Invoke(ctx, PD_UpdateServiceGCSafePoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetGCSafePointV2(ctx context.Context, in *GetGCSafePointV2Request, opts ...grpc.CallOption) (*GetGCSafePointV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGCSafePointV2Response)
	err := c.cc.Invoke(ctx, PD_GetGCSafePointV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) WatchGCSafePointV2(ctx context.Context, in *WatchGCSafePointV2Request, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchGCSafePointV2Response], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PD_ServiceDesc.Streams[3], PD_WatchGCSafePointV2_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchGCSafePointV2Request, WatchGCSafePointV2Response]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_WatchGCSafePointV2Client = grpc.ServerStreamingClient[WatchGCSafePointV2Response]

func (c *pDClient) UpdateGCSafePointV2(ctx context.Context, in *UpdateGCSafePointV2Request, opts ...grpc.CallOption) (*UpdateGCSafePointV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGCSafePointV2Response)
	err := c.cc.Invoke(ctx, PD_UpdateGCSafePointV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) UpdateServiceSafePointV2(ctx context.Context, in *UpdateServiceSafePointV2Request, opts ...grpc.CallOption) (*UpdateServiceSafePointV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateServiceSafePointV2Response)
	err := c.cc.Invoke(ctx, PD_UpdateServiceSafePointV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetAllGCSafePointV2(ctx context.Context, in *GetAllGCSafePointV2Request, opts ...grpc.CallOption) (*GetAllGCSafePointV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllGCSafePointV2Response)
	err := c.cc.Invoke(ctx, PD_GetAllGCSafePointV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) AdvanceGCSafePoint(ctx context.Context, in *AdvanceGCSafePointRequest, opts ...grpc.CallOption) (*AdvanceGCSafePointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdvanceGCSafePointResponse)
	err := c.cc.Invoke(ctx, PD_AdvanceGCSafePoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) AdvanceTxnSafePoint(ctx context.Context, in *AdvanceTxnSafePointRequest, opts ...grpc.CallOption) (*AdvanceTxnSafePointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdvanceTxnSafePointResponse)
	err := c.cc.Invoke(ctx, PD_AdvanceTxnSafePoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SetGCBarrier(ctx context.Context, in *SetGCBarrierRequest, opts ...grpc.CallOption) (*SetGCBarrierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetGCBarrierResponse)
	err := c.cc.Invoke(ctx, PD_SetGCBarrier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) DeleteGCBarrier(ctx context.Context, in *DeleteGCBarrierRequest, opts ...grpc.CallOption) (*DeleteGCBarrierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGCBarrierResponse)
	err := c.cc.Invoke(ctx, PD_DeleteGCBarrier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SetGlobalGCBarrier(ctx context.Context, in *SetGlobalGCBarrierRequest, opts ...grpc.CallOption) (*SetGlobalGCBarrierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetGlobalGCBarrierResponse)
	err := c.cc.Invoke(ctx, PD_SetGlobalGCBarrier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) DeleteGlobalGCBarrier(ctx context.Context, in *DeleteGlobalGCBarrierRequest, opts ...grpc.CallOption) (*DeleteGlobalGCBarrierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGlobalGCBarrierResponse)
	err := c.cc.Invoke(ctx, PD_DeleteGlobalGCBarrier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetGCState(ctx context.Context, in *GetGCStateRequest, opts ...grpc.CallOption) (*GetGCStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGCStateResponse)
	err := c.cc.Invoke(ctx, PD_GetGCState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetAllKeyspacesGCStates(ctx context.Context, in *GetAllKeyspacesGCStatesRequest, opts ...grpc.CallOption) (*GetAllKeyspacesGCStatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllKeyspacesGCStatesResponse)
	err := c.cc.Invoke(ctx, PD_GetAllKeyspacesGCStates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SyncRegions(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SyncRegionRequest, SyncRegionResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PD_ServiceDesc.Streams[4], PD_SyncRegions_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncRegionRequest, SyncRegionResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_SyncRegionsClient = grpc.BidiStreamingClient[SyncRegionRequest, SyncRegionResponse]

func (c *pDClient) GetOperator(ctx context.Context, in *GetOperatorRequest, opts ...grpc.CallOption) (*GetOperatorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOperatorResponse)
	err := c.cc.Invoke(ctx, PD_GetOperator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SyncMaxTS(ctx context.Context, in *SyncMaxTSRequest, opts ...grpc.CallOption) (*SyncMaxTSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncMaxTSResponse)
	err := c.cc.Invoke(ctx, PD_SyncMaxTS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SplitRegions(ctx context.Context, in *SplitRegionsRequest, opts ...grpc.CallOption) (*SplitRegionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SplitRegionsResponse)
	err := c.cc.Invoke(ctx, PD_SplitRegions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SplitAndScatterRegions(ctx context.Context, in *SplitAndScatterRegionsRequest, opts ...grpc.CallOption) (*SplitAndScatterRegionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SplitAndScatterRegionsResponse)
	err := c.cc.Invoke(ctx, PD_SplitAndScatterRegions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetDCLocationInfo(ctx context.Context, in *GetDCLocationInfoRequest, opts ...grpc.CallOption) (*GetDCLocationInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDCLocationInfoResponse)
	err := c.cc.Invoke(ctx, PD_GetDCLocationInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) StoreGlobalConfig(ctx context.Context, in *StoreGlobalConfigRequest, opts ...grpc.CallOption) (*StoreGlobalConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreGlobalConfigResponse)
	err := c.cc.Invoke(ctx, PD_StoreGlobalConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) LoadGlobalConfig(ctx context.Context, in *LoadGlobalConfigRequest, opts ...grpc.CallOption) (*LoadGlobalConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadGlobalConfigResponse)
	err := c.cc.Invoke(ctx, PD_LoadGlobalConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) WatchGlobalConfig(ctx context.Context, in *WatchGlobalConfigRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchGlobalConfigResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PD_ServiceDesc.Streams[5], PD_WatchGlobalConfig_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchGlobalConfigRequest, WatchGlobalConfigResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_WatchGlobalConfigClient = grpc.ServerStreamingClient[WatchGlobalConfigResponse]

func (c *pDClient) ReportBuckets(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ReportBucketsRequest, ReportBucketsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PD_ServiceDesc.Streams[6], PD_ReportBuckets_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReportBucketsRequest, ReportBucketsResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_ReportBucketsClient = grpc.ClientStreamingClient[ReportBucketsRequest, ReportBucketsResponse]

func (c *pDClient) ReportMinResolvedTS(ctx context.Context, in *ReportMinResolvedTsRequest, opts ...grpc.CallOption) (*ReportMinResolvedTsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportMinResolvedTsResponse)
	err := c.cc.Invoke(ctx, PD_ReportMinResolvedTS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) SetExternalTimestamp(ctx context.Context, in *SetExternalTimestampRequest, opts ...grpc.CallOption) (*SetExternalTimestampResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetExternalTimestampResponse)
	err := c.cc.Invoke(ctx, PD_SetExternalTimestamp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetExternalTimestamp(ctx context.Context, in *GetExternalTimestampRequest, opts ...grpc.CallOption) (*GetExternalTimestampResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExternalTimestampResponse)
	err := c.cc.Invoke(ctx, PD_GetExternalTimestamp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pDClient) GetMinTS(ctx context.Context, in *GetMinTSRequest, opts ...grpc.CallOption) (*GetMinTSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMinTSResponse)
	err := c.cc.Invoke(ctx, PD_GetMinTS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PDServer is the server API for PD service.
// All implementations must embed UnimplementedPDServer
// for forward compatibility.
type PDServer interface {
	// GetClusterInfo get the information of this cluster. It does not require
	// the cluster_id in request matchs the id of this cluster.
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	// GetMembers get the member list of this cluster. It does not require
	// the cluster_id in request matchs the id of this cluster.
	GetMembers(context.Context, *GetMembersRequest) (*GetMembersResponse, error)
	Tso(grpc.BidiStreamingServer[TsoRequest, TsoResponse]) error
	Bootstrap(context.Context, *BootstrapRequest) (*BootstrapResponse, error)
	IsBootstrapped(context.Context, *IsBootstrappedRequest) (*IsBootstrappedResponse, error)
	AllocID(context.Context, *AllocIDRequest) (*AllocIDResponse, error)
	IsSnapshotRecovering(context.Context, *IsSnapshotRecoveringRequest) (*IsSnapshotRecoveringResponse, error)
	GetStore(context.Context, *GetStoreRequest) (*GetStoreResponse, error)
	PutStore(context.Context, *PutStoreRequest) (*PutStoreResponse, error)
	GetAllStores(context.Context, *GetAllStoresRequest) (*GetAllStoresResponse, error)
	StoreHeartbeat(context.Context, *StoreHeartbeatRequest) (*StoreHeartbeatResponse, error)
	RegionHeartbeat(grpc.BidiStreamingServer[RegionHeartbeatRequest, RegionHeartbeatResponse]) error
	GetRegion(context.Context, *GetRegionRequest) (*GetRegionResponse, error)
	GetPrevRegion(context.Context, *GetRegionRequest) (*GetRegionResponse, error)
	GetRegionByID(context.Context, *GetRegionByIDRequest) (*GetRegionResponse, error)
	QueryRegion(grpc.BidiStreamingServer[QueryRegionRequest, QueryRegionResponse]) error
	// Deprecated: use BatchScanRegions instead.
	ScanRegions(context.Context, *ScanRegionsRequest) (*ScanRegionsResponse, error)
	BatchScanRegions(context.Context, *BatchScanRegionsRequest) (*BatchScanRegionsResponse, error)
	// Deprecated: Do not use.
	AskSplit(context.Context, *AskSplitRequest) (*AskSplitResponse, error)
	// Deprecated: Do not use.
	ReportSplit(context.Context, *ReportSplitRequest) (*ReportSplitResponse, error)
	AskBatchSplit(context.Context, *AskBatchSplitRequest) (*AskBatchSplitResponse, error)
	ReportBatchSplit(context.Context, *ReportBatchSplitRequest) (*ReportBatchSplitResponse, error)
	GetClusterConfig(context.Context, *GetClusterConfigRequest) (*GetClusterConfigResponse, error)
	PutClusterConfig(context.Context, *PutClusterConfigRequest) (*PutClusterConfigResponse, error)
	ScatterRegion(context.Context, *ScatterRegionRequest) (*ScatterRegionResponse, error)
	GetGCSafePoint(context.Context, *GetGCSafePointRequest) (*GetGCSafePointResponse, error)
	UpdateGCSafePoint(context.Context, *UpdateGCSafePointRequest) (*UpdateGCSafePointResponse, error)
	UpdateServiceGCSafePoint(context.Context, *UpdateServiceGCSafePointRequest) (*UpdateServiceGCSafePointResponse, error)
	GetGCSafePointV2(context.Context, *GetGCSafePointV2Request) (*GetGCSafePointV2Response, error)
	WatchGCSafePointV2(*WatchGCSafePointV2Request, grpc.ServerStreamingServer[WatchGCSafePointV2Response]) error
	UpdateGCSafePointV2(context.Context, *UpdateGCSafePointV2Request) (*UpdateGCSafePointV2Response, error)
	UpdateServiceSafePointV2(context.Context, *UpdateServiceSafePointV2Request) (*UpdateServiceSafePointV2Response, error)
	GetAllGCSafePointV2(context.Context, *GetAllGCSafePointV2Request) (*GetAllGCSafePointV2Response, error)
	AdvanceGCSafePoint(context.Context, *AdvanceGCSafePointRequest) (*AdvanceGCSafePointResponse, error)
	AdvanceTxnSafePoint(context.Context, *AdvanceTxnSafePointRequest) (*AdvanceTxnSafePointResponse, error)
	SetGCBarrier(context.Context, *SetGCBarrierRequest) (*SetGCBarrierResponse, error)
	DeleteGCBarrier(context.Context, *DeleteGCBarrierRequest) (*DeleteGCBarrierResponse, error)
	SetGlobalGCBarrier(context.Context, *SetGlobalGCBarrierRequest) (*SetGlobalGCBarrierResponse, error)
	DeleteGlobalGCBarrier(context.Context, *DeleteGlobalGCBarrierRequest) (*DeleteGlobalGCBarrierResponse, error)
	GetGCState(context.Context, *GetGCStateRequest) (*GetGCStateResponse, error)
	GetAllKeyspacesGCStates(context.Context, *GetAllKeyspacesGCStatesRequest) (*GetAllKeyspacesGCStatesResponse, error)
	SyncRegions(grpc.BidiStreamingServer[SyncRegionRequest, SyncRegionResponse]) error
	GetOperator(context.Context, *GetOperatorRequest) (*GetOperatorResponse, error)
	SyncMaxTS(context.Context, *SyncMaxTSRequest) (*SyncMaxTSResponse, error)
	SplitRegions(context.Context, *SplitRegionsRequest) (*SplitRegionsResponse, error)
	SplitAndScatterRegions(context.Context, *SplitAndScatterRegionsRequest) (*SplitAndScatterRegionsResponse, error)
	GetDCLocationInfo(context.Context, *GetDCLocationInfoRequest) (*GetDCLocationInfoResponse, error)
	StoreGlobalConfig(context.Context, *StoreGlobalConfigRequest) (*StoreGlobalConfigResponse, error)
	LoadGlobalConfig(context.Context, *LoadGlobalConfigRequest) (*LoadGlobalConfigResponse, error)
	WatchGlobalConfig(*WatchGlobalConfigRequest, grpc.ServerStreamingServer[WatchGlobalConfigResponse]) error
	ReportBuckets(grpc.ClientStreamingServer[ReportBucketsRequest, ReportBucketsResponse]) error
	ReportMinResolvedTS(context.Context, *ReportMinResolvedTsRequest) (*ReportMinResolvedTsResponse, error)
	SetExternalTimestamp(context.Context, *SetExternalTimestampRequest) (*SetExternalTimestampResponse, error)
	GetExternalTimestamp(context.Context, *GetExternalTimestampRequest) (*GetExternalTimestampResponse, error)
	// Get the minimum timestamp across all keyspace groups from API server
	// TODO: Currently, we need to ask API server to get the minimum timestamp.
	// Once we support service discovery, we can remove it.
	GetMinTS(context.Context, *GetMinTSRequest) (*GetMinTSResponse, error)
	mustEmbedUnimplementedPDServer()
}

// UnimplementedPDServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPDServer struct{}

func (UnimplementedPDServer) GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedPDServer) GetMembers(context.Context, *GetMembersRequest) (*GetMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMembers not implemented")
}
func (UnimplementedPDServer) Tso(grpc.BidiStreamingServer[TsoRequest, TsoResponse]) error {
	return status.Error(codes.Unimplemented, "method Tso not implemented")
}
func (UnimplementedPDServer) Bootstrap(context.Context, *BootstrapRequest) (*BootstrapResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Bootstrap not implemented")
}
func (UnimplementedPDServer) IsBootstrapped(context.Context, *IsBootstrappedRequest) (*IsBootstrappedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsBootstrapped not implemented")
}
func (UnimplementedPDServer) AllocID(context.Context, *AllocIDRequest) (*AllocIDResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AllocID not implemented")
}
func (UnimplementedPDServer) IsSnapshotRecovering(context.Context, *IsSnapshotRecoveringRequest) (*IsSnapshotRecoveringResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsSnapshotRecovering not implemented")
}
func (UnimplementedPDServer) GetStore(context.Context, *GetStoreRequest) (*GetStoreResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStore not implemented")
}
func (UnimplementedPDServer) PutStore(context.Context, *PutStoreRequest) (*PutStoreResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PutStore not implemented")
}
func (UnimplementedPDServer) GetAllStores(context.Context, *GetAllStoresRequest) (*GetAllStoresResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllStores not implemented")
}
func (UnimplementedPDServer) StoreHeartbeat(context.Context, *StoreHeartbeatRequest) (*StoreHeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StoreHeartbeat not implemented")
}
func (UnimplementedPDServer) RegionHeartbeat(grpc.BidiStreamingServer[RegionHeartbeatRequest, RegionHeartbeatResponse]) error {
	return status.Error(codes.Unimplemented, "method RegionHeartbeat not implemented")
}
func (UnimplementedPDServer) GetRegion(context.Context, *GetRegionRequest) (*GetRegionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRegion not implemented")
}
func (UnimplementedPDServer) GetPrevRegion(context.Context, *GetRegionRequest) (*GetRegionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPrevRegion not implemented")
}
func (UnimplementedPDServer) GetRegionByID(context.Context, *GetRegionByIDRequest) (*GetRegionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRegionByID not implemented")
}
func (UnimplementedPDServer) QueryRegion(grpc.BidiStreamingServer[QueryRegionRequest, QueryRegionResponse]) error {
	return status.Error(codes.Unimplemented, "method QueryRegion not implemented")
}
func (UnimplementedPDServer) ScanRegions(context.Context, *ScanRegionsRequest) (*ScanRegionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScanRegions not implemented")
}
func (UnimplementedPDServer) BatchScanRegions(context.Context, *BatchScanRegionsRequest) (*BatchScanRegionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchScanRegions not implemented")
}
func (UnimplementedPDServer) AskSplit(context.Context, *AskSplitRequest) (*AskSplitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AskSplit not implemented")
}
func (UnimplementedPDServer) ReportSplit(context.Context, *ReportSplitRequest) (*ReportSplitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportSplit not implemented")
}
func (UnimplementedPDServer) AskBatchSplit(context.Context, *AskBatchSplitRequest) (*AskBatchSplitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AskBatchSplit not implemented")
}
func (UnimplementedPDServer) ReportBatchSplit(context.Context, *ReportBatchSplitRequest) (*ReportBatchSplitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportBatchSplit not implemented")
}
func (UnimplementedPDServer) GetClusterConfig(context.Context, *GetClusterConfigRequest) (*GetClusterConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterConfig not implemented")
}
func (UnimplementedPDServer) PutClusterConfig(context.Context, *PutClusterConfigRequest) (*PutClusterConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PutClusterConfig not implemented")
}
func (UnimplementedPDServer) ScatterRegion(context.Context, *ScatterRegionRequest) (*ScatterRegionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScatterRegion not implemented")
}
func (UnimplementedPDServer) GetGCSafePoint(context.Context, *GetGCSafePointRequest) (*GetGCSafePointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGCSafePoint not implemented")
}
func (UnimplementedPDServer) UpdateGCSafePoint(context.Context, *UpdateGCSafePointRequest) (*UpdateGCSafePointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateGCSafePoint not implemented")
}
func (UnimplementedPDServer) UpdateServiceGCSafePoint(context.Context, *UpdateServiceGCSafePointRequest) (*UpdateServiceGCSafePointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateServiceGCSafePoint not implemented")
}
func (UnimplementedPDServer) GetGCSafePointV2(context.Context, *GetGCSafePointV2Request) (*GetGCSafePointV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGCSafePointV2 not implemented")
}
func (UnimplementedPDServer) WatchGCSafePointV2(*WatchGCSafePointV2Request, grpc.ServerStreamingServer[WatchGCSafePointV2Response]) error {
	return status.Error(codes.Unimplemented, "method WatchGCSafePointV2 not implemented")
}
func (UnimplementedPDServer) UpdateGCSafePointV2(context.Context, *UpdateGCSafePointV2Request) (*UpdateGCSafePointV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateGCSafePointV2 not implemented")
}
func (UnimplementedPDServer) UpdateServiceSafePointV2(context.Context, *UpdateServiceSafePointV2Request) (*UpdateServiceSafePointV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateServiceSafePointV2 not implemented")
}
func (UnimplementedPDServer) GetAllGCSafePointV2(context.Context, *GetAllGCSafePointV2Request) (*GetAllGCSafePointV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllGCSafePointV2 not implemented")
}
func (UnimplementedPDServer) AdvanceGCSafePoint(context.Context, *AdvanceGCSafePointRequest) (*AdvanceGCSafePointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AdvanceGCSafePoint not implemented")
}
func (UnimplementedPDServer) AdvanceTxnSafePoint(context.Context, *AdvanceTxnSafePointRequest) (*AdvanceTxnSafePointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AdvanceTxnSafePoint not implemented")
}
func (UnimplementedPDServer) SetGCBarrier(context.Context, *SetGCBarrierRequest) (*SetGCBarrierResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetGCBarrier not implemented")
}
func (UnimplementedPDServer) DeleteGCBarrier(context.Context, *DeleteGCBarrierRequest) (*DeleteGCBarrierResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteGCBarrier not implemented")
}
func (UnimplementedPDServer) SetGlobalGCBarrier(context.Context, *SetGlobalGCBarrierRequest) (*SetGlobalGCBarrierResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetGlobalGCBarrier not implemented")
}
func (UnimplementedPDServer) DeleteGlobalGCBarrier(context.Context, *DeleteGlobalGCBarrierRequest) (*DeleteGlobalGCBarrierResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteGlobalGCBarrier not implemented")
}
func (UnimplementedPDServer) GetGCState(context.Context, *GetGCStateRequest) (*GetGCStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGCState not implemented")
}
func (UnimplementedPDServer) GetAllKeyspacesGCStates(context.Context, *GetAllKeyspacesGCStatesRequest) (*GetAllKeyspacesGCStatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllKeyspacesGCStates not implemented")
}
func (UnimplementedPDServer) SyncRegions(grpc.BidiStreamingServer[SyncRegionRequest, SyncRegionResponse]) error {
	return status.Error(codes.Unimplemented, "method SyncRegions not implemented")
}
func (UnimplementedPDServer) GetOperator(context.Context, *GetOperatorRequest) (*GetOperatorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOperator not implemented")
}
func (UnimplementedPDServer) SyncMaxTS(context.Context, *SyncMaxTSRequest) (*SyncMaxTSResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncMaxTS not implemented")
}
func (UnimplementedPDServer) SplitRegions(context.Context, *SplitRegionsRequest) (*SplitRegionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SplitRegions not implemented")
}
func (UnimplementedPDServer) SplitAndScatterRegions(context.Context, *SplitAndScatterRegionsRequest) (*SplitAndScatterRegionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SplitAndScatterRegions not implemented")
}
func (UnimplementedPDServer) GetDCLocationInfo(context.Context, *GetDCLocationInfoRequest) (*GetDCLocationInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDCLocationInfo not implemented")
}
func (UnimplementedPDServer) StoreGlobalConfig(context.Context, *StoreGlobalConfigRequest) (*StoreGlobalConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StoreGlobalConfig not implemented")
}
func (UnimplementedPDServer) LoadGlobalConfig(context.Context, *LoadGlobalConfigRequest) (*LoadGlobalConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoadGlobalConfig not implemented")
}
func (UnimplementedPDServer) WatchGlobalConfig(*WatchGlobalConfigRequest, grpc.ServerStreamingServer[WatchGlobalConfigResponse]) error {
	return status.Error(codes.Unimplemented, "method WatchGlobalConfig not implemented")
}
func (UnimplementedPDServer) ReportBuckets(grpc.ClientStreamingServer[ReportBucketsRequest, ReportBucketsResponse]) error {
	return status.Error(codes.Unimplemented, "method ReportBuckets not implemented")
}
func (UnimplementedPDServer) ReportMinResolvedTS(context.Context, *ReportMinResolvedTsRequest) (*ReportMinResolvedTsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportMinResolvedTS not implemented")
}
func (UnimplementedPDServer) SetExternalTimestamp(context.Context, *SetExternalTimestampRequest) (*SetExternalTimestampResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetExternalTimestamp not implemented")
}
func (UnimplementedPDServer) GetExternalTimestamp(context.Context, *GetExternalTimestampRequest) (*GetExternalTimestampResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetExternalTimestamp not implemented")
}
func (UnimplementedPDServer) GetMinTS(context.Context, *GetMinTSRequest) (*GetMinTSResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMinTS not implemented")
}
func (UnimplementedPDServer) mustEmbedUnimplementedPDServer() {}
func (UnimplementedPDServer) testEmbeddedByValue()            {}

// UnsafePDServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PDServer will
// result in compilation errors.
type UnsafePDServer interface {
	mustEmbedUnimplementedPDServer()
}

func RegisterPDServer(s grpc.ServiceRegistrar, srv PDServer) {
	// If the following call panics, it indicates UnimplementedPDServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PD_ServiceDesc, srv)
}

func _PD_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetMembers(ctx, req.(*GetMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_Tso_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).Tso(&grpc.GenericServerStream[TsoRequest, TsoResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_TsoServer = grpc.BidiStreamingServer[TsoRequest, TsoResponse]

func _PD_Bootstrap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootstrapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).Bootstrap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_Bootstrap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).Bootstrap(ctx, req.(*BootstrapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_IsBootstrapped_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsBootstrappedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).IsBootstrapped(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_IsBootstrapped_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).IsBootstrapped(ctx, req.(*IsBootstrappedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_AllocID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).AllocID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_AllocID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).AllocID(ctx, req.(*AllocIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_IsSnapshotRecovering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsSnapshotRecoveringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).IsSnapshotRecovering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_IsSnapshotRecovering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).IsSnapshotRecovering(ctx, req.(*IsSnapshotRecoveringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetStore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetStore(ctx, req.(*GetStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_PutStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).PutStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_PutStore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).PutStore(ctx, req.(*PutStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetAllStores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllStoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetAllStores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetAllStores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetAllStores(ctx, req.(*GetAllStoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_StoreHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).StoreHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_StoreHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).StoreHeartbeat(ctx, req.(*StoreHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_RegionHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).RegionHeartbeat(&grpc.GenericServerStream[RegionHeartbeatRequest, RegionHeartbeatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_RegionHeartbeatServer = grpc.BidiStreamingServer[RegionHeartbeatRequest, RegionHeartbeatResponse]

func _PD_GetRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetRegion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetRegion(ctx, req.(*GetRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetPrevRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetPrevRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetPrevRegion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetPrevRegion(ctx, req.(*GetRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetRegionByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetRegionByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetRegionByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetRegionByID(ctx, req.(*GetRegionByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_QueryRegion_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).QueryRegion(&grpc.GenericServerStream[QueryRegionRequest, QueryRegionResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_QueryRegionServer = grpc.BidiStreamingServer[QueryRegionRequest, QueryRegionResponse]

func _PD_ScanRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ScanRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_ScanRegions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ScanRegions(ctx, req.(*ScanRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_BatchScanRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchScanRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).BatchScanRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_BatchScanRegions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).BatchScanRegions(ctx, req.(*BatchScanRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_AskSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AskSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).AskSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_AskSplit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).AskSplit(ctx, req.(*AskSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_ReportSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ReportSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_ReportSplit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ReportSplit(ctx, req.(*ReportSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_AskBatchSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AskBatchSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).AskBatchSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_AskBatchSplit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).AskBatchSplit(ctx, req.(*AskBatchSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_ReportBatchSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportBatchSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ReportBatchSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_ReportBatchSplit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ReportBatchSplit(ctx, req.(*ReportBatchSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetClusterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetClusterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetClusterConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetClusterConfig(ctx, req.(*GetClusterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_PutClusterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutClusterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).PutClusterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_PutClusterConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).PutClusterConfig(ctx, req.(*PutClusterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_ScatterRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScatterRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ScatterRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_ScatterRegion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ScatterRegion(ctx, req.(*ScatterRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetGCSafePoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGCSafePointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetGCSafePoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetGCSafePoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetGCSafePoint(ctx, req.(*GetGCSafePointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_UpdateGCSafePoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGCSafePointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).UpdateGCSafePoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_UpdateGCSafePoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).UpdateGCSafePoint(ctx, req.(*UpdateGCSafePointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_UpdateServiceGCSafePoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateServiceGCSafePointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).UpdateServiceGCSafePoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_UpdateServiceGCSafePoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).UpdateServiceGCSafePoint(ctx, req.(*UpdateServiceGCSafePointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetGCSafePointV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGCSafePointV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetGCSafePointV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetGCSafePointV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetGCSafePointV2(ctx, req.(*GetGCSafePointV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_WatchGCSafePointV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchGCSafePointV2Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PDServer).WatchGCSafePointV2(m, &grpc.GenericServerStream[WatchGCSafePointV2Request, WatchGCSafePointV2Response]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_WatchGCSafePointV2Server = grpc.ServerStreamingServer[WatchGCSafePointV2Response]

func _PD_UpdateGCSafePointV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGCSafePointV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).UpdateGCSafePointV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_UpdateGCSafePointV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).UpdateGCSafePointV2(ctx, req.(*UpdateGCSafePointV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_UpdateServiceSafePointV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateServiceSafePointV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).UpdateServiceSafePointV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_UpdateServiceSafePointV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).UpdateServiceSafePointV2(ctx, req.(*UpdateServiceSafePointV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetAllGCSafePointV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllGCSafePointV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetAllGCSafePointV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetAllGCSafePointV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetAllGCSafePointV2(ctx, req.(*GetAllGCSafePointV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_AdvanceGCSafePoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdvanceGCSafePointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).AdvanceGCSafePoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_AdvanceGCSafePoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).AdvanceGCSafePoint(ctx, req.(*AdvanceGCSafePointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_AdvanceTxnSafePoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdvanceTxnSafePointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).AdvanceTxnSafePoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_AdvanceTxnSafePoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).AdvanceTxnSafePoint(ctx, req.(*AdvanceTxnSafePointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SetGCBarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGCBarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SetGCBarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_SetGCBarrier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SetGCBarrier(ctx, req.(*SetGCBarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_DeleteGCBarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGCBarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).DeleteGCBarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_DeleteGCBarrier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).DeleteGCBarrier(ctx, req.(*DeleteGCBarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SetGlobalGCBarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGlobalGCBarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SetGlobalGCBarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_SetGlobalGCBarrier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SetGlobalGCBarrier(ctx, req.(*SetGlobalGCBarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_DeleteGlobalGCBarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGlobalGCBarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).DeleteGlobalGCBarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_DeleteGlobalGCBarrier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).DeleteGlobalGCBarrier(ctx, req.(*DeleteGlobalGCBarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetGCState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGCStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetGCState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetGCState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetGCState(ctx, req.(*GetGCStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetAllKeyspacesGCStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllKeyspacesGCStatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetAllKeyspacesGCStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetAllKeyspacesGCStates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetAllKeyspacesGCStates(ctx, req.(*GetAllKeyspacesGCStatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SyncRegions_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).SyncRegions(&grpc.GenericServerStream[SyncRegionRequest, SyncRegionResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_SyncRegionsServer = grpc.BidiStreamingServer[SyncRegionRequest, SyncRegionResponse]

func _PD_GetOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetOperator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetOperator(ctx, req.(*GetOperatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SyncMaxTS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMaxTSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SyncMaxTS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_SyncMaxTS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SyncMaxTS(ctx, req.(*SyncMaxTSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SplitRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SplitRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SplitRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_SplitRegions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SplitRegions(ctx, req.(*SplitRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SplitAndScatterRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SplitAndScatterRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SplitAndScatterRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_SplitAndScatterRegions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SplitAndScatterRegions(ctx, req.(*SplitAndScatterRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetDCLocationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDCLocationInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetDCLocationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetDCLocationInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetDCLocationInfo(ctx, req.(*GetDCLocationInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_StoreGlobalConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreGlobalConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).StoreGlobalConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_StoreGlobalConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).StoreGlobalConfig(ctx, req.(*StoreGlobalConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_LoadGlobalConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadGlobalConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).LoadGlobalConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_LoadGlobalConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).LoadGlobalConfig(ctx, req.(*LoadGlobalConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_WatchGlobalConfig_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchGlobalConfigRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PDServer).WatchGlobalConfig(m, &grpc.GenericServerStream[WatchGlobalConfigRequest, WatchGlobalConfigResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_WatchGlobalConfigServer = grpc.ServerStreamingServer[WatchGlobalConfigResponse]

func _PD_ReportBuckets_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PDServer).ReportBuckets(&grpc.GenericServerStream[ReportBucketsRequest, ReportBucketsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PD_ReportBucketsServer = grpc.ClientStreamingServer[ReportBucketsRequest, ReportBucketsResponse]

func _PD_ReportMinResolvedTS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportMinResolvedTsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).ReportMinResolvedTS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_ReportMinResolvedTS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).ReportMinResolvedTS(ctx, req.(*ReportMinResolvedTsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_SetExternalTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetExternalTimestampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).SetExternalTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_SetExternalTimestamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).SetExternalTimestamp(ctx, req.(*SetExternalTimestampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetExternalTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExternalTimestampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetExternalTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetExternalTimestamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetExternalTimestamp(ctx, req.(*GetExternalTimestampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PD_GetMinTS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMinTSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDServer).GetMinTS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PD_GetMinTS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDServer).GetMinTS(ctx, req.(*GetMinTSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PD_ServiceDesc is the grpc.ServiceDesc for PD service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PD_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pdpb.PD",
	HandlerType: (*PDServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusterInfo",
			Handler:    _PD_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetMembers",
			Handler:    _PD_GetMembers_Handler,
		},
		{
			MethodName: "Bootstrap",
			Handler:    _PD_Bootstrap_Handler,
		},
		{
			MethodName: "IsBootstrapped",
			Handler:    _PD_IsBootstrapped_Handler,
		},
		{
			MethodName: "AllocID",
			Handler:    _PD_AllocID_Handler,
		},
		{
			MethodName: "IsSnapshotRecovering",
			Handler:    _PD_IsSnapshotRecovering_Handler,
		},
		{
			MethodName: "GetStore",
			Handler:    _PD_GetStore_Handler,
		},
		{
			MethodName: "PutStore",
			Handler:    _PD_PutStore_Handler,
		},
		{
			MethodName: "GetAllStores",
			Handler:    _PD_GetAllStores_Handler,
		},
		{
			MethodName: "StoreHeartbeat",
			Handler:    _PD_StoreHeartbeat_Handler,
		},
		{
			MethodName: "GetRegion",
			Handler:    _PD_GetRegion_Handler,
		},
		{
			MethodName: "GetPrevRegion",
			Handler:    _PD_GetPrevRegion_Handler,
		},
		{
			MethodName: "GetRegionByID",
			Handler:    _PD_GetRegionByID_Handler,
		},
		{
			MethodName: "ScanRegions",
			Handler:    _PD_ScanRegions_Handler,
		},
		{
			MethodName: "BatchScanRegions",
			Handler:    _PD_BatchScanRegions_Handler,
		},
		{
			MethodName: "AskSplit",
			Handler:    _PD_AskSplit_Handler,
		},
		{
			MethodName: "ReportSplit",
			Handler:    _PD_ReportSplit_Handler,
		},
		{
			MethodName: "AskBatchSplit",
			Handler:    _PD_AskBatchSplit_Handler,
		},
		{
			MethodName: "ReportBatchSplit",
			Handler:    _PD_ReportBatchSplit_Handler,
		},
		{
			MethodName: "GetClusterConfig",
			Handler:    _PD_GetClusterConfig_Handler,
		},
		{
			MethodName: "PutClusterConfig",
			Handler:    _PD_PutClusterConfig_Handler,
		},
		{
			MethodName: "ScatterRegion",
			Handler:    _PD_ScatterRegion_Handler,
		},
		{
			MethodName: "GetGCSafePoint",
			Handler:    _PD_GetGCSafePoint_Handler,
		},
		{
			MethodName: "UpdateGCSafePoint",
			Handler:    _PD_UpdateGCSafePoint_Handler,
		},
		{
			MethodName: "UpdateServiceGCSafePoint",
			Handler:    _PD_UpdateServiceGCSafePoint_Handler,
		},
		{
			MethodName: "GetGCSafePointV2",
			Handler:    _PD_GetGCSafePointV2_Handler,
		},
		{
			MethodName: "UpdateGCSafePointV2",
			Handler:    _PD_UpdateGCSafePointV2_Handler,
		},
		{
			MethodName: "UpdateServiceSafePointV2",
			Handler:    _PD_UpdateServiceSafePointV2_Handler,
		},
		{
			MethodName: "GetAllGCSafePointV2",
			Handler:    _PD_GetAllGCSafePointV2_Handler,
		},
		{
			MethodName: "AdvanceGCSafePoint",
			Handler:    _PD_AdvanceGCSafePoint_Handler,
		},
		{
			MethodName: "AdvanceTxnSafePoint",
			Handler:    _PD_AdvanceTxnSafePoint_Handler,
		},
		{
			MethodName: "SetGCBarrier",
			Handler:    _PD_SetGCBarrier_Handler,
		},
		{
			MethodName: "DeleteGCBarrier",
			Handler:    _PD_DeleteGCBarrier_Handler,
		},
		{
			MethodName: "SetGlobalGCBarrier",
			Handler:    _PD_SetGlobalGCBarrier_Handler,
		},
		{
			MethodName: "DeleteGlobalGCBarrier",
			Handler:    _PD_DeleteGlobalGCBarrier_Handler,
		},
		{
			MethodName: "GetGCState",
			Handler:    _PD_GetGCState_Handler,
		},
		{
			MethodName: "GetAllKeyspacesGCStates",
			Handler:    _PD_GetAllKeyspacesGCStates_Handler,
		},
		{
			MethodName: "GetOperator",
			Handler:    _PD_GetOperator_Handler,
		},
		{
			MethodName: "SyncMaxTS",
			Handler:    _PD_SyncMaxTS_Handler,
		},
		{
			MethodName: "SplitRegions",
			Handler:    _PD_SplitRegions_Handler,
		},
		{
			MethodName: "SplitAndScatterRegions",
			Handler:    _PD_SplitAndScatterRegions_Handler,
		},
		{
			MethodName: "GetDCLocationInfo",
			Handler:    _PD_GetDCLocationInfo_Handler,
		},
		{
			MethodName: "StoreGlobalConfig",
			Handler:    _PD_StoreGlobalConfig_Handler,
		},
		{
			MethodName: "LoadGlobalConfig",
			Handler:    _PD_LoadGlobalConfig_Handler,
		},
		{
			MethodName: "ReportMinResolvedTS",
			Handler:    _PD_ReportMinResolvedTS_Handler,
		},
		{
			MethodName: "SetExternalTimestamp",
			Handler:    _PD_SetExternalTimestamp_Handler,
		},
		{
			MethodName: "GetExternalTimestamp",
			Handler:    _PD_GetExternalTimestamp_Handler,
		},
		{
			MethodName: "GetMinTS",
			Handler:    _PD_GetMinTS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Tso",
			Handler:       _PD_Tso_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "RegionHeartbeat",
			Handler:       _PD_RegionHeartbeat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "QueryRegion",
			Handler:       _PD_QueryRegion_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "WatchGCSafePointV2",
			Handler:       _PD_WatchGCSafePointV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SyncRegions",
			Handler:       _PD_SyncRegions_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "WatchGlobalConfig",
			Handler:       _PD_WatchGlobalConfig_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReportBuckets",
			Handler:       _PD_ReportBuckets_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pdpb.proto",
}
