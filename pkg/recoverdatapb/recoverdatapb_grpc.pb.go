// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: recoverdatapb.proto

package recoverdatapb

import (
	"context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RecoverData_ReadRegionMeta_FullMethodName = "/recover_data.RecoverData/ReadRegionMeta"
	RecoverData_RecoverRegion_FullMethodName  = "/recover_data.RecoverData/RecoverRegion"
	RecoverData_WaitApply_FullMethodName      = "/recover_data.RecoverData/WaitApply"
	RecoverData_ResolveKvData_FullMethodName  = "/recover_data.RecoverData/ResolveKvData"
)

// RecoverDataClient is the client API for RecoverData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// a recovery workflow likes
// 1. BR read ReadRegionMeta to get all region meta
// 2. BR send recover region to tikv, e.g assign leader and wait leader apply to last index
// 3. BR wait all regions in tikv to apply to last index (no write during the recovery)
// 4. BR resolved kv data
type RecoverDataClient interface {
	// read region meta to ready region meta
	ReadRegionMeta(ctx context.Context, in *ReadRegionMetaRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RegionMeta], error)
	// execute the recovery command
	RecoverRegion(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[RecoverRegionRequest, RecoverRegionResponse], error)
	// wait all region apply to last index
	WaitApply(ctx context.Context, in *WaitApplyRequest, opts ...grpc.CallOption) (*WaitApplyResponse, error)
	// execute delete data from kv db
	ResolveKvData(ctx context.Context, in *ResolveKvDataRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ResolveKvDataResponse], error)
}

type recoverDataClient struct {
	cc grpc.ClientConnInterface
}

func NewRecoverDataClient(cc grpc.ClientConnInterface) RecoverDataClient {
	return &recoverDataClient{cc}
}

func (c *recoverDataClient) ReadRegionMeta(ctx context.Context, in *ReadRegionMetaRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RegionMeta], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RecoverData_ServiceDesc.Streams[0], RecoverData_ReadRegionMeta_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReadRegionMetaRequest, RegionMeta]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RecoverData_ReadRegionMetaClient = grpc.ServerStreamingClient[RegionMeta]

func (c *recoverDataClient) RecoverRegion(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[RecoverRegionRequest, RecoverRegionResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RecoverData_ServiceDesc.Streams[1], RecoverData_RecoverRegion_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RecoverRegionRequest, RecoverRegionResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RecoverData_RecoverRegionClient = grpc.ClientStreamingClient[RecoverRegionRequest, RecoverRegionResponse]

func (c *recoverDataClient) WaitApply(ctx context.Context, in *WaitApplyRequest, opts ...grpc.CallOption) (*WaitApplyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WaitApplyResponse)
	err := c.cc.Invoke(ctx, RecoverData_WaitApply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *recoverDataClient) ResolveKvData(ctx context.Context, in *ResolveKvDataRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ResolveKvDataResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RecoverData_ServiceDesc.Streams[2], RecoverData_ResolveKvData_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ResolveKvDataRequest, ResolveKvDataResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RecoverData_ResolveKvDataClient = grpc.ServerStreamingClient[ResolveKvDataResponse]

// RecoverDataServer is the server API for RecoverData service.
// All implementations must embed UnimplementedRecoverDataServer
// for forward compatibility.
//
// a recovery workflow likes
// 1. BR read ReadRegionMeta to get all region meta
// 2. BR send recover region to tikv, e.g assign leader and wait leader apply to last index
// 3. BR wait all regions in tikv to apply to last index (no write during the recovery)
// 4. BR resolved kv data
type RecoverDataServer interface {
	// read region meta to ready region meta
	ReadRegionMeta(*ReadRegionMetaRequest, grpc.ServerStreamingServer[RegionMeta]) error
	// execute the recovery command
	RecoverRegion(grpc.ClientStreamingServer[RecoverRegionRequest, RecoverRegionResponse]) error
	// wait all region apply to last index
	WaitApply(context.Context, *WaitApplyRequest) (*WaitApplyResponse, error)
	// execute delete data from kv db
	ResolveKvData(*ResolveKvDataRequest, grpc.ServerStreamingServer[ResolveKvDataResponse]) error
	mustEmbedUnimplementedRecoverDataServer()
}

// UnimplementedRecoverDataServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRecoverDataServer struct{}

func (UnimplementedRecoverDataServer) ReadRegionMeta(*ReadRegionMetaRequest, grpc.ServerStreamingServer[RegionMeta]) error {
	return status.Error(codes.Unimplemented, "method ReadRegionMeta not implemented")
}
func (UnimplementedRecoverDataServer) RecoverRegion(grpc.ClientStreamingServer[RecoverRegionRequest, RecoverRegionResponse]) error {
	return status.Error(codes.Unimplemented, "method RecoverRegion not implemented")
}
func (UnimplementedRecoverDataServer) WaitApply(context.Context, *WaitApplyRequest) (*WaitApplyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WaitApply not implemented")
}
func (UnimplementedRecoverDataServer) ResolveKvData(*ResolveKvDataRequest, grpc.ServerStreamingServer[ResolveKvDataResponse]) error {
	return status.Error(codes.Unimplemented, "method ResolveKvData not implemented")
}
func (UnimplementedRecoverDataServer) mustEmbedUnimplementedRecoverDataServer() {}
func (UnimplementedRecoverDataServer) testEmbeddedByValue()                     {}

// UnsafeRecoverDataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RecoverDataServer will
// result in compilation errors.
type UnsafeRecoverDataServer interface {
	mustEmbedUnimplementedRecoverDataServer()
}

func RegisterRecoverDataServer(s grpc.ServiceRegistrar, srv RecoverDataServer) {
	// If the following call panics, it indicates UnimplementedRecoverDataServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RecoverData_ServiceDesc, srv)
}

func _RecoverData_ReadRegionMeta_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRegionMetaRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RecoverDataServer).ReadRegionMeta(m, &grpc.GenericServerStream[ReadRegionMetaRequest, RegionMeta]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RecoverData_ReadRegionMetaServer = grpc.ServerStreamingServer[RegionMeta]

func _RecoverData_RecoverRegion_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RecoverDataServer).RecoverRegion(&grpc.GenericServerStream[RecoverRegionRequest, RecoverRegionResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RecoverData_RecoverRegionServer = grpc.ClientStreamingServer[RecoverRegionRequest, RecoverRegionResponse]

func _RecoverData_WaitApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecoverDataServer).WaitApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RecoverData_WaitApply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecoverDataServer).WaitApply(ctx, req.(*WaitApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RecoverData_ResolveKvData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ResolveKvDataRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RecoverDataServer).ResolveKvData(m, &grpc.GenericServerStream[ResolveKvDataRequest, ResolveKvDataResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RecoverData_ResolveKvDataServer = grpc.ServerStreamingServer[ResolveKvDataResponse]

// RecoverData_ServiceDesc is the grpc.ServiceDesc for RecoverData service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RecoverData_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "recover_data.RecoverData",
	HandlerType: (*RecoverDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WaitApply",
			Handler:    _RecoverData_WaitApply_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadRegionMeta",
			Handler:       _RecoverData_ReadRegionMeta_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverRegion",
			Handler:       _RecoverData_RecoverRegion_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ResolveKvData",
			Handler:       _RecoverData_ResolveKvData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "recoverdatapb.proto",
}
