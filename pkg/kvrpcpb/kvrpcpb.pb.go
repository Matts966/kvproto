// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: kvrpcpb.proto

package kvrpcpb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	deadlock "github.com/pingcap/kvproto/pkg/deadlock"
	errorpb "github.com/pingcap/kvproto/pkg/errorpb"
	metapb "github.com/pingcap/kvproto/pkg/metapb"
	resource_manager "github.com/pingcap/kvproto/pkg/resource_manager"
	tracepb "github.com/pingcap/kvproto/pkg/tracepb"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Used to specify the behavior when a pessimistic lock request is woken up after waiting for another
// lock.
type PessimisticLockWakeUpMode int32

const (
	// When woken up, returns WriteConflict error to the client and the client should retry if necessary.
	// In this mode, results of `return_values` or `check_existence` will be set to `values` and `not_founds`
	// fields of the PessimisticLockResponse, which is compatible with old versions.
	PessimisticLockWakeUpMode_WakeUpModeNormal PessimisticLockWakeUpMode = 0
	// When woken up, continue trying to lock the key. This implicitly enables the `allow_lock_with_conflict`
	// behavior, which means, allow acquiring the lock even if there is WriteConflict on the key.
	// In this mode, `return_values` or `check_existence` fields of PessimisticLockResponse won't be used, and
	// all results are carried in the `results` field.
	PessimisticLockWakeUpMode_WakeUpModeForceLock PessimisticLockWakeUpMode = 1
)

// Enum value maps for PessimisticLockWakeUpMode.
var (
	PessimisticLockWakeUpMode_name = map[int32]string{
		0: "WakeUpModeNormal",
		1: "WakeUpModeForceLock",
	}
	PessimisticLockWakeUpMode_value = map[string]int32{
		"WakeUpModeNormal":    0,
		"WakeUpModeForceLock": 1,
	}
)

func (x PessimisticLockWakeUpMode) Enum() *PessimisticLockWakeUpMode {
	p := new(PessimisticLockWakeUpMode)
	*p = x
	return p
}

func (x PessimisticLockWakeUpMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PessimisticLockWakeUpMode) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[0].Descriptor()
}

func (PessimisticLockWakeUpMode) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[0]
}

func (x PessimisticLockWakeUpMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PessimisticLockWakeUpMode.Descriptor instead.
func (PessimisticLockWakeUpMode) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{0}
}

type PessimisticLockKeyResultType int32

const (
	PessimisticLockKeyResultType_LockResultNormal             PessimisticLockKeyResultType = 0
	PessimisticLockKeyResultType_LockResultLockedWithConflict PessimisticLockKeyResultType = 1
	PessimisticLockKeyResultType_LockResultFailed             PessimisticLockKeyResultType = 2
)

// Enum value maps for PessimisticLockKeyResultType.
var (
	PessimisticLockKeyResultType_name = map[int32]string{
		0: "LockResultNormal",
		1: "LockResultLockedWithConflict",
		2: "LockResultFailed",
	}
	PessimisticLockKeyResultType_value = map[string]int32{
		"LockResultNormal":             0,
		"LockResultLockedWithConflict": 1,
		"LockResultFailed":             2,
	}
)

func (x PessimisticLockKeyResultType) Enum() *PessimisticLockKeyResultType {
	p := new(PessimisticLockKeyResultType)
	*p = x
	return p
}

func (x PessimisticLockKeyResultType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PessimisticLockKeyResultType) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[1].Descriptor()
}

func (PessimisticLockKeyResultType) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[1]
}

func (x PessimisticLockKeyResultType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PessimisticLockKeyResultType.Descriptor instead.
func (PessimisticLockKeyResultType) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{1}
}

// CommitRole indicates the current commit request is a primary commit or a secondary commit.
type CommitRole int32

const (
	// Unknown about the current request is a primary commit or a secondary commit;
	CommitRole_Unknown CommitRole = 0
	// Current request is a primary commit;
	CommitRole_Primary CommitRole = 1
	// Current request is a secondary commit;
	CommitRole_Secondary CommitRole = 2
)

// Enum value maps for CommitRole.
var (
	CommitRole_name = map[int32]string{
		0: "Unknown",
		1: "Primary",
		2: "Secondary",
	}
	CommitRole_value = map[string]int32{
		"Unknown":   0,
		"Primary":   1,
		"Secondary": 2,
	}
)

func (x CommitRole) Enum() *CommitRole {
	p := new(CommitRole)
	*p = x
	return p
}

func (x CommitRole) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommitRole) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[2].Descriptor()
}

func (CommitRole) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[2]
}

func (x CommitRole) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommitRole.Descriptor instead.
func (CommitRole) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{2}
}

// The API version the server and the client is using.
// See more details in https://github.com/tikv/rfcs/blob/master/text/0069-api-v2.md.
type APIVersion int32

const (
	// `V1` is mainly for TiDB & TxnKV, and is not safe to use RawKV along with the others.
	// V1 server only accepts V1 requests. V1 raw requests with TTL will be rejected.
	APIVersion_V1 APIVersion = 0
	// `V1TTL` is only available to RawKV, and 8 bytes representing the unix timestamp in
	// seconds for expiring time will be append to the value of all RawKV entries. For example:
	// ------------------------------------------------------------
	// | User value     | Expire Ts                               |
	// ------------------------------------------------------------
	// | 0x12 0x34 0x56 | 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff |
	// ------------------------------------------------------------
	// V1TTL server only accepts V1 raw requests.
	// V1 client should not use `V1TTL` in request. V1 client should always send `V1`.
	APIVersion_V1TTL APIVersion = 1
	// `V2` use new encoding for RawKV & TxnKV to support more features.
	//
	// Key Encoding:
	//
	//	TiDB: start with `m` or `t`, the same as `V1`.
	//	TxnKV: prefix with `x`, encoded as `MCE( x{keyspace id} + {user key} ) + timestamp`.
	//	RawKV: prefix with `r`, encoded as `MCE( r{keyspace id} + {user key} ) + timestamp`.
	//	Where the `{keyspace id}` is fixed-length of 3 bytes in network byte order.
	//	Besides, RawKV entires must be in `default` CF.
	//
	// Value Encoding:
	//
	//	TiDB & TxnKV: the same as `V1`.
	//	RawKV: `{user value} + {optional fields} + {meta flag}`. The last byte in the
	//	raw value must be meta flags. For example:
	//	--------------------------------------
	//	| User value     | Meta flags        |
	//	--------------------------------------
	//	| 0x12 0x34 0x56 | 0x00 (0b00000000) |
	//	--------------------------------------
	//	Bit 0 of meta flags is for TTL. If set, the value contains 8 bytes expiring time as
	//	unix timestamp in seconds at the very left to the meta flags.
	//	--------------------------------------------------------------------------------
	//	| User value     | Expiring time                           | Meta flags        |
	//	--------------------------------------------------------------------------------
	//	| 0x12 0x34 0x56 | 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff | 0x01 (0b00000001) |
	//	--------------------------------------------------------------------------------
	//	Bit 1 is for deletion. If set, the entry is logical deleted.
	//	---------------------
	//	| Meta flags        |
	//	---------------------
	//	| 0x02 (0b00000010) |
	//	---------------------
	//
	// V2 server accpets V2 requests and V1 transactional requests that statrts with TiDB key
	// prefix (`m` and `t`).
	APIVersion_V2 APIVersion = 2
)

// Enum value maps for APIVersion.
var (
	APIVersion_name = map[int32]string{
		0: "V1",
		1: "V1TTL",
		2: "V2",
	}
	APIVersion_value = map[string]int32{
		"V1":    0,
		"V1TTL": 1,
		"V2":    2,
	}
)

func (x APIVersion) Enum() *APIVersion {
	p := new(APIVersion)
	*p = x
	return p
}

func (x APIVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (APIVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[3].Descriptor()
}

func (APIVersion) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[3]
}

func (x APIVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use APIVersion.Descriptor instead.
func (APIVersion) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{3}
}

type CommandPri int32

const (
	CommandPri_Normal CommandPri = 0 // Normal is the default value.
	CommandPri_Low    CommandPri = 1
	CommandPri_High   CommandPri = 2
)

// Enum value maps for CommandPri.
var (
	CommandPri_name = map[int32]string{
		0: "Normal",
		1: "Low",
		2: "High",
	}
	CommandPri_value = map[string]int32{
		"Normal": 0,
		"Low":    1,
		"High":   2,
	}
)

func (x CommandPri) Enum() *CommandPri {
	p := new(CommandPri)
	*p = x
	return p
}

func (x CommandPri) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommandPri) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[4].Descriptor()
}

func (CommandPri) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[4]
}

func (x CommandPri) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommandPri.Descriptor instead.
func (CommandPri) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{4}
}

type IsolationLevel int32

const (
	IsolationLevel_SI        IsolationLevel = 0 // SI = snapshot isolation
	IsolationLevel_RC        IsolationLevel = 1 // RC = read committed
	IsolationLevel_RCCheckTS IsolationLevel = 2 // RC read and it's needed to check if there exists more recent versions.
)

// Enum value maps for IsolationLevel.
var (
	IsolationLevel_name = map[int32]string{
		0: "SI",
		1: "RC",
		2: "RCCheckTS",
	}
	IsolationLevel_value = map[string]int32{
		"SI":        0,
		"RC":        1,
		"RCCheckTS": 2,
	}
)

func (x IsolationLevel) Enum() *IsolationLevel {
	p := new(IsolationLevel)
	*p = x
	return p
}

func (x IsolationLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IsolationLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[5].Descriptor()
}

func (IsolationLevel) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[5]
}

func (x IsolationLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IsolationLevel.Descriptor instead.
func (IsolationLevel) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{5}
}

// Operation allowed info during each TiKV storage threshold.
type DiskFullOpt int32

const (
	DiskFullOpt_NotAllowedOnFull     DiskFullOpt = 0 // The default value, means operations are not allowed either under almost full or already full.
	DiskFullOpt_AllowedOnAlmostFull  DiskFullOpt = 1 // Means operations will be allowed when disk is almost full.
	DiskFullOpt_AllowedOnAlreadyFull DiskFullOpt = 2 // Means operations will be allowed when disk is already full.
)

// Enum value maps for DiskFullOpt.
var (
	DiskFullOpt_name = map[int32]string{
		0: "NotAllowedOnFull",
		1: "AllowedOnAlmostFull",
		2: "AllowedOnAlreadyFull",
	}
	DiskFullOpt_value = map[string]int32{
		"NotAllowedOnFull":     0,
		"AllowedOnAlmostFull":  1,
		"AllowedOnAlreadyFull": 2,
	}
)

func (x DiskFullOpt) Enum() *DiskFullOpt {
	p := new(DiskFullOpt)
	*p = x
	return p
}

func (x DiskFullOpt) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DiskFullOpt) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[6].Descriptor()
}

func (DiskFullOpt) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[6]
}

func (x DiskFullOpt) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DiskFullOpt.Descriptor instead.
func (DiskFullOpt) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{6}
}

type Op int32

const (
	Op_Put      Op = 0
	Op_Del      Op = 1
	Op_Lock     Op = 2
	Op_Rollback Op = 3
	// insert operation has a constraint that key should not exist before.
	Op_Insert Op = 4
	// PessimisticLock is exclusive lock acquired in pessimistic transaction.
	Op_PessimisticLock Op = 5
	Op_CheckNotExists  Op = 6
	// SharedLock likes Lock but in shared mode.
	Op_SharedLock Op = 7
	// SharedPessimisticLock is shared lock acquired in pessimistic transaction.
	Op_SharedPessimisticLock Op = 8
)

// Enum value maps for Op.
var (
	Op_name = map[int32]string{
		0: "Put",
		1: "Del",
		2: "Lock",
		3: "Rollback",
		4: "Insert",
		5: "PessimisticLock",
		6: "CheckNotExists",
		7: "SharedLock",
		8: "SharedPessimisticLock",
	}
	Op_value = map[string]int32{
		"Put":                   0,
		"Del":                   1,
		"Lock":                  2,
		"Rollback":              3,
		"Insert":                4,
		"PessimisticLock":       5,
		"CheckNotExists":        6,
		"SharedLock":            7,
		"SharedPessimisticLock": 8,
	}
)

func (x Op) Enum() *Op {
	p := new(Op)
	*p = x
	return p
}

func (x Op) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Op) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[7].Descriptor()
}

func (Op) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[7]
}

func (x Op) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Op.Descriptor instead.
func (Op) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{7}
}

type Assertion int32

const (
	Assertion_None     Assertion = 0
	Assertion_Exist    Assertion = 1
	Assertion_NotExist Assertion = 2
)

// Enum value maps for Assertion.
var (
	Assertion_name = map[int32]string{
		0: "None",
		1: "Exist",
		2: "NotExist",
	}
	Assertion_value = map[string]int32{
		"None":     0,
		"Exist":    1,
		"NotExist": 2,
	}
)

func (x Assertion) Enum() *Assertion {
	p := new(Assertion)
	*p = x
	return p
}

func (x Assertion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Assertion) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[8].Descriptor()
}

func (Assertion) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[8]
}

func (x Assertion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Assertion.Descriptor instead.
func (Assertion) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{8}
}

type AssertionLevel int32

const (
	// No assertion.
	AssertionLevel_Off AssertionLevel = 0
	// Assertion is enabled, but not enforced when it might affect performance.
	AssertionLevel_Fast AssertionLevel = 1
	// Assertion is enabled and enforced.
	AssertionLevel_Strict AssertionLevel = 2
)

// Enum value maps for AssertionLevel.
var (
	AssertionLevel_name = map[int32]string{
		0: "Off",
		1: "Fast",
		2: "Strict",
	}
	AssertionLevel_value = map[string]int32{
		"Off":    0,
		"Fast":   1,
		"Strict": 2,
	}
)

func (x AssertionLevel) Enum() *AssertionLevel {
	p := new(AssertionLevel)
	*p = x
	return p
}

func (x AssertionLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AssertionLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[9].Descriptor()
}

func (AssertionLevel) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[9]
}

func (x AssertionLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AssertionLevel.Descriptor instead.
func (AssertionLevel) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{9}
}

type Action int32

const (
	Action_NoAction                     Action = 0
	Action_TTLExpireRollback            Action = 1
	Action_LockNotExistRollback         Action = 2
	Action_MinCommitTSPushed            Action = 3
	Action_TTLExpirePessimisticRollback Action = 4
	Action_LockNotExistDoNothing        Action = 5
)

// Enum value maps for Action.
var (
	Action_name = map[int32]string{
		0: "NoAction",
		1: "TTLExpireRollback",
		2: "LockNotExistRollback",
		3: "MinCommitTSPushed",
		4: "TTLExpirePessimisticRollback",
		5: "LockNotExistDoNothing",
	}
	Action_value = map[string]int32{
		"NoAction":                     0,
		"TTLExpireRollback":            1,
		"LockNotExistRollback":         2,
		"MinCommitTSPushed":            3,
		"TTLExpirePessimisticRollback": 4,
		"LockNotExistDoNothing":        5,
	}
)

func (x Action) Enum() *Action {
	p := new(Action)
	*p = x
	return p
}

func (x Action) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Action) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[10].Descriptor()
}

func (Action) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[10]
}

func (x Action) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Action.Descriptor instead.
func (Action) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{10}
}

type ExtraOp int32

const (
	ExtraOp_Noop ExtraOp = 0
	// ReadOldValue represents to output the previous value for delete/update operations.
	ExtraOp_ReadOldValue ExtraOp = 1
)

// Enum value maps for ExtraOp.
var (
	ExtraOp_name = map[int32]string{
		0: "Noop",
		1: "ReadOldValue",
	}
	ExtraOp_value = map[string]int32{
		"Noop":         0,
		"ReadOldValue": 1,
	}
)

func (x ExtraOp) Enum() *ExtraOp {
	p := new(ExtraOp)
	*p = x
	return p
}

func (x ExtraOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExtraOp) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[11].Descriptor()
}

func (ExtraOp) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[11]
}

func (x ExtraOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ExtraOp.Descriptor instead.
func (ExtraOp) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{11}
}

type ChecksumAlgorithm int32

const (
	ChecksumAlgorithm_Crc64_Xor ChecksumAlgorithm = 0
)

// Enum value maps for ChecksumAlgorithm.
var (
	ChecksumAlgorithm_name = map[int32]string{
		0: "Crc64_Xor",
	}
	ChecksumAlgorithm_value = map[string]int32{
		"Crc64_Xor": 0,
	}
)

func (x ChecksumAlgorithm) Enum() *ChecksumAlgorithm {
	p := new(ChecksumAlgorithm)
	*p = x
	return p
}

func (x ChecksumAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChecksumAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[12].Descriptor()
}

func (ChecksumAlgorithm) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[12]
}

func (x ChecksumAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChecksumAlgorithm.Descriptor instead.
func (ChecksumAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{12}
}

// What kind of checks need to be performed for keys in a pessimistic transaction.
type PrewriteRequest_PessimisticAction int32

const (
	// The key needn't be locked and no extra write conflict checks are needed.
	// Deprecated in next-gen (cloud-storage-engine).
	PrewriteRequest_SKIP_PESSIMISTIC_CHECK PrewriteRequest_PessimisticAction = 0
	// The key should have been locked at the time of prewrite. If the lock is missing,
	// the lock will be amended. This is the normal case for pessimistic transactions.
	PrewriteRequest_DO_PESSIMISTIC_CHECK PrewriteRequest_PessimisticAction = 1
	// The key does not acquire a pessimistic lock for performance optimization.
	// Constraint checking (write conflicts + data constraints) is deferred to prewrite.
	PrewriteRequest_DO_CONSTRAINT_CHECK PrewriteRequest_PessimisticAction = 2
)

// Enum value maps for PrewriteRequest_PessimisticAction.
var (
	PrewriteRequest_PessimisticAction_name = map[int32]string{
		0: "SKIP_PESSIMISTIC_CHECK",
		1: "DO_PESSIMISTIC_CHECK",
		2: "DO_CONSTRAINT_CHECK",
	}
	PrewriteRequest_PessimisticAction_value = map[string]int32{
		"SKIP_PESSIMISTIC_CHECK": 0,
		"DO_PESSIMISTIC_CHECK":   1,
		"DO_CONSTRAINT_CHECK":    2,
	}
)

func (x PrewriteRequest_PessimisticAction) Enum() *PrewriteRequest_PessimisticAction {
	p := new(PrewriteRequest_PessimisticAction)
	*p = x
	return p
}

func (x PrewriteRequest_PessimisticAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PrewriteRequest_PessimisticAction) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[13].Descriptor()
}

func (PrewriteRequest_PessimisticAction) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[13]
}

func (x PrewriteRequest_PessimisticAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PrewriteRequest_PessimisticAction.Descriptor instead.
func (PrewriteRequest_PessimisticAction) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{4, 0}
}

type WriteConflict_Reason int32

const (
	WriteConflict_Unknown              WriteConflict_Reason = 0
	WriteConflict_Optimistic           WriteConflict_Reason = 1 // in optimistic transactions.
	WriteConflict_PessimisticRetry     WriteConflict_Reason = 2 // a lock acquisition request waits for a lock and awakes, or meets a newer version of data, let TiDB retry.
	WriteConflict_SelfRolledBack       WriteConflict_Reason = 3 // the transaction itself has been rolled back when it tries to prewrite.
	WriteConflict_RcCheckTs            WriteConflict_Reason = 4 // RcCheckTs failure by meeting a newer version, let TiDB retry.
	WriteConflict_LazyUniquenessCheck  WriteConflict_Reason = 5 // write conflict found when deferring constraint checks in pessimistic transactions. Deprecated in next-gen (cloud-storage-engine).
	WriteConflict_NotLockedKeyConflict WriteConflict_Reason = 6 // write conflict found on keys that do not acquire pessimistic locks in pessimistic transactions.
)

// Enum value maps for WriteConflict_Reason.
var (
	WriteConflict_Reason_name = map[int32]string{
		0: "Unknown",
		1: "Optimistic",
		2: "PessimisticRetry",
		3: "SelfRolledBack",
		4: "RcCheckTs",
		5: "LazyUniquenessCheck",
		6: "NotLockedKeyConflict",
	}
	WriteConflict_Reason_value = map[string]int32{
		"Unknown":              0,
		"Optimistic":           1,
		"PessimisticRetry":     2,
		"SelfRolledBack":       3,
		"RcCheckTs":            4,
		"LazyUniquenessCheck":  5,
		"NotLockedKeyConflict": 6,
	}
)

func (x WriteConflict_Reason) Enum() *WriteConflict_Reason {
	p := new(WriteConflict_Reason)
	*p = x
	return p
}

func (x WriteConflict_Reason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WriteConflict_Reason) Descriptor() protoreflect.EnumDescriptor {
	return file_kvrpcpb_proto_enumTypes[14].Descriptor()
}

func (WriteConflict_Reason) Type() protoreflect.EnumType {
	return &file_kvrpcpb_proto_enumTypes[14]
}

func (x WriteConflict_Reason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WriteConflict_Reason.Descriptor instead.
func (WriteConflict_Reason) EnumDescriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{80, 0}
}

// A transactional get command. Lookup a value for `key` in the transaction with
// starting timestamp = `version`.
type GetRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Key     []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Version uint64                 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// If true, the response will include the commit ts of the key.
	NeedCommitTs  bool `protobuf:"varint,4,opt,name=need_commit_ts,json=needCommitTs,proto3" json:"need_commit_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() {
	*x = GetRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest) ProtoMessage() {}

func (x *GetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{0}
}

func (x *GetRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *GetRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *GetRequest) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *GetRequest) GetNeedCommitTs() bool {
	if x != nil {
		return x.NeedCommitTs
	}
	return false
}

type GetResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A region error indicates that the request was sent to the wrong TiKV node
	// (or other, similar errors).
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	// A value could not be retrieved due to the state of the database for the requested key.
	Error *KeyError `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// A successful result.
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// True if the key does not exist in the database.
	NotFound bool `protobuf:"varint,4,opt,name=not_found,json=notFound,proto3" json:"not_found,omitempty"`
	// Time and scan details when processing the request.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,6,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	// The commit timestamp of the key.
	// If it is zero, it means the commit timestamp is unknown.
	CommitTs      uint64 `protobuf:"varint,7,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() {
	*x = GetResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse) ProtoMessage() {}

func (x *GetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{1}
}

func (x *GetResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *GetResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *GetResponse) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *GetResponse) GetNotFound() bool {
	if x != nil {
		return x.NotFound
	}
	return false
}

func (x *GetResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

func (x *GetResponse) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

// Scan fetches values for a range of keys; it is part of the transaction with
// starting timestamp = `version`.
type ScanRequest struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Context  *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartKey []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// The maximum number of results to return.
	Limit   uint32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Version uint64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// Return only the keys found by scanning, not their values.
	KeyOnly bool `protobuf:"varint,5,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	Reverse bool `protobuf:"varint,6,opt,name=reverse,proto3" json:"reverse,omitempty"`
	// For compatibility, when scanning forward, the range to scan is [start_key, end_key), where start_key < end_key;
	// and when scanning backward, it scans [end_key, start_key) in descending order, where end_key < start_key.
	EndKey []byte `protobuf:"bytes,7,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// If sample_step > 0, skips 'sample_step - 1' number of keys after each returned key.
	// locks are not checked.
	SampleStep    uint32 `protobuf:"varint,8,opt,name=sample_step,json=sampleStep,proto3" json:"sample_step,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScanRequest) Reset() {
	*x = ScanRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanRequest) ProtoMessage() {}

func (x *ScanRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanRequest.ProtoReflect.Descriptor instead.
func (*ScanRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{2}
}

func (x *ScanRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *ScanRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *ScanRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ScanRequest) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ScanRequest) GetKeyOnly() bool {
	if x != nil {
		return x.KeyOnly
	}
	return false
}

func (x *ScanRequest) GetReverse() bool {
	if x != nil {
		return x.Reverse
	}
	return false
}

func (x *ScanRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *ScanRequest) GetSampleStep() uint32 {
	if x != nil {
		return x.SampleStep
	}
	return 0
}

type ScanResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	// Each KvPair may contain a key error.
	Pairs []*KvPair `protobuf:"bytes,2,rep,name=pairs,proto3" json:"pairs,omitempty"`
	// This KeyError exists when some key is locked but we cannot check locks of all keys.
	// In this case, `pairs` should be empty and the client should redo scanning all the keys
	// after resolving the lock.
	Error         *KeyError `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScanResponse) Reset() {
	*x = ScanResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanResponse) ProtoMessage() {}

func (x *ScanResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanResponse.ProtoReflect.Descriptor instead.
func (*ScanResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{3}
}

func (x *ScanResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *ScanResponse) GetPairs() []*KvPair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

func (x *ScanResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

// A prewrite is the first phase of writing to TiKV. It contains all data to be written in a transaction.
// TiKV will write the data in a preliminary state. Data cannot be read until it has been committed.
// The client should only commit a transaction once all prewrites succeed.
type PrewriteRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// The data to be written to the database.
	Mutations []*Mutation `protobuf:"bytes,2,rep,name=mutations,proto3" json:"mutations,omitempty"`
	// The client picks one key to be primary (unrelated to the primary key concept in SQL). This
	// key's lock is the source of truth for the state of a transaction. All other locks due to a
	// transaction will point to the primary lock.
	PrimaryLock []byte `protobuf:"bytes,3,opt,name=primary_lock,json=primaryLock,proto3" json:"primary_lock,omitempty"`
	// Identifies the transaction being written.
	StartVersion uint64 `protobuf:"varint,4,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	LockTtl      uint64 `protobuf:"varint,5,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	// TiKV can skip some checks, used for speeding up data migration.
	SkipConstraintCheck bool `protobuf:"varint,6,opt,name=skip_constraint_check,json=skipConstraintCheck,proto3" json:"skip_constraint_check,omitempty"`
	// For pessimistic transaction, some mutations don't need to be locked, for example, non-unique index key.
	// Keys with deferred constraint checks are not locked.
	PessimisticActions []PrewriteRequest_PessimisticAction `protobuf:"varint,7,rep,packed,name=pessimistic_actions,json=pessimisticActions,proto3,enum=kvrpcpb.PrewriteRequest_PessimisticAction" json:"pessimistic_actions,omitempty"`
	// How many keys this transaction involves in this region.
	TxnSize uint64 `protobuf:"varint,8,opt,name=txn_size,json=txnSize,proto3" json:"txn_size,omitempty"`
	// For pessimistic transactions only; used to check if a conflict lock is already committed.
	ForUpdateTs uint64 `protobuf:"varint,9,opt,name=for_update_ts,json=forUpdateTs,proto3" json:"for_update_ts,omitempty"`
	// If min_commit_ts > 0, this is a large transaction request, the final commit_ts
	// will be inferred from `min_commit_ts`.
	MinCommitTs uint64 `protobuf:"varint,10,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// When async commit is enabled, `secondaries` should be set as the key list of all secondary
	// locks if the request prewrites the primary lock.
	UseAsyncCommit bool     `protobuf:"varint,11,opt,name=use_async_commit,json=useAsyncCommit,proto3" json:"use_async_commit,omitempty"`
	Secondaries    [][]byte `protobuf:"bytes,12,rep,name=secondaries,proto3" json:"secondaries,omitempty"`
	// When the transaction involves only one region, it's possible to commit the transaction
	// directly with 1PC protocol.
	TryOnePc bool `protobuf:"varint,13,opt,name=try_one_pc,json=tryOnePc,proto3" json:"try_one_pc,omitempty"`
	// The max commit ts is reserved for limiting the commit ts of 1PC or async commit, which can be used to avoid
	// inconsistency with schema change.
	MaxCommitTs uint64 `protobuf:"varint,14,opt,name=max_commit_ts,json=maxCommitTs,proto3" json:"max_commit_ts,omitempty"`
	// The level of assertion to use on this prewrte request.
	AssertionLevel AssertionLevel `protobuf:"varint,15,opt,name=assertion_level,json=assertionLevel,proto3,enum=kvrpcpb.AssertionLevel" json:"assertion_level,omitempty"`
	// for_update_ts constriants that should be checked when prewriting a pessimistic transaction.
	// See https://github.com/tikv/tikv/issues/14311
	ForUpdateTsConstraints []*PrewriteRequest_ForUpdateTSConstraint `protobuf:"bytes,16,rep,name=for_update_ts_constraints,json=forUpdateTsConstraints,proto3" json:"for_update_ts_constraints,omitempty"`
	// Reserved for file based transaction.
	TxnFileChunks []uint64 `protobuf:"varint,100,rep,packed,name=txn_file_chunks,json=txnFileChunks,proto3" json:"txn_file_chunks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrewriteRequest) Reset() {
	*x = PrewriteRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrewriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrewriteRequest) ProtoMessage() {}

func (x *PrewriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrewriteRequest.ProtoReflect.Descriptor instead.
func (*PrewriteRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{4}
}

func (x *PrewriteRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PrewriteRequest) GetMutations() []*Mutation {
	if x != nil {
		return x.Mutations
	}
	return nil
}

func (x *PrewriteRequest) GetPrimaryLock() []byte {
	if x != nil {
		return x.PrimaryLock
	}
	return nil
}

func (x *PrewriteRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *PrewriteRequest) GetLockTtl() uint64 {
	if x != nil {
		return x.LockTtl
	}
	return 0
}

func (x *PrewriteRequest) GetSkipConstraintCheck() bool {
	if x != nil {
		return x.SkipConstraintCheck
	}
	return false
}

func (x *PrewriteRequest) GetPessimisticActions() []PrewriteRequest_PessimisticAction {
	if x != nil {
		return x.PessimisticActions
	}
	return nil
}

func (x *PrewriteRequest) GetTxnSize() uint64 {
	if x != nil {
		return x.TxnSize
	}
	return 0
}

func (x *PrewriteRequest) GetForUpdateTs() uint64 {
	if x != nil {
		return x.ForUpdateTs
	}
	return 0
}

func (x *PrewriteRequest) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

func (x *PrewriteRequest) GetUseAsyncCommit() bool {
	if x != nil {
		return x.UseAsyncCommit
	}
	return false
}

func (x *PrewriteRequest) GetSecondaries() [][]byte {
	if x != nil {
		return x.Secondaries
	}
	return nil
}

func (x *PrewriteRequest) GetTryOnePc() bool {
	if x != nil {
		return x.TryOnePc
	}
	return false
}

func (x *PrewriteRequest) GetMaxCommitTs() uint64 {
	if x != nil {
		return x.MaxCommitTs
	}
	return 0
}

func (x *PrewriteRequest) GetAssertionLevel() AssertionLevel {
	if x != nil {
		return x.AssertionLevel
	}
	return AssertionLevel_Off
}

func (x *PrewriteRequest) GetForUpdateTsConstraints() []*PrewriteRequest_ForUpdateTSConstraint {
	if x != nil {
		return x.ForUpdateTsConstraints
	}
	return nil
}

func (x *PrewriteRequest) GetTxnFileChunks() []uint64 {
	if x != nil {
		return x.TxnFileChunks
	}
	return nil
}

type PrewriteResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Errors      []*KeyError            `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`
	// 0 if the min_commit_ts is not ready or any other reason that async
	// commit cannot proceed. The client can then fallback to normal way to
	// continue committing the transaction if prewrite are all finished.
	MinCommitTs uint64 `protobuf:"varint,3,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// When the transaction is successfully committed with 1PC protocol, this field will be set to
	// the commit ts of the transaction. Otherwise, if TiKV failed to commit it with 1PC or the
	// transaction is not 1PC, the value will be 0.
	OnePcCommitTs uint64 `protobuf:"varint,4,opt,name=one_pc_commit_ts,json=onePcCommitTs,proto3" json:"one_pc_commit_ts,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,5,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrewriteResponse) Reset() {
	*x = PrewriteResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrewriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrewriteResponse) ProtoMessage() {}

func (x *PrewriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrewriteResponse.ProtoReflect.Descriptor instead.
func (*PrewriteResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{5}
}

func (x *PrewriteResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *PrewriteResponse) GetErrors() []*KeyError {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *PrewriteResponse) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

func (x *PrewriteResponse) GetOnePcCommitTs() uint64 {
	if x != nil {
		return x.OnePcCommitTs
	}
	return 0
}

func (x *PrewriteResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// Lock a set of keys to prepare to write to them.
type PessimisticLockRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// In this case every `Op` of the mutations must be `PessimisticLock`.
	Mutations    []*Mutation `protobuf:"bytes,2,rep,name=mutations,proto3" json:"mutations,omitempty"`
	PrimaryLock  []byte      `protobuf:"bytes,3,opt,name=primary_lock,json=primaryLock,proto3" json:"primary_lock,omitempty"`
	StartVersion uint64      `protobuf:"varint,4,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	LockTtl      uint64      `protobuf:"varint,5,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	// Each locking command in a pessimistic transaction has its own timestamp. If locking fails, then
	// the corresponding SQL statement can be retried with a later timestamp, TiDB does not need to
	// retry the whole transaction. The name comes from the `SELECT ... FOR UPDATE` SQL statement which
	// is a locking read. Each `SELECT ... FOR UPDATE` in a transaction will be assigned its own
	// timestamp.
	ForUpdateTs uint64 `protobuf:"varint,6,opt,name=for_update_ts,json=forUpdateTs,proto3" json:"for_update_ts,omitempty"`
	// If the request is the first lock request, we don't need to detect deadlock.
	IsFirstLock bool `protobuf:"varint,7,opt,name=is_first_lock,json=isFirstLock,proto3" json:"is_first_lock,omitempty"`
	// Time to wait for lock released in milliseconds when encountering locks.
	// 0 means using default timeout in TiKV. Negative means no wait.
	WaitTimeout int64 `protobuf:"varint,8,opt,name=wait_timeout,json=waitTimeout,proto3" json:"wait_timeout,omitempty"`
	// If it is true, TiKV will acquire the pessimistic lock regardless of write conflict
	// and return the latest value. It's only supported for single mutation.
	//
	// Deprecated: Marked as deprecated in kvrpcpb.proto.
	Force bool `protobuf:"varint,9,opt,name=force,proto3" json:"force,omitempty"`
	// If it is true, TiKV will return values of the keys if no error, so TiDB can cache the values for
	// later read in the same transaction.
	// When 'force' is set to true, this field is ignored.
	ReturnValues bool `protobuf:"varint,10,opt,name=return_values,json=returnValues,proto3" json:"return_values,omitempty"`
	// If min_commit_ts > 0, this is large transaction proto, the final commit_ts
	// would be infered from min_commit_ts.
	MinCommitTs uint64 `protobuf:"varint,11,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// If set to true, it means TiKV need to check if the key exists, and return the result in
	// the `not_founds` feild in the response. This works no matter if `return_values` is set. If
	// `return_values` is set, it simply makes no difference; otherwise, the `value` field of the
	// repsonse will be empty while the `not_founds` field still indicates the keys' existence.
	CheckExistence bool `protobuf:"varint,12,opt,name=check_existence,json=checkExistence,proto3" json:"check_existence,omitempty"`
	// TiKV lock the record only when it exists
	LockOnlyIfExists bool `protobuf:"varint,13,opt,name=lock_only_if_exists,json=lockOnlyIfExists,proto3" json:"lock_only_if_exists,omitempty"`
	// Specifies the behavior when the request is woken up after wating for lock of another transaction.
	WakeUpMode    PessimisticLockWakeUpMode `protobuf:"varint,14,opt,name=wake_up_mode,json=wakeUpMode,proto3,enum=kvrpcpb.PessimisticLockWakeUpMode" json:"wake_up_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PessimisticLockRequest) Reset() {
	*x = PessimisticLockRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PessimisticLockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PessimisticLockRequest) ProtoMessage() {}

func (x *PessimisticLockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PessimisticLockRequest.ProtoReflect.Descriptor instead.
func (*PessimisticLockRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{6}
}

func (x *PessimisticLockRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PessimisticLockRequest) GetMutations() []*Mutation {
	if x != nil {
		return x.Mutations
	}
	return nil
}

func (x *PessimisticLockRequest) GetPrimaryLock() []byte {
	if x != nil {
		return x.PrimaryLock
	}
	return nil
}

func (x *PessimisticLockRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *PessimisticLockRequest) GetLockTtl() uint64 {
	if x != nil {
		return x.LockTtl
	}
	return 0
}

func (x *PessimisticLockRequest) GetForUpdateTs() uint64 {
	if x != nil {
		return x.ForUpdateTs
	}
	return 0
}

func (x *PessimisticLockRequest) GetIsFirstLock() bool {
	if x != nil {
		return x.IsFirstLock
	}
	return false
}

func (x *PessimisticLockRequest) GetWaitTimeout() int64 {
	if x != nil {
		return x.WaitTimeout
	}
	return 0
}

// Deprecated: Marked as deprecated in kvrpcpb.proto.
func (x *PessimisticLockRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

func (x *PessimisticLockRequest) GetReturnValues() bool {
	if x != nil {
		return x.ReturnValues
	}
	return false
}

func (x *PessimisticLockRequest) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

func (x *PessimisticLockRequest) GetCheckExistence() bool {
	if x != nil {
		return x.CheckExistence
	}
	return false
}

func (x *PessimisticLockRequest) GetLockOnlyIfExists() bool {
	if x != nil {
		return x.LockOnlyIfExists
	}
	return false
}

func (x *PessimisticLockRequest) GetWakeUpMode() PessimisticLockWakeUpMode {
	if x != nil {
		return x.WakeUpMode
	}
	return PessimisticLockWakeUpMode_WakeUpModeNormal
}

type PessimisticLockKeyResult struct {
	state     protoimpl.MessageState       `protogen:"open.v1"`
	Type      PessimisticLockKeyResultType `protobuf:"varint,1,opt,name=type,proto3,enum=kvrpcpb.PessimisticLockKeyResultType" json:"type,omitempty"`
	Value     []byte                       `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Existence bool                         `protobuf:"varint,3,opt,name=existence,proto3" json:"existence,omitempty"`
	// We allow a key be locked when there is write conflict (latest commit_ts > for_update_ts).
	// In this case, the key is semantically locked by a newer for_update_ts.
	// For each requested key, the field is non-zero if the key is locked with write conflict, and it
	// equals to the commit_ts of the latest version of the specified key. The for_update_ts field
	// of the lock that's actually written to TiKV will also be this value. At the same time,
	// `value` and `existence` will be returned regardless to how `return_values` and
	// `check_existence` are set.
	LockedWithConflictTs uint64 `protobuf:"varint,4,opt,name=locked_with_conflict_ts,json=lockedWithConflictTs,proto3" json:"locked_with_conflict_ts,omitempty"`
	// Hint the client that resolving lock is not needed for this lock. For `PessimisticLock`
	// requests only.
	SkipResolvingLock bool `protobuf:"varint,11,opt,name=skip_resolving_lock,json=skipResolvingLock,proto3" json:"skip_resolving_lock,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PessimisticLockKeyResult) Reset() {
	*x = PessimisticLockKeyResult{}
	mi := &file_kvrpcpb_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PessimisticLockKeyResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PessimisticLockKeyResult) ProtoMessage() {}

func (x *PessimisticLockKeyResult) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PessimisticLockKeyResult.ProtoReflect.Descriptor instead.
func (*PessimisticLockKeyResult) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{7}
}

func (x *PessimisticLockKeyResult) GetType() PessimisticLockKeyResultType {
	if x != nil {
		return x.Type
	}
	return PessimisticLockKeyResultType_LockResultNormal
}

func (x *PessimisticLockKeyResult) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *PessimisticLockKeyResult) GetExistence() bool {
	if x != nil {
		return x.Existence
	}
	return false
}

func (x *PessimisticLockKeyResult) GetLockedWithConflictTs() uint64 {
	if x != nil {
		return x.LockedWithConflictTs
	}
	return 0
}

func (x *PessimisticLockKeyResult) GetSkipResolvingLock() bool {
	if x != nil {
		return x.SkipResolvingLock
	}
	return false
}

type PessimisticLockResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Errors      []*KeyError            `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`
	// It carries the latest value and its commit ts if force in PessimisticLockRequest is true.
	//
	// Deprecated: Marked as deprecated in kvrpcpb.proto.
	CommitTs uint64 `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	// Deprecated: Marked as deprecated in kvrpcpb.proto.
	Value []byte `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// The values is set if 'return_values' is true in the request and no error.
	// If 'force' is true, this field is not used.
	// Only used when `wake_up_mode` is `WakeUpModeNormal`.
	Values [][]byte `protobuf:"bytes,5,rep,name=values,proto3" json:"values,omitempty"`
	// Indicates whether the values at the same index is correspond to an existing key.
	// In legacy TiKV, this field is not used even 'force' is false. In that case, an empty value indicates
	// two possible situations: (1) the key does not exist. (2) the key exists but the value is empty.
	// Only used when `wake_up_mode` is `WakeUpModeNormal`.
	NotFounds []bool `protobuf:"varint,6,rep,packed,name=not_founds,json=notFounds,proto3" json:"not_founds,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,7,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	// Results of the request. Only used when `wake_up_mode` is `WakeUpModeForceLock`.
	Results       []*PessimisticLockKeyResult `protobuf:"bytes,8,rep,name=results,proto3" json:"results,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PessimisticLockResponse) Reset() {
	*x = PessimisticLockResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PessimisticLockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PessimisticLockResponse) ProtoMessage() {}

func (x *PessimisticLockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PessimisticLockResponse.ProtoReflect.Descriptor instead.
func (*PessimisticLockResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{8}
}

func (x *PessimisticLockResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *PessimisticLockResponse) GetErrors() []*KeyError {
	if x != nil {
		return x.Errors
	}
	return nil
}

// Deprecated: Marked as deprecated in kvrpcpb.proto.
func (x *PessimisticLockResponse) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

// Deprecated: Marked as deprecated in kvrpcpb.proto.
func (x *PessimisticLockResponse) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *PessimisticLockResponse) GetValues() [][]byte {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *PessimisticLockResponse) GetNotFounds() []bool {
	if x != nil {
		return x.NotFounds
	}
	return nil
}

func (x *PessimisticLockResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

func (x *PessimisticLockResponse) GetResults() []*PessimisticLockKeyResult {
	if x != nil {
		return x.Results
	}
	return nil
}

// Unlock keys locked using `PessimisticLockRequest`.
type PessimisticRollbackRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartVersion  uint64                 `protobuf:"varint,2,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	ForUpdateTs   uint64                 `protobuf:"varint,3,opt,name=for_update_ts,json=forUpdateTs,proto3" json:"for_update_ts,omitempty"`
	Keys          [][]byte               `protobuf:"bytes,4,rep,name=keys,proto3" json:"keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PessimisticRollbackRequest) Reset() {
	*x = PessimisticRollbackRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PessimisticRollbackRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PessimisticRollbackRequest) ProtoMessage() {}

func (x *PessimisticRollbackRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PessimisticRollbackRequest.ProtoReflect.Descriptor instead.
func (*PessimisticRollbackRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{9}
}

func (x *PessimisticRollbackRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PessimisticRollbackRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *PessimisticRollbackRequest) GetForUpdateTs() uint64 {
	if x != nil {
		return x.ForUpdateTs
	}
	return 0
}

func (x *PessimisticRollbackRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

type PessimisticRollbackResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Errors      []*KeyError            `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,3,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PessimisticRollbackResponse) Reset() {
	*x = PessimisticRollbackResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PessimisticRollbackResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PessimisticRollbackResponse) ProtoMessage() {}

func (x *PessimisticRollbackResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PessimisticRollbackResponse.ProtoReflect.Descriptor instead.
func (*PessimisticRollbackResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{10}
}

func (x *PessimisticRollbackResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *PessimisticRollbackResponse) GetErrors() []*KeyError {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *PessimisticRollbackResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// Used to update the lock_ttl of a psessimistic and/or large transaction to prevent it from been killed.
type TxnHeartBeatRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// The key of the lock to update.
	PrimaryLock []byte `protobuf:"bytes,2,opt,name=primary_lock,json=primaryLock,proto3" json:"primary_lock,omitempty"`
	// Start timestamp of the large transaction.
	StartVersion uint64 `protobuf:"varint,3,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// The new TTL the sender would like.
	AdviseLockTtl uint64 `protobuf:"varint,4,opt,name=advise_lock_ttl,json=adviseLockTtl,proto3" json:"advise_lock_ttl,omitempty"`
	// Optionally update PK's min_commit_ts.
	// Only for non-async-commmit and non-1PC transactions.
	// If it is 0, ignore this field.
	MinCommitTs uint64 `protobuf:"varint,5,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// Reserved for file based transaction.
	IsTxnFile     bool `protobuf:"varint,100,opt,name=is_txn_file,json=isTxnFile,proto3" json:"is_txn_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxnHeartBeatRequest) Reset() {
	*x = TxnHeartBeatRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxnHeartBeatRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxnHeartBeatRequest) ProtoMessage() {}

func (x *TxnHeartBeatRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxnHeartBeatRequest.ProtoReflect.Descriptor instead.
func (*TxnHeartBeatRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{11}
}

func (x *TxnHeartBeatRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *TxnHeartBeatRequest) GetPrimaryLock() []byte {
	if x != nil {
		return x.PrimaryLock
	}
	return nil
}

func (x *TxnHeartBeatRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *TxnHeartBeatRequest) GetAdviseLockTtl() uint64 {
	if x != nil {
		return x.AdviseLockTtl
	}
	return 0
}

func (x *TxnHeartBeatRequest) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

func (x *TxnHeartBeatRequest) GetIsTxnFile() bool {
	if x != nil {
		return x.IsTxnFile
	}
	return false
}

type TxnHeartBeatResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// The TTL actually set on the requested lock.
	LockTtl uint64 `protobuf:"varint,3,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxnHeartBeatResponse) Reset() {
	*x = TxnHeartBeatResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxnHeartBeatResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxnHeartBeatResponse) ProtoMessage() {}

func (x *TxnHeartBeatResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxnHeartBeatResponse.ProtoReflect.Descriptor instead.
func (*TxnHeartBeatResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{12}
}

func (x *TxnHeartBeatResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *TxnHeartBeatResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *TxnHeartBeatResponse) GetLockTtl() uint64 {
	if x != nil {
		return x.LockTtl
	}
	return 0
}

func (x *TxnHeartBeatResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// CheckTxnStatusRequest checks the status of a transaction.
// If the transaction is rollbacked/committed, return that result.
// If the TTL of the transaction is exhausted, abort that transaction and inform the caller.
// Otherwise, returns the TTL information for the transaction.
// CheckTxnStatusRequest may also push forward the minCommitTS of a large transaction.
type CheckTxnStatusRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// Primary key and lock ts together to locate the primary lock of a transaction.
	PrimaryKey []byte `protobuf:"bytes,2,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	// Starting timestamp of the transaction being checked.
	LockTs uint64 `protobuf:"varint,3,opt,name=lock_ts,json=lockTs,proto3" json:"lock_ts,omitempty"`
	// The start timestamp of the transaction which this request is part of.
	CallerStartTs uint64 `protobuf:"varint,4,opt,name=caller_start_ts,json=callerStartTs,proto3" json:"caller_start_ts,omitempty"`
	// The client must specify the current time to TiKV using this timestamp. It is used to check TTL
	// timeouts. It may be inaccurate.
	CurrentTs uint64 `protobuf:"varint,5,opt,name=current_ts,json=currentTs,proto3" json:"current_ts,omitempty"`
	// If true, then TiKV will leave a rollback tombstone in the write CF for `primary_key`, even if
	// that key is not locked.
	RollbackIfNotExist bool `protobuf:"varint,6,opt,name=rollback_if_not_exist,json=rollbackIfNotExist,proto3" json:"rollback_if_not_exist,omitempty"`
	// This field is set to true only if the transaction is known to fall back from async commit.
	// Then, CheckTxnStatus treats the transaction as non-async-commit even if the use_async_commit
	// field in the primary lock is true.
	ForceSyncCommit bool `protobuf:"varint,7,opt,name=force_sync_commit,json=forceSyncCommit,proto3" json:"force_sync_commit,omitempty"`
	// If the check request is used to resolve or decide the transaction status for a input pessimistic
	// lock, the transaction status could not be decided if the primary lock is pessimistic too and
	// it's still uncertain.
	ResolvingPessimisticLock bool `protobuf:"varint,8,opt,name=resolving_pessimistic_lock,json=resolvingPessimisticLock,proto3" json:"resolving_pessimistic_lock,omitempty"`
	// Whether it's needed to check if the lock on the key (if any) is the primary lock.
	// This is for handling some corner cases when a pessimistic transaction changes its primary
	// (see https://github.com/pingcap/tidb/issues/42937 for details). This field is necessary
	// because the old versions of clients cannot handle some results returned from TiKV correctly.
	// For new versions, this field should always be set to true.
	VerifyIsPrimary bool `protobuf:"varint,9,opt,name=verify_is_primary,json=verifyIsPrimary,proto3" json:"verify_is_primary,omitempty"`
	// Reserved for file based transaction.
	IsTxnFile     bool `protobuf:"varint,100,opt,name=is_txn_file,json=isTxnFile,proto3" json:"is_txn_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckTxnStatusRequest) Reset() {
	*x = CheckTxnStatusRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckTxnStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckTxnStatusRequest) ProtoMessage() {}

func (x *CheckTxnStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckTxnStatusRequest.ProtoReflect.Descriptor instead.
func (*CheckTxnStatusRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{13}
}

func (x *CheckTxnStatusRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *CheckTxnStatusRequest) GetPrimaryKey() []byte {
	if x != nil {
		return x.PrimaryKey
	}
	return nil
}

func (x *CheckTxnStatusRequest) GetLockTs() uint64 {
	if x != nil {
		return x.LockTs
	}
	return 0
}

func (x *CheckTxnStatusRequest) GetCallerStartTs() uint64 {
	if x != nil {
		return x.CallerStartTs
	}
	return 0
}

func (x *CheckTxnStatusRequest) GetCurrentTs() uint64 {
	if x != nil {
		return x.CurrentTs
	}
	return 0
}

func (x *CheckTxnStatusRequest) GetRollbackIfNotExist() bool {
	if x != nil {
		return x.RollbackIfNotExist
	}
	return false
}

func (x *CheckTxnStatusRequest) GetForceSyncCommit() bool {
	if x != nil {
		return x.ForceSyncCommit
	}
	return false
}

func (x *CheckTxnStatusRequest) GetResolvingPessimisticLock() bool {
	if x != nil {
		return x.ResolvingPessimisticLock
	}
	return false
}

func (x *CheckTxnStatusRequest) GetVerifyIsPrimary() bool {
	if x != nil {
		return x.VerifyIsPrimary
	}
	return false
}

func (x *CheckTxnStatusRequest) GetIsTxnFile() bool {
	if x != nil {
		return x.IsTxnFile
	}
	return false
}

type CheckTxnStatusResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Three kinds of transaction status:
	//
	//	locked: lock_ttl > 0
	//	committed: commit_version > 0
	//	rollbacked: lock_ttl = 0 && commit_version = 0
	LockTtl       uint64 `protobuf:"varint,3,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	CommitVersion uint64 `protobuf:"varint,4,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	// The action performed by TiKV (and why if the action is to rollback).
	Action   Action    `protobuf:"varint,5,opt,name=action,proto3,enum=kvrpcpb.Action" json:"action,omitempty"`
	LockInfo *LockInfo `protobuf:"bytes,6,opt,name=lock_info,json=lockInfo,proto3" json:"lock_info,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,7,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckTxnStatusResponse) Reset() {
	*x = CheckTxnStatusResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckTxnStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckTxnStatusResponse) ProtoMessage() {}

func (x *CheckTxnStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckTxnStatusResponse.ProtoReflect.Descriptor instead.
func (*CheckTxnStatusResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{14}
}

func (x *CheckTxnStatusResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *CheckTxnStatusResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CheckTxnStatusResponse) GetLockTtl() uint64 {
	if x != nil {
		return x.LockTtl
	}
	return 0
}

func (x *CheckTxnStatusResponse) GetCommitVersion() uint64 {
	if x != nil {
		return x.CommitVersion
	}
	return 0
}

func (x *CheckTxnStatusResponse) GetAction() Action {
	if x != nil {
		return x.Action
	}
	return Action_NoAction
}

func (x *CheckTxnStatusResponse) GetLockInfo() *LockInfo {
	if x != nil {
		return x.LockInfo
	}
	return nil
}

func (x *CheckTxnStatusResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// Part of the async commit protocol, checks for locks on all supplied keys. If a lock is missing,
// does not have a successful status, or belongs to another transaction, TiKV will leave a rollback
// tombstone for that key.
type CheckSecondaryLocksRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Keys    [][]byte               `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	// Identifies the transaction we are investigating.
	StartVersion  uint64 `protobuf:"varint,3,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckSecondaryLocksRequest) Reset() {
	*x = CheckSecondaryLocksRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckSecondaryLocksRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckSecondaryLocksRequest) ProtoMessage() {}

func (x *CheckSecondaryLocksRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckSecondaryLocksRequest.ProtoReflect.Descriptor instead.
func (*CheckSecondaryLocksRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{15}
}

func (x *CheckSecondaryLocksRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *CheckSecondaryLocksRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *CheckSecondaryLocksRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

type CheckSecondaryLocksResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// For each key in `keys` in `CheckSecondaryLocks`, there will be a lock in
	// this list if there is a lock present and belonging to the correct transaction,
	// nil otherwise.
	Locks []*LockInfo `protobuf:"bytes,3,rep,name=locks,proto3" json:"locks,omitempty"`
	// If any of the locks have been committed, this is the commit ts used. If no
	// locks have been committed, it will be zero.
	CommitTs uint64 `protobuf:"varint,4,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,5,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckSecondaryLocksResponse) Reset() {
	*x = CheckSecondaryLocksResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckSecondaryLocksResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckSecondaryLocksResponse) ProtoMessage() {}

func (x *CheckSecondaryLocksResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckSecondaryLocksResponse.ProtoReflect.Descriptor instead.
func (*CheckSecondaryLocksResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{16}
}

func (x *CheckSecondaryLocksResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *CheckSecondaryLocksResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CheckSecondaryLocksResponse) GetLocks() []*LockInfo {
	if x != nil {
		return x.Locks
	}
	return nil
}

func (x *CheckSecondaryLocksResponse) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

func (x *CheckSecondaryLocksResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// The second phase of writing to TiKV. If there are no errors or conflicts, then this request
// commits a transaction so that its data can be read by other transactions.
type CommitRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// Identifies the transaction.
	StartVersion uint64 `protobuf:"varint,2,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// All keys in the transaction (to be committed).
	Keys [][]byte `protobuf:"bytes,3,rep,name=keys,proto3" json:"keys,omitempty"`
	// Timestamp for the end of the transaction. Must be greater than `start_version`.
	CommitVersion uint64 `protobuf:"varint,4,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	// commit_role indicates the current commit request is a primary commit or a secondary commit.
	// It's value maybe `Unknown` when using a client with an old version.
	CommitRole CommitRole `protobuf:"varint,6,opt,name=commit_role,json=commitRole,proto3,enum=kvrpcpb.CommitRole" json:"commit_role,omitempty"`
	// primary_key indicates the primary key of the transaction.
	// Its value may be empty when using an old version client.
	PrimaryKey []byte `protobuf:"bytes,7,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	// Whether committing an `use_async_commit` (i.e. should be treated as committed) prewrite.
	UseAsyncCommit bool `protobuf:"varint,8,opt,name=use_async_commit,json=useAsyncCommit,proto3" json:"use_async_commit,omitempty"`
	// Reserved for file based transaction.
	IsTxnFile     bool `protobuf:"varint,100,opt,name=is_txn_file,json=isTxnFile,proto3" json:"is_txn_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitRequest) Reset() {
	*x = CommitRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitRequest) ProtoMessage() {}

func (x *CommitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitRequest.ProtoReflect.Descriptor instead.
func (*CommitRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{17}
}

func (x *CommitRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *CommitRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *CommitRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *CommitRequest) GetCommitVersion() uint64 {
	if x != nil {
		return x.CommitVersion
	}
	return 0
}

func (x *CommitRequest) GetCommitRole() CommitRole {
	if x != nil {
		return x.CommitRole
	}
	return CommitRole_Unknown
}

func (x *CommitRequest) GetPrimaryKey() []byte {
	if x != nil {
		return x.PrimaryKey
	}
	return nil
}

func (x *CommitRequest) GetUseAsyncCommit() bool {
	if x != nil {
		return x.UseAsyncCommit
	}
	return false
}

func (x *CommitRequest) GetIsTxnFile() bool {
	if x != nil {
		return x.IsTxnFile
	}
	return false
}

type CommitResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// If the commit ts is derived from min_commit_ts, this field should be set.
	CommitVersion uint64 `protobuf:"varint,3,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitResponse) Reset() {
	*x = CommitResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitResponse) ProtoMessage() {}

func (x *CommitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitResponse.ProtoReflect.Descriptor instead.
func (*CommitResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{18}
}

func (x *CommitResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *CommitResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CommitResponse) GetCommitVersion() uint64 {
	if x != nil {
		return x.CommitVersion
	}
	return 0
}

func (x *CommitResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// Not yet implemented.
type ImportRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mutations     []*Mutation            `protobuf:"bytes,1,rep,name=mutations,proto3" json:"mutations,omitempty"`
	CommitVersion uint64                 `protobuf:"varint,2,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImportRequest) Reset() {
	*x = ImportRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImportRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImportRequest) ProtoMessage() {}

func (x *ImportRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImportRequest.ProtoReflect.Descriptor instead.
func (*ImportRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{19}
}

func (x *ImportRequest) GetMutations() []*Mutation {
	if x != nil {
		return x.Mutations
	}
	return nil
}

func (x *ImportRequest) GetCommitVersion() uint64 {
	if x != nil {
		return x.CommitVersion
	}
	return 0
}

type ImportResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImportResponse) Reset() {
	*x = ImportResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImportResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImportResponse) ProtoMessage() {}

func (x *ImportResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImportResponse.ProtoReflect.Descriptor instead.
func (*ImportResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{20}
}

func (x *ImportResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *ImportResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Cleanup a key by possibly unlocking it.
// From 4.0 onwards, this message is no longer used.
type CleanupRequest struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Context      *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Key          []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	StartVersion uint64                 `protobuf:"varint,3,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// The current timestamp, used in combination with a lock's TTL to determine
	// if the lock has expired. If `current_ts == 0`, then the key will be unlocked
	// irrespective of its TTL.
	CurrentTs     uint64 `protobuf:"varint,4,opt,name=current_ts,json=currentTs,proto3" json:"current_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupRequest) Reset() {
	*x = CleanupRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupRequest) ProtoMessage() {}

func (x *CleanupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupRequest.ProtoReflect.Descriptor instead.
func (*CleanupRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{21}
}

func (x *CleanupRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *CleanupRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *CleanupRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *CleanupRequest) GetCurrentTs() uint64 {
	if x != nil {
		return x.CurrentTs
	}
	return 0
}

type CleanupResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Set if the key is already committed.
	CommitVersion uint64 `protobuf:"varint,3,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupResponse) Reset() {
	*x = CleanupResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupResponse) ProtoMessage() {}

func (x *CleanupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupResponse.ProtoReflect.Descriptor instead.
func (*CleanupResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{22}
}

func (x *CleanupResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *CleanupResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CleanupResponse) GetCommitVersion() uint64 {
	if x != nil {
		return x.CommitVersion
	}
	return 0
}

// Similar to a `Get` request.
type BatchGetRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Keys    [][]byte               `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	Version uint64                 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// If true, the response will include the commit ts of the key.
	NeedCommitTs  bool `protobuf:"varint,4,opt,name=need_commit_ts,json=needCommitTs,proto3" json:"need_commit_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchGetRequest) Reset() {
	*x = BatchGetRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetRequest) ProtoMessage() {}

func (x *BatchGetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetRequest.ProtoReflect.Descriptor instead.
func (*BatchGetRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{23}
}

func (x *BatchGetRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *BatchGetRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *BatchGetRequest) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *BatchGetRequest) GetNeedCommitTs() bool {
	if x != nil {
		return x.NeedCommitTs
	}
	return false
}

type BatchGetResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Pairs       []*KvPair              `protobuf:"bytes,2,rep,name=pairs,proto3" json:"pairs,omitempty"`
	// Time and scan details when processing the request.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	// This KeyError exists when some key is locked but we cannot check locks of all keys.
	// In this case, `pairs` should be empty and the client should redo batch get all the keys
	// after resolving the lock.
	Error         *KeyError `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchGetResponse) Reset() {
	*x = BatchGetResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetResponse) ProtoMessage() {}

func (x *BatchGetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetResponse.ProtoReflect.Descriptor instead.
func (*BatchGetResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{24}
}

func (x *BatchGetResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *BatchGetResponse) GetPairs() []*KvPair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

func (x *BatchGetResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

func (x *BatchGetResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

// Rollback a prewritten transaction. This will remove the preliminary data from the database,
// unlock locks, and leave a rollback tombstone.
type BatchRollbackRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// Identify the transaction to be rolled back.
	StartVersion uint64 `protobuf:"varint,2,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// The keys to rollback.
	Keys [][]byte `protobuf:"bytes,3,rep,name=keys,proto3" json:"keys,omitempty"`
	// Reserved for file based transaction.
	IsTxnFile     bool `protobuf:"varint,100,opt,name=is_txn_file,json=isTxnFile,proto3" json:"is_txn_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchRollbackRequest) Reset() {
	*x = BatchRollbackRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchRollbackRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchRollbackRequest) ProtoMessage() {}

func (x *BatchRollbackRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchRollbackRequest.ProtoReflect.Descriptor instead.
func (*BatchRollbackRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{25}
}

func (x *BatchRollbackRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *BatchRollbackRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *BatchRollbackRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *BatchRollbackRequest) GetIsTxnFile() bool {
	if x != nil {
		return x.IsTxnFile
	}
	return false
}

type BatchRollbackResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,3,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchRollbackResponse) Reset() {
	*x = BatchRollbackResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchRollbackResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchRollbackResponse) ProtoMessage() {}

func (x *BatchRollbackResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchRollbackResponse.ProtoReflect.Descriptor instead.
func (*BatchRollbackResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{26}
}

func (x *BatchRollbackResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *BatchRollbackResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *BatchRollbackResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// Scan the database for locks. Used at the start of the GC process to find all
// old locks.
type ScanLockRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// Returns all locks with a start timestamp before `max_version`.
	MaxVersion uint64 `protobuf:"varint,2,opt,name=max_version,json=maxVersion,proto3" json:"max_version,omitempty"`
	// Start scanning from this key.
	StartKey []byte `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// The maximum number of locks to return.
	Limit uint32 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	// The exclusive upperbound for scanning.
	EndKey        []byte `protobuf:"bytes,5,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScanLockRequest) Reset() {
	*x = ScanLockRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanLockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanLockRequest) ProtoMessage() {}

func (x *ScanLockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanLockRequest.ProtoReflect.Descriptor instead.
func (*ScanLockRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{27}
}

func (x *ScanLockRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *ScanLockRequest) GetMaxVersion() uint64 {
	if x != nil {
		return x.MaxVersion
	}
	return 0
}

func (x *ScanLockRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *ScanLockRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ScanLockRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

type ScanLockResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Info on all locks found by the scan.
	Locks []*LockInfo `protobuf:"bytes,3,rep,name=locks,proto3" json:"locks,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScanLockResponse) Reset() {
	*x = ScanLockResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanLockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanLockResponse) ProtoMessage() {}

func (x *ScanLockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanLockResponse.ProtoReflect.Descriptor instead.
func (*ScanLockResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{28}
}

func (x *ScanLockResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *ScanLockResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ScanLockResponse) GetLocks() []*LockInfo {
	if x != nil {
		return x.Locks
	}
	return nil
}

func (x *ScanLockResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// For all keys locked by the transaction identified by `start_version`, either
// commit or rollback the transaction and unlock the key.
type ResolveLockRequest struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Context      *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartVersion uint64                 `protobuf:"varint,2,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// `commit_version == 0` means the transaction was rolled back.
	// `commit_version > 0` means the transaction was committed at the given timestamp.
	CommitVersion uint64     `protobuf:"varint,3,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	TxnInfos      []*TxnInfo `protobuf:"bytes,4,rep,name=txn_infos,json=txnInfos,proto3" json:"txn_infos,omitempty"`
	// Only resolve specified keys.
	Keys [][]byte `protobuf:"bytes,5,rep,name=keys,proto3" json:"keys,omitempty"`
	// Reserved for file based transaction.
	IsTxnFile     bool `protobuf:"varint,100,opt,name=is_txn_file,json=isTxnFile,proto3" json:"is_txn_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResolveLockRequest) Reset() {
	*x = ResolveLockRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResolveLockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResolveLockRequest) ProtoMessage() {}

func (x *ResolveLockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResolveLockRequest.ProtoReflect.Descriptor instead.
func (*ResolveLockRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{29}
}

func (x *ResolveLockRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *ResolveLockRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *ResolveLockRequest) GetCommitVersion() uint64 {
	if x != nil {
		return x.CommitVersion
	}
	return 0
}

func (x *ResolveLockRequest) GetTxnInfos() []*TxnInfo {
	if x != nil {
		return x.TxnInfos
	}
	return nil
}

func (x *ResolveLockRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *ResolveLockRequest) GetIsTxnFile() bool {
	if x != nil {
		return x.IsTxnFile
	}
	return false
}

type ResolveLockResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,3,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResolveLockResponse) Reset() {
	*x = ResolveLockResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResolveLockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResolveLockResponse) ProtoMessage() {}

func (x *ResolveLockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResolveLockResponse.ProtoReflect.Descriptor instead.
func (*ResolveLockResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{30}
}

func (x *ResolveLockResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *ResolveLockResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ResolveLockResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// Request TiKV to garbage collect all non-current data older than `safe_point`.
type GCRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	SafePoint     uint64                 `protobuf:"varint,2,opt,name=safe_point,json=safePoint,proto3" json:"safe_point,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GCRequest) Reset() {
	*x = GCRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GCRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GCRequest) ProtoMessage() {}

func (x *GCRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GCRequest.ProtoReflect.Descriptor instead.
func (*GCRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{31}
}

func (x *GCRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *GCRequest) GetSafePoint() uint64 {
	if x != nil {
		return x.SafePoint
	}
	return 0
}

type GCResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GCResponse) Reset() {
	*x = GCResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GCResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GCResponse) ProtoMessage() {}

func (x *GCResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GCResponse.ProtoReflect.Descriptor instead.
func (*GCResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{32}
}

func (x *GCResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *GCResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

// Delete a range of data from TiKV.
type DeleteRangeRequest struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Context  *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartKey []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte                 `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// If true, the data will not be immediately deleted, but the operation will
	// still be replicated via Raft. This is used to notify TiKV that the data
	// will be deleted using `unsafe_destroy_range` soon.
	NotifyOnly    bool `protobuf:"varint,4,opt,name=notify_only,json=notifyOnly,proto3" json:"notify_only,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRangeRequest) Reset() {
	*x = DeleteRangeRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRangeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRangeRequest) ProtoMessage() {}

func (x *DeleteRangeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRangeRequest.ProtoReflect.Descriptor instead.
func (*DeleteRangeRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{33}
}

func (x *DeleteRangeRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *DeleteRangeRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *DeleteRangeRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *DeleteRangeRequest) GetNotifyOnly() bool {
	if x != nil {
		return x.NotifyOnly
	}
	return false
}

type DeleteRangeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRangeResponse) Reset() {
	*x = DeleteRangeResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRangeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRangeResponse) ProtoMessage() {}

func (x *DeleteRangeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRangeResponse.ProtoReflect.Descriptor instead.
func (*DeleteRangeResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{34}
}

func (x *DeleteRangeResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *DeleteRangeResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Preparing the flashback for a region/key range will "lock" the region
// so that there is no any read, write or schedule operation could be proposed before
// the actual flashback operation.
type PrepareFlashbackToVersionRequest struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Context  *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartKey []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte                 `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The `start_ts` which we will use to write a lock to prevent
	// the `resolved_ts` from advancing during the whole process.
	StartTs uint64 `protobuf:"varint,4,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// The TS version which the data will flashback to later.
	Version       uint64 `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrepareFlashbackToVersionRequest) Reset() {
	*x = PrepareFlashbackToVersionRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareFlashbackToVersionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareFlashbackToVersionRequest) ProtoMessage() {}

func (x *PrepareFlashbackToVersionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareFlashbackToVersionRequest.ProtoReflect.Descriptor instead.
func (*PrepareFlashbackToVersionRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{35}
}

func (x *PrepareFlashbackToVersionRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PrepareFlashbackToVersionRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *PrepareFlashbackToVersionRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *PrepareFlashbackToVersionRequest) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *PrepareFlashbackToVersionRequest) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

type PrepareFlashbackToVersionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrepareFlashbackToVersionResponse) Reset() {
	*x = PrepareFlashbackToVersionResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareFlashbackToVersionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareFlashbackToVersionResponse) ProtoMessage() {}

func (x *PrepareFlashbackToVersionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareFlashbackToVersionResponse.ProtoReflect.Descriptor instead.
func (*PrepareFlashbackToVersionResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{36}
}

func (x *PrepareFlashbackToVersionResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *PrepareFlashbackToVersionResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Flashback the region to a specific point with the given `version`, please
// make sure the region is "locked" by `PrepareFlashbackToVersionRequest` first,
// otherwise this request will fail.
type FlashbackToVersionRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// The TS version which the data should flashback to.
	Version  uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	StartKey []byte `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The `start_ts` and `commit_ts` which the newly written MVCC version will use.
	// Please make sure the `start_ts` is the same one in `PrepareFlashbackToVersionRequest`.
	StartTs       uint64 `protobuf:"varint,5,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs      uint64 `protobuf:"varint,6,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlashbackToVersionRequest) Reset() {
	*x = FlashbackToVersionRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlashbackToVersionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlashbackToVersionRequest) ProtoMessage() {}

func (x *FlashbackToVersionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlashbackToVersionRequest.ProtoReflect.Descriptor instead.
func (*FlashbackToVersionRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{37}
}

func (x *FlashbackToVersionRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *FlashbackToVersionRequest) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *FlashbackToVersionRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *FlashbackToVersionRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *FlashbackToVersionRequest) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *FlashbackToVersionRequest) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

type FlashbackToVersionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlashbackToVersionResponse) Reset() {
	*x = FlashbackToVersionResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlashbackToVersionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlashbackToVersionResponse) ProtoMessage() {}

func (x *FlashbackToVersionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlashbackToVersionResponse.ProtoReflect.Descriptor instead.
func (*FlashbackToVersionResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{38}
}

func (x *FlashbackToVersionResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *FlashbackToVersionResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RawGetRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Cf            string                 `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawGetRequest) Reset() {
	*x = RawGetRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawGetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawGetRequest) ProtoMessage() {}

func (x *RawGetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawGetRequest.ProtoReflect.Descriptor instead.
func (*RawGetRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{39}
}

func (x *RawGetRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawGetRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *RawGetRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

type RawGetResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Value         []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	NotFound      bool                   `protobuf:"varint,4,opt,name=not_found,json=notFound,proto3" json:"not_found,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawGetResponse) Reset() {
	*x = RawGetResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawGetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawGetResponse) ProtoMessage() {}

func (x *RawGetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawGetResponse.ProtoReflect.Descriptor instead.
func (*RawGetResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{40}
}

func (x *RawGetResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawGetResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *RawGetResponse) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *RawGetResponse) GetNotFound() bool {
	if x != nil {
		return x.NotFound
	}
	return false
}

type RawBatchGetRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Keys          [][]byte               `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	Cf            string                 `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawBatchGetRequest) Reset() {
	*x = RawBatchGetRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawBatchGetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawBatchGetRequest) ProtoMessage() {}

func (x *RawBatchGetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawBatchGetRequest.ProtoReflect.Descriptor instead.
func (*RawBatchGetRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{41}
}

func (x *RawBatchGetRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawBatchGetRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *RawBatchGetRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

type RawBatchGetResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Pairs         []*KvPair              `protobuf:"bytes,2,rep,name=pairs,proto3" json:"pairs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawBatchGetResponse) Reset() {
	*x = RawBatchGetResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawBatchGetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawBatchGetResponse) ProtoMessage() {}

func (x *RawBatchGetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawBatchGetResponse.ProtoReflect.Descriptor instead.
func (*RawBatchGetResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{42}
}

func (x *RawBatchGetResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawBatchGetResponse) GetPairs() []*KvPair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

type RawPutRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Cf            string                 `protobuf:"bytes,4,opt,name=cf,proto3" json:"cf,omitempty"`
	Ttl           uint64                 `protobuf:"varint,5,opt,name=ttl,proto3" json:"ttl,omitempty"`
	ForCas        bool                   `protobuf:"varint,6,opt,name=for_cas,json=forCas,proto3" json:"for_cas,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawPutRequest) Reset() {
	*x = RawPutRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawPutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawPutRequest) ProtoMessage() {}

func (x *RawPutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawPutRequest.ProtoReflect.Descriptor instead.
func (*RawPutRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{43}
}

func (x *RawPutRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawPutRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *RawPutRequest) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *RawPutRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *RawPutRequest) GetTtl() uint64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *RawPutRequest) GetForCas() bool {
	if x != nil {
		return x.ForCas
	}
	return false
}

type RawPutResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawPutResponse) Reset() {
	*x = RawPutResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawPutResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawPutResponse) ProtoMessage() {}

func (x *RawPutResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawPutResponse.ProtoReflect.Descriptor instead.
func (*RawPutResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{44}
}

func (x *RawPutResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawPutResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RawBatchPutRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Pairs   []*KvPair              `protobuf:"bytes,2,rep,name=pairs,proto3" json:"pairs,omitempty"`
	Cf      string                 `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	// Deprecated: Marked as deprecated in kvrpcpb.proto.
	Ttl    uint64 `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
	ForCas bool   `protobuf:"varint,5,opt,name=for_cas,json=forCas,proto3" json:"for_cas,omitempty"`
	// The time-to-live for each keys in seconds, and if the length of `ttls`
	// is exactly one, the ttl will be applied to all keys. Otherwise, the length
	// mismatch between `ttls` and `pairs` will return an error.
	Ttls          []uint64 `protobuf:"varint,6,rep,packed,name=ttls,proto3" json:"ttls,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawBatchPutRequest) Reset() {
	*x = RawBatchPutRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawBatchPutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawBatchPutRequest) ProtoMessage() {}

func (x *RawBatchPutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawBatchPutRequest.ProtoReflect.Descriptor instead.
func (*RawBatchPutRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{45}
}

func (x *RawBatchPutRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawBatchPutRequest) GetPairs() []*KvPair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

func (x *RawBatchPutRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

// Deprecated: Marked as deprecated in kvrpcpb.proto.
func (x *RawBatchPutRequest) GetTtl() uint64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *RawBatchPutRequest) GetForCas() bool {
	if x != nil {
		return x.ForCas
	}
	return false
}

func (x *RawBatchPutRequest) GetTtls() []uint64 {
	if x != nil {
		return x.Ttls
	}
	return nil
}

type RawBatchPutResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawBatchPutResponse) Reset() {
	*x = RawBatchPutResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawBatchPutResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawBatchPutResponse) ProtoMessage() {}

func (x *RawBatchPutResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawBatchPutResponse.ProtoReflect.Descriptor instead.
func (*RawBatchPutResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{46}
}

func (x *RawBatchPutResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawBatchPutResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RawDeleteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Cf            string                 `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	ForCas        bool                   `protobuf:"varint,4,opt,name=for_cas,json=forCas,proto3" json:"for_cas,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawDeleteRequest) Reset() {
	*x = RawDeleteRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawDeleteRequest) ProtoMessage() {}

func (x *RawDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawDeleteRequest.ProtoReflect.Descriptor instead.
func (*RawDeleteRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{47}
}

func (x *RawDeleteRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawDeleteRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *RawDeleteRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *RawDeleteRequest) GetForCas() bool {
	if x != nil {
		return x.ForCas
	}
	return false
}

type RawDeleteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawDeleteResponse) Reset() {
	*x = RawDeleteResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawDeleteResponse) ProtoMessage() {}

func (x *RawDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawDeleteResponse.ProtoReflect.Descriptor instead.
func (*RawDeleteResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{48}
}

func (x *RawDeleteResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawDeleteResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RawBatchDeleteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Keys          [][]byte               `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	Cf            string                 `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	ForCas        bool                   `protobuf:"varint,4,opt,name=for_cas,json=forCas,proto3" json:"for_cas,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawBatchDeleteRequest) Reset() {
	*x = RawBatchDeleteRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawBatchDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawBatchDeleteRequest) ProtoMessage() {}

func (x *RawBatchDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawBatchDeleteRequest.ProtoReflect.Descriptor instead.
func (*RawBatchDeleteRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{49}
}

func (x *RawBatchDeleteRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawBatchDeleteRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *RawBatchDeleteRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *RawBatchDeleteRequest) GetForCas() bool {
	if x != nil {
		return x.ForCas
	}
	return false
}

type RawBatchDeleteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawBatchDeleteResponse) Reset() {
	*x = RawBatchDeleteResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawBatchDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawBatchDeleteResponse) ProtoMessage() {}

func (x *RawBatchDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawBatchDeleteResponse.ProtoReflect.Descriptor instead.
func (*RawBatchDeleteResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{50}
}

func (x *RawBatchDeleteResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawBatchDeleteResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RawScanRequest struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Context  *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartKey []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	Limit    uint32                 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	KeyOnly  bool                   `protobuf:"varint,4,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	Cf       string                 `protobuf:"bytes,5,opt,name=cf,proto3" json:"cf,omitempty"`
	Reverse  bool                   `protobuf:"varint,6,opt,name=reverse,proto3" json:"reverse,omitempty"`
	// For compatibility, when scanning forward, the range to scan is [start_key, end_key), where start_key < end_key;
	// and when scanning backward, it scans [end_key, start_key) in descending order, where end_key < start_key.
	EndKey        []byte `protobuf:"bytes,7,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawScanRequest) Reset() {
	*x = RawScanRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawScanRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawScanRequest) ProtoMessage() {}

func (x *RawScanRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawScanRequest.ProtoReflect.Descriptor instead.
func (*RawScanRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{51}
}

func (x *RawScanRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawScanRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *RawScanRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *RawScanRequest) GetKeyOnly() bool {
	if x != nil {
		return x.KeyOnly
	}
	return false
}

func (x *RawScanRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *RawScanRequest) GetReverse() bool {
	if x != nil {
		return x.Reverse
	}
	return false
}

func (x *RawScanRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

type RawScanResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Kvs           []*KvPair              `protobuf:"bytes,2,rep,name=kvs,proto3" json:"kvs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawScanResponse) Reset() {
	*x = RawScanResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawScanResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawScanResponse) ProtoMessage() {}

func (x *RawScanResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawScanResponse.ProtoReflect.Descriptor instead.
func (*RawScanResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{52}
}

func (x *RawScanResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawScanResponse) GetKvs() []*KvPair {
	if x != nil {
		return x.Kvs
	}
	return nil
}

type RawDeleteRangeRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartKey      []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey        []byte                 `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Cf            string                 `protobuf:"bytes,4,opt,name=cf,proto3" json:"cf,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawDeleteRangeRequest) Reset() {
	*x = RawDeleteRangeRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawDeleteRangeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawDeleteRangeRequest) ProtoMessage() {}

func (x *RawDeleteRangeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawDeleteRangeRequest.ProtoReflect.Descriptor instead.
func (*RawDeleteRangeRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{53}
}

func (x *RawDeleteRangeRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawDeleteRangeRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *RawDeleteRangeRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *RawDeleteRangeRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

type RawDeleteRangeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawDeleteRangeResponse) Reset() {
	*x = RawDeleteRangeResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawDeleteRangeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawDeleteRangeResponse) ProtoMessage() {}

func (x *RawDeleteRangeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawDeleteRangeResponse.ProtoReflect.Descriptor instead.
func (*RawDeleteRangeResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{54}
}

func (x *RawDeleteRangeResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawDeleteRangeResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RawBatchScanRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Ranges        []*KeyRange            `protobuf:"bytes,2,rep,name=ranges,proto3" json:"ranges,omitempty"`                         // scanning range
	EachLimit     uint32                 `protobuf:"varint,3,opt,name=each_limit,json=eachLimit,proto3" json:"each_limit,omitempty"` // max number of returning kv pairs for each scanning range
	KeyOnly       bool                   `protobuf:"varint,4,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	Cf            string                 `protobuf:"bytes,5,opt,name=cf,proto3" json:"cf,omitempty"`
	Reverse       bool                   `protobuf:"varint,6,opt,name=reverse,proto3" json:"reverse,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawBatchScanRequest) Reset() {
	*x = RawBatchScanRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawBatchScanRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawBatchScanRequest) ProtoMessage() {}

func (x *RawBatchScanRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawBatchScanRequest.ProtoReflect.Descriptor instead.
func (*RawBatchScanRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{55}
}

func (x *RawBatchScanRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawBatchScanRequest) GetRanges() []*KeyRange {
	if x != nil {
		return x.Ranges
	}
	return nil
}

func (x *RawBatchScanRequest) GetEachLimit() uint32 {
	if x != nil {
		return x.EachLimit
	}
	return 0
}

func (x *RawBatchScanRequest) GetKeyOnly() bool {
	if x != nil {
		return x.KeyOnly
	}
	return false
}

func (x *RawBatchScanRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *RawBatchScanRequest) GetReverse() bool {
	if x != nil {
		return x.Reverse
	}
	return false
}

type RawBatchScanResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Kvs           []*KvPair              `protobuf:"bytes,2,rep,name=kvs,proto3" json:"kvs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawBatchScanResponse) Reset() {
	*x = RawBatchScanResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawBatchScanResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawBatchScanResponse) ProtoMessage() {}

func (x *RawBatchScanResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawBatchScanResponse.ProtoReflect.Descriptor instead.
func (*RawBatchScanResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{56}
}

func (x *RawBatchScanResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawBatchScanResponse) GetKvs() []*KvPair {
	if x != nil {
		return x.Kvs
	}
	return nil
}

type UnsafeDestroyRangeRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartKey      []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey        []byte                 `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsafeDestroyRangeRequest) Reset() {
	*x = UnsafeDestroyRangeRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsafeDestroyRangeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsafeDestroyRangeRequest) ProtoMessage() {}

func (x *UnsafeDestroyRangeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsafeDestroyRangeRequest.ProtoReflect.Descriptor instead.
func (*UnsafeDestroyRangeRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{57}
}

func (x *UnsafeDestroyRangeRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *UnsafeDestroyRangeRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *UnsafeDestroyRangeRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

type UnsafeDestroyRangeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsafeDestroyRangeResponse) Reset() {
	*x = UnsafeDestroyRangeResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsafeDestroyRangeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsafeDestroyRangeResponse) ProtoMessage() {}

func (x *UnsafeDestroyRangeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsafeDestroyRangeResponse.ProtoReflect.Descriptor instead.
func (*UnsafeDestroyRangeResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{58}
}

func (x *UnsafeDestroyRangeResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *UnsafeDestroyRangeResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type RegisterLockObserverRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	MaxTs         uint64                 `protobuf:"varint,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterLockObserverRequest) Reset() {
	*x = RegisterLockObserverRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterLockObserverRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterLockObserverRequest) ProtoMessage() {}

func (x *RegisterLockObserverRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterLockObserverRequest.ProtoReflect.Descriptor instead.
func (*RegisterLockObserverRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{59}
}

func (x *RegisterLockObserverRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RegisterLockObserverRequest) GetMaxTs() uint64 {
	if x != nil {
		return x.MaxTs
	}
	return 0
}

type RegisterLockObserverResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         string                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterLockObserverResponse) Reset() {
	*x = RegisterLockObserverResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterLockObserverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterLockObserverResponse) ProtoMessage() {}

func (x *RegisterLockObserverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterLockObserverResponse.ProtoReflect.Descriptor instead.
func (*RegisterLockObserverResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{60}
}

func (x *RegisterLockObserverResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type CheckLockObserverRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	MaxTs         uint64                 `protobuf:"varint,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckLockObserverRequest) Reset() {
	*x = CheckLockObserverRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckLockObserverRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckLockObserverRequest) ProtoMessage() {}

func (x *CheckLockObserverRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckLockObserverRequest.ProtoReflect.Descriptor instead.
func (*CheckLockObserverRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{61}
}

func (x *CheckLockObserverRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *CheckLockObserverRequest) GetMaxTs() uint64 {
	if x != nil {
		return x.MaxTs
	}
	return 0
}

type CheckLockObserverResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         string                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	IsClean       bool                   `protobuf:"varint,2,opt,name=is_clean,json=isClean,proto3" json:"is_clean,omitempty"`
	Locks         []*LockInfo            `protobuf:"bytes,3,rep,name=locks,proto3" json:"locks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckLockObserverResponse) Reset() {
	*x = CheckLockObserverResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckLockObserverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckLockObserverResponse) ProtoMessage() {}

func (x *CheckLockObserverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckLockObserverResponse.ProtoReflect.Descriptor instead.
func (*CheckLockObserverResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{62}
}

func (x *CheckLockObserverResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *CheckLockObserverResponse) GetIsClean() bool {
	if x != nil {
		return x.IsClean
	}
	return false
}

func (x *CheckLockObserverResponse) GetLocks() []*LockInfo {
	if x != nil {
		return x.Locks
	}
	return nil
}

type RemoveLockObserverRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	MaxTs         uint64                 `protobuf:"varint,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveLockObserverRequest) Reset() {
	*x = RemoveLockObserverRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveLockObserverRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveLockObserverRequest) ProtoMessage() {}

func (x *RemoveLockObserverRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveLockObserverRequest.ProtoReflect.Descriptor instead.
func (*RemoveLockObserverRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{63}
}

func (x *RemoveLockObserverRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RemoveLockObserverRequest) GetMaxTs() uint64 {
	if x != nil {
		return x.MaxTs
	}
	return 0
}

type RemoveLockObserverResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         string                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveLockObserverResponse) Reset() {
	*x = RemoveLockObserverResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveLockObserverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveLockObserverResponse) ProtoMessage() {}

func (x *RemoveLockObserverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveLockObserverResponse.ProtoReflect.Descriptor instead.
func (*RemoveLockObserverResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{64}
}

func (x *RemoveLockObserverResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type PhysicalScanLockRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	MaxTs         uint64                 `protobuf:"varint,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	StartKey      []byte                 `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	Limit         uint32                 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PhysicalScanLockRequest) Reset() {
	*x = PhysicalScanLockRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PhysicalScanLockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhysicalScanLockRequest) ProtoMessage() {}

func (x *PhysicalScanLockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhysicalScanLockRequest.ProtoReflect.Descriptor instead.
func (*PhysicalScanLockRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{65}
}

func (x *PhysicalScanLockRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *PhysicalScanLockRequest) GetMaxTs() uint64 {
	if x != nil {
		return x.MaxTs
	}
	return 0
}

func (x *PhysicalScanLockRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *PhysicalScanLockRequest) GetLimit() uint32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type PhysicalScanLockResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         string                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Locks         []*LockInfo            `protobuf:"bytes,2,rep,name=locks,proto3" json:"locks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PhysicalScanLockResponse) Reset() {
	*x = PhysicalScanLockResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PhysicalScanLockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhysicalScanLockResponse) ProtoMessage() {}

func (x *PhysicalScanLockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhysicalScanLockResponse.ProtoReflect.Descriptor instead.
func (*PhysicalScanLockResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{66}
}

func (x *PhysicalScanLockResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *PhysicalScanLockResponse) GetLocks() []*LockInfo {
	if x != nil {
		return x.Locks
	}
	return nil
}

// Sent from PD to a TiKV node.
type SplitRegionRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// Deprecated: Marked as deprecated in kvrpcpb.proto.
	SplitKey  []byte   `protobuf:"bytes,2,opt,name=split_key,json=splitKey,proto3" json:"split_key,omitempty"`
	SplitKeys [][]byte `protobuf:"bytes,3,rep,name=split_keys,json=splitKeys,proto3" json:"split_keys,omitempty"` // when use it to do batch split, `split_key` should be empty.
	// Once enabled, the split_key will not be encoded.
	IsRawKv       bool `protobuf:"varint,4,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SplitRegionRequest) Reset() {
	*x = SplitRegionRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SplitRegionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SplitRegionRequest) ProtoMessage() {}

func (x *SplitRegionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SplitRegionRequest.ProtoReflect.Descriptor instead.
func (*SplitRegionRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{67}
}

func (x *SplitRegionRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

// Deprecated: Marked as deprecated in kvrpcpb.proto.
func (x *SplitRegionRequest) GetSplitKey() []byte {
	if x != nil {
		return x.SplitKey
	}
	return nil
}

func (x *SplitRegionRequest) GetSplitKeys() [][]byte {
	if x != nil {
		return x.SplitKeys
	}
	return nil
}

func (x *SplitRegionRequest) GetIsRawKv() bool {
	if x != nil {
		return x.IsRawKv
	}
	return false
}

type SplitRegionResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	// Deprecated: Marked as deprecated in kvrpcpb.proto.
	Left *metapb.Region `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"` // set when there are only 2 result regions.
	// Deprecated: Marked as deprecated in kvrpcpb.proto.
	Right   *metapb.Region   `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`     // set when there are only 2 result regions.
	Regions []*metapb.Region `protobuf:"bytes,4,rep,name=regions,proto3" json:"regions,omitempty"` // include all result regions.
	// Reserved for file based transaction.
	Errors        []*KeyError `protobuf:"bytes,100,rep,name=errors,proto3" json:"errors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SplitRegionResponse) Reset() {
	*x = SplitRegionResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SplitRegionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SplitRegionResponse) ProtoMessage() {}

func (x *SplitRegionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SplitRegionResponse.ProtoReflect.Descriptor instead.
func (*SplitRegionResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{68}
}

func (x *SplitRegionResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

// Deprecated: Marked as deprecated in kvrpcpb.proto.
func (x *SplitRegionResponse) GetLeft() *metapb.Region {
	if x != nil {
		return x.Left
	}
	return nil
}

// Deprecated: Marked as deprecated in kvrpcpb.proto.
func (x *SplitRegionResponse) GetRight() *metapb.Region {
	if x != nil {
		return x.Right
	}
	return nil
}

func (x *SplitRegionResponse) GetRegions() []*metapb.Region {
	if x != nil {
		return x.Regions
	}
	return nil
}

func (x *SplitRegionResponse) GetErrors() []*KeyError {
	if x != nil {
		return x.Errors
	}
	return nil
}

// Sent from TiFlash to a TiKV node.
type ReadIndexRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Context *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	// TiKV checks the given range if there is any unapplied lock
	// blocking the read request.
	StartTs       uint64      `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Ranges        []*KeyRange `protobuf:"bytes,3,rep,name=ranges,proto3" json:"ranges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadIndexRequest) Reset() {
	*x = ReadIndexRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadIndexRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadIndexRequest) ProtoMessage() {}

func (x *ReadIndexRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadIndexRequest.ProtoReflect.Descriptor instead.
func (*ReadIndexRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{69}
}

func (x *ReadIndexRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *ReadIndexRequest) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *ReadIndexRequest) GetRanges() []*KeyRange {
	if x != nil {
		return x.Ranges
	}
	return nil
}

type ReadIndexResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	ReadIndex   uint64                 `protobuf:"varint,2,opt,name=read_index,json=readIndex,proto3" json:"read_index,omitempty"`
	// If `locked` is set, this read request is blocked by a lock.
	// The lock should be returned to the client.
	Locked        *LockInfo `protobuf:"bytes,3,opt,name=locked,proto3" json:"locked,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadIndexResponse) Reset() {
	*x = ReadIndexResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadIndexResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadIndexResponse) ProtoMessage() {}

func (x *ReadIndexResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadIndexResponse.ProtoReflect.Descriptor instead.
func (*ReadIndexResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{70}
}

func (x *ReadIndexResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *ReadIndexResponse) GetReadIndex() uint64 {
	if x != nil {
		return x.ReadIndex
	}
	return 0
}

func (x *ReadIndexResponse) GetLocked() *LockInfo {
	if x != nil {
		return x.Locked
	}
	return nil
}

type MvccGetByKeyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MvccGetByKeyRequest) Reset() {
	*x = MvccGetByKeyRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccGetByKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccGetByKeyRequest) ProtoMessage() {}

func (x *MvccGetByKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccGetByKeyRequest.ProtoReflect.Descriptor instead.
func (*MvccGetByKeyRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{71}
}

func (x *MvccGetByKeyRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *MvccGetByKeyRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

type MvccGetByKeyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Info          *MvccInfo              `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MvccGetByKeyResponse) Reset() {
	*x = MvccGetByKeyResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccGetByKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccGetByKeyResponse) ProtoMessage() {}

func (x *MvccGetByKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccGetByKeyResponse.ProtoReflect.Descriptor instead.
func (*MvccGetByKeyResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{72}
}

func (x *MvccGetByKeyResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *MvccGetByKeyResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *MvccGetByKeyResponse) GetInfo() *MvccInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

type MvccGetByStartTsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	StartTs       uint64                 `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MvccGetByStartTsRequest) Reset() {
	*x = MvccGetByStartTsRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccGetByStartTsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccGetByStartTsRequest) ProtoMessage() {}

func (x *MvccGetByStartTsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccGetByStartTsRequest.ProtoReflect.Descriptor instead.
func (*MvccGetByStartTsRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{73}
}

func (x *MvccGetByStartTsRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *MvccGetByStartTsRequest) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

type MvccGetByStartTsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Key           []byte                 `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Info          *MvccInfo              `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MvccGetByStartTsResponse) Reset() {
	*x = MvccGetByStartTsResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccGetByStartTsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccGetByStartTsResponse) ProtoMessage() {}

func (x *MvccGetByStartTsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccGetByStartTsResponse.ProtoReflect.Descriptor instead.
func (*MvccGetByStartTsResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{74}
}

func (x *MvccGetByStartTsResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *MvccGetByStartTsResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *MvccGetByStartTsResponse) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *MvccGetByStartTsResponse) GetInfo() *MvccInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

// Miscellaneous metadata attached to most requests.
type Context struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	RegionId       uint64                 `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	RegionEpoch    *metapb.RegionEpoch    `protobuf:"bytes,2,opt,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	Peer           *metapb.Peer           `protobuf:"bytes,3,opt,name=peer,proto3" json:"peer,omitempty"`
	Term           uint64                 `protobuf:"varint,5,opt,name=term,proto3" json:"term,omitempty"`
	Priority       CommandPri             `protobuf:"varint,6,opt,name=priority,proto3,enum=kvrpcpb.CommandPri" json:"priority,omitempty"`
	IsolationLevel IsolationLevel         `protobuf:"varint,7,opt,name=isolation_level,json=isolationLevel,proto3,enum=kvrpcpb.IsolationLevel" json:"isolation_level,omitempty"`
	NotFillCache   bool                   `protobuf:"varint,8,opt,name=not_fill_cache,json=notFillCache,proto3" json:"not_fill_cache,omitempty"`
	SyncLog        bool                   `protobuf:"varint,9,opt,name=sync_log,json=syncLog,proto3" json:"sync_log,omitempty"`
	// True means execution time statistics should be recorded and returned.
	RecordTimeStat bool `protobuf:"varint,10,opt,name=record_time_stat,json=recordTimeStat,proto3" json:"record_time_stat,omitempty"`
	// True means RocksDB scan statistics should be recorded and returned.
	RecordScanStat bool `protobuf:"varint,11,opt,name=record_scan_stat,json=recordScanStat,proto3" json:"record_scan_stat,omitempty"`
	ReplicaRead    bool `protobuf:"varint,12,opt,name=replica_read,json=replicaRead,proto3" json:"replica_read,omitempty"`
	// Read requests can ignore locks belonging to these transactions because either
	// these transactions are rolled back or theirs commit_ts > read request's start_ts.
	ResolvedLocks          []uint64 `protobuf:"varint,13,rep,packed,name=resolved_locks,json=resolvedLocks,proto3" json:"resolved_locks,omitempty"`
	MaxExecutionDurationMs uint64   `protobuf:"varint,14,opt,name=max_execution_duration_ms,json=maxExecutionDurationMs,proto3" json:"max_execution_duration_ms,omitempty"`
	// After a region applies to `applied_index`, we can get a
	// snapshot for the region even if the peer is a follower.
	AppliedIndex uint64 `protobuf:"varint,15,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	// A hint for TiKV to schedule tasks more fairly. Query with same task ID
	// may share same priority and resource quota.
	TaskId uint64 `protobuf:"varint,16,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// Not required to read the most up-to-date data, replicas with `safe_ts` >= `start_ts`
	// can handle read request directly
	StaleRead bool `protobuf:"varint,17,opt,name=stale_read,json=staleRead,proto3" json:"stale_read,omitempty"`
	// Any additional serialized information about the request.
	ResourceGroupTag []byte `protobuf:"bytes,18,opt,name=resource_group_tag,json=resourceGroupTag,proto3" json:"resource_group_tag,omitempty"`
	// Used to tell TiKV whether operations are allowed or not on different disk usages.
	DiskFullOpt DiskFullOpt `protobuf:"varint,19,opt,name=disk_full_opt,json=diskFullOpt,proto3,enum=kvrpcpb.DiskFullOpt" json:"disk_full_opt,omitempty"`
	// Indicates the request is a retry request and the same request may have been sent before.
	IsRetryRequest bool `protobuf:"varint,20,opt,name=is_retry_request,json=isRetryRequest,proto3" json:"is_retry_request,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion APIVersion `protobuf:"varint,21,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// Read request should read through locks belonging to these transactions because these
	// transactions are committed and theirs commit_ts <= read request's start_ts.
	CommittedLocks []uint64 `protobuf:"varint,22,rep,packed,name=committed_locks,json=committedLocks,proto3" json:"committed_locks,omitempty"`
	// The informantion to trace a request sent to TiKV.
	TraceContext *tracepb.TraceContext `protobuf:"bytes,23,opt,name=trace_context,json=traceContext,proto3" json:"trace_context,omitempty"`
	// The source of the request, will be used as the tag of the metrics reporting.
	// This field can be set for any requests that require to report metrics with any extra labels.
	RequestSource string `protobuf:"bytes,24,opt,name=request_source,json=requestSource,proto3" json:"request_source,omitempty"`
	// The source of the current transaction.
	TxnSource uint64 `protobuf:"varint,25,opt,name=txn_source,json=txnSource,proto3" json:"txn_source,omitempty"`
	// If `busy_threshold_ms` is given, TiKV can reject the request and return a `ServerIsBusy`
	// error before processing if the estimated waiting duration exceeds the threshold.
	BusyThresholdMs uint32 `protobuf:"varint,27,opt,name=busy_threshold_ms,json=busyThresholdMs,proto3" json:"busy_threshold_ms,omitempty"`
	// Some information used for resource control.
	ResourceControlContext *ResourceControlContext `protobuf:"bytes,28,opt,name=resource_control_context,json=resourceControlContext,proto3" json:"resource_control_context,omitempty"`
	// The keyspace that the request is sent to.
	// NOTE: This field is only meaningful while the api_version is V2.
	KeyspaceName string `protobuf:"bytes,31,opt,name=keyspace_name,json=keyspaceName,proto3" json:"keyspace_name,omitempty"`
	// The keyspace that the request is sent to.
	// NOTE: This field is only meaningful while the api_version is V2.
	KeyspaceId uint32 `protobuf:"varint,32,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	// The buckets version that the request is sent to.
	// NOTE: This field is only meaningful while enable buckets.
	BucketsVersion uint64 `protobuf:"varint,33,opt,name=buckets_version,json=bucketsVersion,proto3" json:"buckets_version,omitempty"`
	// It tells us where the request comes from in TiDB. If it isn't from TiDB, leave it blank.
	// This is for tests only and thus can be safely changed/removed without affecting compatibility.
	SourceStmt *SourceStmt `protobuf:"bytes,34,opt,name=source_stmt,json=sourceStmt,proto3" json:"source_stmt,omitempty"`
	// The cluster id of the request
	ClusterId uint64 `protobuf:"varint,35,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// The trace id of the request, will be used for tracing the request's execution's inner steps.
	TraceId []byte `protobuf:"bytes,36,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	// Control flags for trace logging behavior.
	// Bit 0: immediate_log - Force immediate logging without buffering
	// Bit 1: category_req_resp - Enable request/response tracing
	// Bit 2: category_write_details - Enable detailed write tracing
	// Bit 3: category_read_details - Enable detailed read tracing
	// Bits 4-63: Reserved for future use
	// This field is set by client-go based on an extractor function provided by TiDB.
	TraceControlFlags uint64 `protobuf:"varint,37,opt,name=trace_control_flags,json=traceControlFlags,proto3" json:"trace_control_flags,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Context) Reset() {
	*x = Context{}
	mi := &file_kvrpcpb_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Context) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Context) ProtoMessage() {}

func (x *Context) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Context.ProtoReflect.Descriptor instead.
func (*Context) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{75}
}

func (x *Context) GetRegionId() uint64 {
	if x != nil {
		return x.RegionId
	}
	return 0
}

func (x *Context) GetRegionEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.RegionEpoch
	}
	return nil
}

func (x *Context) GetPeer() *metapb.Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *Context) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

func (x *Context) GetPriority() CommandPri {
	if x != nil {
		return x.Priority
	}
	return CommandPri_Normal
}

func (x *Context) GetIsolationLevel() IsolationLevel {
	if x != nil {
		return x.IsolationLevel
	}
	return IsolationLevel_SI
}

func (x *Context) GetNotFillCache() bool {
	if x != nil {
		return x.NotFillCache
	}
	return false
}

func (x *Context) GetSyncLog() bool {
	if x != nil {
		return x.SyncLog
	}
	return false
}

func (x *Context) GetRecordTimeStat() bool {
	if x != nil {
		return x.RecordTimeStat
	}
	return false
}

func (x *Context) GetRecordScanStat() bool {
	if x != nil {
		return x.RecordScanStat
	}
	return false
}

func (x *Context) GetReplicaRead() bool {
	if x != nil {
		return x.ReplicaRead
	}
	return false
}

func (x *Context) GetResolvedLocks() []uint64 {
	if x != nil {
		return x.ResolvedLocks
	}
	return nil
}

func (x *Context) GetMaxExecutionDurationMs() uint64 {
	if x != nil {
		return x.MaxExecutionDurationMs
	}
	return 0
}

func (x *Context) GetAppliedIndex() uint64 {
	if x != nil {
		return x.AppliedIndex
	}
	return 0
}

func (x *Context) GetTaskId() uint64 {
	if x != nil {
		return x.TaskId
	}
	return 0
}

func (x *Context) GetStaleRead() bool {
	if x != nil {
		return x.StaleRead
	}
	return false
}

func (x *Context) GetResourceGroupTag() []byte {
	if x != nil {
		return x.ResourceGroupTag
	}
	return nil
}

func (x *Context) GetDiskFullOpt() DiskFullOpt {
	if x != nil {
		return x.DiskFullOpt
	}
	return DiskFullOpt_NotAllowedOnFull
}

func (x *Context) GetIsRetryRequest() bool {
	if x != nil {
		return x.IsRetryRequest
	}
	return false
}

func (x *Context) GetApiVersion() APIVersion {
	if x != nil {
		return x.ApiVersion
	}
	return APIVersion_V1
}

func (x *Context) GetCommittedLocks() []uint64 {
	if x != nil {
		return x.CommittedLocks
	}
	return nil
}

func (x *Context) GetTraceContext() *tracepb.TraceContext {
	if x != nil {
		return x.TraceContext
	}
	return nil
}

func (x *Context) GetRequestSource() string {
	if x != nil {
		return x.RequestSource
	}
	return ""
}

func (x *Context) GetTxnSource() uint64 {
	if x != nil {
		return x.TxnSource
	}
	return 0
}

func (x *Context) GetBusyThresholdMs() uint32 {
	if x != nil {
		return x.BusyThresholdMs
	}
	return 0
}

func (x *Context) GetResourceControlContext() *ResourceControlContext {
	if x != nil {
		return x.ResourceControlContext
	}
	return nil
}

func (x *Context) GetKeyspaceName() string {
	if x != nil {
		return x.KeyspaceName
	}
	return ""
}

func (x *Context) GetKeyspaceId() uint32 {
	if x != nil {
		return x.KeyspaceId
	}
	return 0
}

func (x *Context) GetBucketsVersion() uint64 {
	if x != nil {
		return x.BucketsVersion
	}
	return 0
}

func (x *Context) GetSourceStmt() *SourceStmt {
	if x != nil {
		return x.SourceStmt
	}
	return nil
}

func (x *Context) GetClusterId() uint64 {
	if x != nil {
		return x.ClusterId
	}
	return 0
}

func (x *Context) GetTraceId() []byte {
	if x != nil {
		return x.TraceId
	}
	return nil
}

func (x *Context) GetTraceControlFlags() uint64 {
	if x != nil {
		return x.TraceControlFlags
	}
	return 0
}

type ResourceControlContext struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// It's used to identify which resource group the request belongs to.
	ResourceGroupName string `protobuf:"bytes,1,opt,name=resource_group_name,json=resourceGroupName,proto3" json:"resource_group_name,omitempty"`
	// The resource consumption of the resource group that have completed at all TiKVs between the previous request to this TiKV and current request.
	// It's used as penalty to make the local resource scheduling on one TiKV takes the gloabl resource consumption into consideration.
	Penalty *resource_manager.Consumption `protobuf:"bytes,2,opt,name=penalty,proto3" json:"penalty,omitempty"`
	// This priority would override the original priority of the resource group for the request.
	// Used to deprioritize the runaway queries.
	OverridePriority uint64 `protobuf:"varint,3,opt,name=override_priority,json=overridePriority,proto3" json:"override_priority,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ResourceControlContext) Reset() {
	*x = ResourceControlContext{}
	mi := &file_kvrpcpb_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResourceControlContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResourceControlContext) ProtoMessage() {}

func (x *ResourceControlContext) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResourceControlContext.ProtoReflect.Descriptor instead.
func (*ResourceControlContext) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{76}
}

func (x *ResourceControlContext) GetResourceGroupName() string {
	if x != nil {
		return x.ResourceGroupName
	}
	return ""
}

func (x *ResourceControlContext) GetPenalty() *resource_manager.Consumption {
	if x != nil {
		return x.Penalty
	}
	return nil
}

func (x *ResourceControlContext) GetOverridePriority() uint64 {
	if x != nil {
		return x.OverridePriority
	}
	return 0
}

type SourceStmt struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	StartTs      uint64                 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	ConnectionId uint64                 `protobuf:"varint,2,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	StmtId       uint64                 `protobuf:"varint,3,opt,name=stmt_id,json=stmtId,proto3" json:"stmt_id,omitempty"`
	// session alias set by user
	SessionAlias  string `protobuf:"bytes,4,opt,name=session_alias,json=sessionAlias,proto3" json:"session_alias,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceStmt) Reset() {
	*x = SourceStmt{}
	mi := &file_kvrpcpb_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceStmt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceStmt) ProtoMessage() {}

func (x *SourceStmt) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceStmt.ProtoReflect.Descriptor instead.
func (*SourceStmt) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{77}
}

func (x *SourceStmt) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *SourceStmt) GetConnectionId() uint64 {
	if x != nil {
		return x.ConnectionId
	}
	return 0
}

func (x *SourceStmt) GetStmtId() uint64 {
	if x != nil {
		return x.StmtId
	}
	return 0
}

func (x *SourceStmt) GetSessionAlias() string {
	if x != nil {
		return x.SessionAlias
	}
	return ""
}

type LockInfo struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	PrimaryLock []byte                 `protobuf:"bytes,1,opt,name=primary_lock,json=primaryLock,proto3" json:"primary_lock,omitempty"`
	LockVersion uint64                 `protobuf:"varint,2,opt,name=lock_version,json=lockVersion,proto3" json:"lock_version,omitempty"`
	Key         []byte                 `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	LockTtl     uint64                 `protobuf:"varint,4,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	// How many keys this transaction involves in this region.
	TxnSize         uint64 `protobuf:"varint,5,opt,name=txn_size,json=txnSize,proto3" json:"txn_size,omitempty"`
	LockType        Op     `protobuf:"varint,6,opt,name=lock_type,json=lockType,proto3,enum=kvrpcpb.Op" json:"lock_type,omitempty"`
	LockForUpdateTs uint64 `protobuf:"varint,7,opt,name=lock_for_update_ts,json=lockForUpdateTs,proto3" json:"lock_for_update_ts,omitempty"`
	// Fields for transactions that are using Async Commit.
	UseAsyncCommit bool     `protobuf:"varint,8,opt,name=use_async_commit,json=useAsyncCommit,proto3" json:"use_async_commit,omitempty"`
	MinCommitTs    uint64   `protobuf:"varint,9,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	Secondaries    [][]byte `protobuf:"bytes,10,rep,name=secondaries,proto3" json:"secondaries,omitempty"`
	// The time elapsed since last update of lock wait info when waiting.
	// It's used in timeout errors. 0 means unknown or not applicable.
	// It can be used to help the client decide whether to try resolving the lock.
	DurationToLastUpdateMs uint64 `protobuf:"varint,11,opt,name=duration_to_last_update_ms,json=durationToLastUpdateMs,proto3" json:"duration_to_last_update_ms,omitempty"`
	// When lock_type is SharedLock, this describes transactions holding the shared lock.
	// Important: when lock_type is SharedLock, all shared locks must use shared_lock_infos;
	// DO NOT read from the wrapper LockInfo.
	// TODO(slock): tidb should send requests with a feature flag to indicate whether it
	// supports shared locks, so that tikv can fail the requests from old tidb versions
	// when needed.
	SharedLockInfos []*LockInfo `protobuf:"bytes,12,rep,name=shared_lock_infos,json=sharedLockInfos,proto3" json:"shared_lock_infos,omitempty"`
	// Reserved for file based transaction.
	IsTxnFile     bool `protobuf:"varint,100,opt,name=is_txn_file,json=isTxnFile,proto3" json:"is_txn_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LockInfo) Reset() {
	*x = LockInfo{}
	mi := &file_kvrpcpb_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LockInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LockInfo) ProtoMessage() {}

func (x *LockInfo) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LockInfo.ProtoReflect.Descriptor instead.
func (*LockInfo) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{78}
}

func (x *LockInfo) GetPrimaryLock() []byte {
	if x != nil {
		return x.PrimaryLock
	}
	return nil
}

func (x *LockInfo) GetLockVersion() uint64 {
	if x != nil {
		return x.LockVersion
	}
	return 0
}

func (x *LockInfo) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *LockInfo) GetLockTtl() uint64 {
	if x != nil {
		return x.LockTtl
	}
	return 0
}

func (x *LockInfo) GetTxnSize() uint64 {
	if x != nil {
		return x.TxnSize
	}
	return 0
}

func (x *LockInfo) GetLockType() Op {
	if x != nil {
		return x.LockType
	}
	return Op_Put
}

func (x *LockInfo) GetLockForUpdateTs() uint64 {
	if x != nil {
		return x.LockForUpdateTs
	}
	return 0
}

func (x *LockInfo) GetUseAsyncCommit() bool {
	if x != nil {
		return x.UseAsyncCommit
	}
	return false
}

func (x *LockInfo) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

func (x *LockInfo) GetSecondaries() [][]byte {
	if x != nil {
		return x.Secondaries
	}
	return nil
}

func (x *LockInfo) GetDurationToLastUpdateMs() uint64 {
	if x != nil {
		return x.DurationToLastUpdateMs
	}
	return 0
}

func (x *LockInfo) GetSharedLockInfos() []*LockInfo {
	if x != nil {
		return x.SharedLockInfos
	}
	return nil
}

func (x *LockInfo) GetIsTxnFile() bool {
	if x != nil {
		return x.IsTxnFile
	}
	return false
}

type KeyError struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Locked           *LockInfo              `protobuf:"bytes,1,opt,name=locked,proto3" json:"locked,omitempty"`                                                 // Client should backoff or cleanup the lock then retry.
	Retryable        string                 `protobuf:"bytes,2,opt,name=retryable,proto3" json:"retryable,omitempty"`                                           // Client may restart the txn. e.g write conflict.
	Abort            string                 `protobuf:"bytes,3,opt,name=abort,proto3" json:"abort,omitempty"`                                                   // Client should abort the txn.
	Conflict         *WriteConflict         `protobuf:"bytes,4,opt,name=conflict,proto3" json:"conflict,omitempty"`                                             // Write conflict is moved from retryable to here.
	AlreadyExist     *AlreadyExist          `protobuf:"bytes,5,opt,name=already_exist,json=alreadyExist,proto3" json:"already_exist,omitempty"`                 // Key already exists
	Deadlock         *Deadlock              `protobuf:"bytes,6,opt,name=deadlock,proto3" json:"deadlock,omitempty"`                                             // Deadlock is used in pessimistic transaction for single statement rollback.
	CommitTsExpired  *CommitTsExpired       `protobuf:"bytes,7,opt,name=commit_ts_expired,json=commitTsExpired,proto3" json:"commit_ts_expired,omitempty"`      // Commit ts is earlier than min commit ts of a transaction.
	TxnNotFound      *TxnNotFound           `protobuf:"bytes,8,opt,name=txn_not_found,json=txnNotFound,proto3" json:"txn_not_found,omitempty"`                  // Txn not found when checking txn status.
	CommitTsTooLarge *CommitTsTooLarge      `protobuf:"bytes,9,opt,name=commit_ts_too_large,json=commitTsTooLarge,proto3" json:"commit_ts_too_large,omitempty"` // Calculated commit TS exceeds the limit given by the user.
	AssertionFailed  *AssertionFailed       `protobuf:"bytes,10,opt,name=assertion_failed,json=assertionFailed,proto3" json:"assertion_failed,omitempty"`       // Assertion of a `Mutation` is evaluated as a failure.
	PrimaryMismatch  *PrimaryMismatch       `protobuf:"bytes,11,opt,name=primary_mismatch,json=primaryMismatch,proto3" json:"primary_mismatch,omitempty"`       // CheckTxnStatus is sent to a lock that's not the primary.
	TxnLockNotFound  *TxnLockNotFound       `protobuf:"bytes,12,opt,name=txn_lock_not_found,json=txnLockNotFound,proto3" json:"txn_lock_not_found,omitempty"`   // TxnLockNotFound indicates the txn lock is not found.
	// Extra information for error debugging
	DebugInfo     *DebugInfo `protobuf:"bytes,100,opt,name=debug_info,json=debugInfo,proto3" json:"debug_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyError) Reset() {
	*x = KeyError{}
	mi := &file_kvrpcpb_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyError) ProtoMessage() {}

func (x *KeyError) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyError.ProtoReflect.Descriptor instead.
func (*KeyError) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{79}
}

func (x *KeyError) GetLocked() *LockInfo {
	if x != nil {
		return x.Locked
	}
	return nil
}

func (x *KeyError) GetRetryable() string {
	if x != nil {
		return x.Retryable
	}
	return ""
}

func (x *KeyError) GetAbort() string {
	if x != nil {
		return x.Abort
	}
	return ""
}

func (x *KeyError) GetConflict() *WriteConflict {
	if x != nil {
		return x.Conflict
	}
	return nil
}

func (x *KeyError) GetAlreadyExist() *AlreadyExist {
	if x != nil {
		return x.AlreadyExist
	}
	return nil
}

func (x *KeyError) GetDeadlock() *Deadlock {
	if x != nil {
		return x.Deadlock
	}
	return nil
}

func (x *KeyError) GetCommitTsExpired() *CommitTsExpired {
	if x != nil {
		return x.CommitTsExpired
	}
	return nil
}

func (x *KeyError) GetTxnNotFound() *TxnNotFound {
	if x != nil {
		return x.TxnNotFound
	}
	return nil
}

func (x *KeyError) GetCommitTsTooLarge() *CommitTsTooLarge {
	if x != nil {
		return x.CommitTsTooLarge
	}
	return nil
}

func (x *KeyError) GetAssertionFailed() *AssertionFailed {
	if x != nil {
		return x.AssertionFailed
	}
	return nil
}

func (x *KeyError) GetPrimaryMismatch() *PrimaryMismatch {
	if x != nil {
		return x.PrimaryMismatch
	}
	return nil
}

func (x *KeyError) GetTxnLockNotFound() *TxnLockNotFound {
	if x != nil {
		return x.TxnLockNotFound
	}
	return nil
}

func (x *KeyError) GetDebugInfo() *DebugInfo {
	if x != nil {
		return x.DebugInfo
	}
	return nil
}

type WriteConflict struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	StartTs          uint64                 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	ConflictTs       uint64                 `protobuf:"varint,2,opt,name=conflict_ts,json=conflictTs,proto3" json:"conflict_ts,omitempty"`
	Key              []byte                 `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Primary          []byte                 `protobuf:"bytes,4,opt,name=primary,proto3" json:"primary,omitempty"`
	ConflictCommitTs uint64                 `protobuf:"varint,5,opt,name=conflict_commit_ts,json=conflictCommitTs,proto3" json:"conflict_commit_ts,omitempty"`
	Reason           WriteConflict_Reason   `protobuf:"varint,6,opt,name=reason,proto3,enum=kvrpcpb.WriteConflict_Reason" json:"reason,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *WriteConflict) Reset() {
	*x = WriteConflict{}
	mi := &file_kvrpcpb_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteConflict) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteConflict) ProtoMessage() {}

func (x *WriteConflict) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteConflict.ProtoReflect.Descriptor instead.
func (*WriteConflict) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{80}
}

func (x *WriteConflict) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *WriteConflict) GetConflictTs() uint64 {
	if x != nil {
		return x.ConflictTs
	}
	return 0
}

func (x *WriteConflict) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *WriteConflict) GetPrimary() []byte {
	if x != nil {
		return x.Primary
	}
	return nil
}

func (x *WriteConflict) GetConflictCommitTs() uint64 {
	if x != nil {
		return x.ConflictCommitTs
	}
	return 0
}

func (x *WriteConflict) GetReason() WriteConflict_Reason {
	if x != nil {
		return x.Reason
	}
	return WriteConflict_Unknown
}

type AlreadyExist struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           []byte                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AlreadyExist) Reset() {
	*x = AlreadyExist{}
	mi := &file_kvrpcpb_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlreadyExist) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlreadyExist) ProtoMessage() {}

func (x *AlreadyExist) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlreadyExist.ProtoReflect.Descriptor instead.
func (*AlreadyExist) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{81}
}

func (x *AlreadyExist) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

type Deadlock struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	LockTs  uint64                 `protobuf:"varint,1,opt,name=lock_ts,json=lockTs,proto3" json:"lock_ts,omitempty"`
	LockKey []byte                 `protobuf:"bytes,2,opt,name=lock_key,json=lockKey,proto3" json:"lock_key,omitempty"`
	// The hash of `deadlock_key` field.
	DeadlockKeyHash uint64                   `protobuf:"varint,3,opt,name=deadlock_key_hash,json=deadlockKeyHash,proto3" json:"deadlock_key_hash,omitempty"`
	WaitChain       []*deadlock.WaitForEntry `protobuf:"bytes,4,rep,name=wait_chain,json=waitChain,proto3" json:"wait_chain,omitempty"`
	// The key that the current transaction has already acquired and blocks another transaction to form the deadlock.
	DeadlockKey   []byte `protobuf:"bytes,5,opt,name=deadlock_key,json=deadlockKey,proto3" json:"deadlock_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Deadlock) Reset() {
	*x = Deadlock{}
	mi := &file_kvrpcpb_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Deadlock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Deadlock) ProtoMessage() {}

func (x *Deadlock) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Deadlock.ProtoReflect.Descriptor instead.
func (*Deadlock) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{82}
}

func (x *Deadlock) GetLockTs() uint64 {
	if x != nil {
		return x.LockTs
	}
	return 0
}

func (x *Deadlock) GetLockKey() []byte {
	if x != nil {
		return x.LockKey
	}
	return nil
}

func (x *Deadlock) GetDeadlockKeyHash() uint64 {
	if x != nil {
		return x.DeadlockKeyHash
	}
	return 0
}

func (x *Deadlock) GetWaitChain() []*deadlock.WaitForEntry {
	if x != nil {
		return x.WaitChain
	}
	return nil
}

func (x *Deadlock) GetDeadlockKey() []byte {
	if x != nil {
		return x.DeadlockKey
	}
	return nil
}

type CommitTsExpired struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	StartTs           uint64                 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	AttemptedCommitTs uint64                 `protobuf:"varint,2,opt,name=attempted_commit_ts,json=attemptedCommitTs,proto3" json:"attempted_commit_ts,omitempty"`
	Key               []byte                 `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	MinCommitTs       uint64                 `protobuf:"varint,4,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *CommitTsExpired) Reset() {
	*x = CommitTsExpired{}
	mi := &file_kvrpcpb_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitTsExpired) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitTsExpired) ProtoMessage() {}

func (x *CommitTsExpired) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitTsExpired.ProtoReflect.Descriptor instead.
func (*CommitTsExpired) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{83}
}

func (x *CommitTsExpired) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *CommitTsExpired) GetAttemptedCommitTs() uint64 {
	if x != nil {
		return x.AttemptedCommitTs
	}
	return 0
}

func (x *CommitTsExpired) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *CommitTsExpired) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

type TxnNotFound struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StartTs       uint64                 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	PrimaryKey    []byte                 `protobuf:"bytes,2,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxnNotFound) Reset() {
	*x = TxnNotFound{}
	mi := &file_kvrpcpb_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxnNotFound) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxnNotFound) ProtoMessage() {}

func (x *TxnNotFound) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxnNotFound.ProtoReflect.Descriptor instead.
func (*TxnNotFound) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{84}
}

func (x *TxnNotFound) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *TxnNotFound) GetPrimaryKey() []byte {
	if x != nil {
		return x.PrimaryKey
	}
	return nil
}

type CommitTsTooLarge struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CommitTs      uint64                 `protobuf:"varint,1,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"` // The calculated commit TS.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitTsTooLarge) Reset() {
	*x = CommitTsTooLarge{}
	mi := &file_kvrpcpb_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitTsTooLarge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitTsTooLarge) ProtoMessage() {}

func (x *CommitTsTooLarge) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitTsTooLarge.ProtoReflect.Descriptor instead.
func (*CommitTsTooLarge) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{85}
}

func (x *CommitTsTooLarge) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

type AssertionFailed struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	StartTs          uint64                 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Key              []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Assertion        Assertion              `protobuf:"varint,3,opt,name=assertion,proto3,enum=kvrpcpb.Assertion" json:"assertion,omitempty"`
	ExistingStartTs  uint64                 `protobuf:"varint,4,opt,name=existing_start_ts,json=existingStartTs,proto3" json:"existing_start_ts,omitempty"`
	ExistingCommitTs uint64                 `protobuf:"varint,5,opt,name=existing_commit_ts,json=existingCommitTs,proto3" json:"existing_commit_ts,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *AssertionFailed) Reset() {
	*x = AssertionFailed{}
	mi := &file_kvrpcpb_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AssertionFailed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AssertionFailed) ProtoMessage() {}

func (x *AssertionFailed) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AssertionFailed.ProtoReflect.Descriptor instead.
func (*AssertionFailed) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{86}
}

func (x *AssertionFailed) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *AssertionFailed) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *AssertionFailed) GetAssertion() Assertion {
	if x != nil {
		return x.Assertion
	}
	return Assertion_None
}

func (x *AssertionFailed) GetExistingStartTs() uint64 {
	if x != nil {
		return x.ExistingStartTs
	}
	return 0
}

func (x *AssertionFailed) GetExistingCommitTs() uint64 {
	if x != nil {
		return x.ExistingCommitTs
	}
	return 0
}

type PrimaryMismatch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LockInfo      *LockInfo              `protobuf:"bytes,1,opt,name=lock_info,json=lockInfo,proto3" json:"lock_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrimaryMismatch) Reset() {
	*x = PrimaryMismatch{}
	mi := &file_kvrpcpb_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrimaryMismatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrimaryMismatch) ProtoMessage() {}

func (x *PrimaryMismatch) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrimaryMismatch.ProtoReflect.Descriptor instead.
func (*PrimaryMismatch) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{87}
}

func (x *PrimaryMismatch) GetLockInfo() *LockInfo {
	if x != nil {
		return x.LockInfo
	}
	return nil
}

type TxnLockNotFound struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           []byte                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxnLockNotFound) Reset() {
	*x = TxnLockNotFound{}
	mi := &file_kvrpcpb_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxnLockNotFound) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxnLockNotFound) ProtoMessage() {}

func (x *TxnLockNotFound) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxnLockNotFound.ProtoReflect.Descriptor instead.
func (*TxnLockNotFound) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{88}
}

func (x *TxnLockNotFound) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

type MvccDebugInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           []byte                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Mvcc          *MvccInfo              `protobuf:"bytes,2,opt,name=mvcc,proto3" json:"mvcc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MvccDebugInfo) Reset() {
	*x = MvccDebugInfo{}
	mi := &file_kvrpcpb_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccDebugInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccDebugInfo) ProtoMessage() {}

func (x *MvccDebugInfo) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccDebugInfo.ProtoReflect.Descriptor instead.
func (*MvccDebugInfo) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{89}
}

func (x *MvccDebugInfo) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *MvccDebugInfo) GetMvcc() *MvccInfo {
	if x != nil {
		return x.Mvcc
	}
	return nil
}

type DebugInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MvccInfo      []*MvccDebugInfo       `protobuf:"bytes,1,rep,name=mvcc_info,json=mvccInfo,proto3" json:"mvcc_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DebugInfo) Reset() {
	*x = DebugInfo{}
	mi := &file_kvrpcpb_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DebugInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DebugInfo) ProtoMessage() {}

func (x *DebugInfo) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DebugInfo.ProtoReflect.Descriptor instead.
func (*DebugInfo) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{90}
}

func (x *DebugInfo) GetMvccInfo() []*MvccDebugInfo {
	if x != nil {
		return x.MvccInfo
	}
	return nil
}

type TimeDetail struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Off-cpu wall time elapsed in TiKV side. Usually this includes queue waiting time and
	// other kind of waitings in series. (Wait time in the raftstore is not included.)
	WaitWallTimeMs uint64 `protobuf:"varint,1,opt,name=wait_wall_time_ms,json=waitWallTimeMs,proto3" json:"wait_wall_time_ms,omitempty"`
	// Off-cpu and on-cpu wall time elapsed to actually process the request payload. It does not
	// include `wait_wall_time`.
	// This field is very close to the CPU time in most cases. Some wait time spend in RocksDB
	// cannot be excluded for now, like Mutex wait time, which is included in this field, so that
	// this field is called wall time instead of CPU time.
	ProcessWallTimeMs uint64 `protobuf:"varint,2,opt,name=process_wall_time_ms,json=processWallTimeMs,proto3" json:"process_wall_time_ms,omitempty"`
	// KV read wall Time means the time used in key/value scan and get.
	KvReadWallTimeMs uint64 `protobuf:"varint,3,opt,name=kv_read_wall_time_ms,json=kvReadWallTimeMs,proto3" json:"kv_read_wall_time_ms,omitempty"`
	// Total wall clock time spent on this RPC in TiKV .
	TotalRpcWallTimeNs uint64 `protobuf:"varint,4,opt,name=total_rpc_wall_time_ns,json=totalRpcWallTimeNs,proto3" json:"total_rpc_wall_time_ns,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *TimeDetail) Reset() {
	*x = TimeDetail{}
	mi := &file_kvrpcpb_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeDetail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeDetail) ProtoMessage() {}

func (x *TimeDetail) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeDetail.ProtoReflect.Descriptor instead.
func (*TimeDetail) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{91}
}

func (x *TimeDetail) GetWaitWallTimeMs() uint64 {
	if x != nil {
		return x.WaitWallTimeMs
	}
	return 0
}

func (x *TimeDetail) GetProcessWallTimeMs() uint64 {
	if x != nil {
		return x.ProcessWallTimeMs
	}
	return 0
}

func (x *TimeDetail) GetKvReadWallTimeMs() uint64 {
	if x != nil {
		return x.KvReadWallTimeMs
	}
	return 0
}

func (x *TimeDetail) GetTotalRpcWallTimeNs() uint64 {
	if x != nil {
		return x.TotalRpcWallTimeNs
	}
	return 0
}

type TimeDetailV2 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Off-cpu wall time elapsed in TiKV side. Usually this includes queue waiting time and
	// other kind of waitings in series. (Wait time in the raftstore is not included.)
	WaitWallTimeNs uint64 `protobuf:"varint,1,opt,name=wait_wall_time_ns,json=waitWallTimeNs,proto3" json:"wait_wall_time_ns,omitempty"`
	// Off-cpu and on-cpu wall time elapsed to actually process the request payload. It does not
	// include `wait_wall_time` and `suspend_wall_time`.
	// This field is very close to the CPU time in most cases. Some wait time spend in RocksDB
	// cannot be excluded for now, like Mutex wait time, which is included in this field, so that
	// this field is called wall time instead of CPU time.
	ProcessWallTimeNs uint64 `protobuf:"varint,2,opt,name=process_wall_time_ns,json=processWallTimeNs,proto3" json:"process_wall_time_ns,omitempty"`
	// Cpu wall time elapsed that task is waiting in queue.
	ProcessSuspendWallTimeNs uint64 `protobuf:"varint,3,opt,name=process_suspend_wall_time_ns,json=processSuspendWallTimeNs,proto3" json:"process_suspend_wall_time_ns,omitempty"`
	// KV read wall Time means the time used in key/value scan and get.
	KvReadWallTimeNs uint64 `protobuf:"varint,4,opt,name=kv_read_wall_time_ns,json=kvReadWallTimeNs,proto3" json:"kv_read_wall_time_ns,omitempty"`
	// Total wall clock time spent on this RPC in TiKV .
	TotalRpcWallTimeNs uint64 `protobuf:"varint,5,opt,name=total_rpc_wall_time_ns,json=totalRpcWallTimeNs,proto3" json:"total_rpc_wall_time_ns,omitempty"`
	// Time spent on the gRPC layer.
	KvGrpcProcessTimeNs uint64 `protobuf:"varint,6,opt,name=kv_grpc_process_time_ns,json=kvGrpcProcessTimeNs,proto3" json:"kv_grpc_process_time_ns,omitempty"`
	// Time spent on waiting for run again in grpc pool from other executor pool.
	KvGrpcWaitTimeNs uint64 `protobuf:"varint,7,opt,name=kv_grpc_wait_time_ns,json=kvGrpcWaitTimeNs,proto3" json:"kv_grpc_wait_time_ns,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *TimeDetailV2) Reset() {
	*x = TimeDetailV2{}
	mi := &file_kvrpcpb_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeDetailV2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeDetailV2) ProtoMessage() {}

func (x *TimeDetailV2) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeDetailV2.ProtoReflect.Descriptor instead.
func (*TimeDetailV2) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{92}
}

func (x *TimeDetailV2) GetWaitWallTimeNs() uint64 {
	if x != nil {
		return x.WaitWallTimeNs
	}
	return 0
}

func (x *TimeDetailV2) GetProcessWallTimeNs() uint64 {
	if x != nil {
		return x.ProcessWallTimeNs
	}
	return 0
}

func (x *TimeDetailV2) GetProcessSuspendWallTimeNs() uint64 {
	if x != nil {
		return x.ProcessSuspendWallTimeNs
	}
	return 0
}

func (x *TimeDetailV2) GetKvReadWallTimeNs() uint64 {
	if x != nil {
		return x.KvReadWallTimeNs
	}
	return 0
}

func (x *TimeDetailV2) GetTotalRpcWallTimeNs() uint64 {
	if x != nil {
		return x.TotalRpcWallTimeNs
	}
	return 0
}

func (x *TimeDetailV2) GetKvGrpcProcessTimeNs() uint64 {
	if x != nil {
		return x.KvGrpcProcessTimeNs
	}
	return 0
}

func (x *TimeDetailV2) GetKvGrpcWaitTimeNs() uint64 {
	if x != nil {
		return x.KvGrpcWaitTimeNs
	}
	return 0
}

type ScanInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Total         int64                  `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Processed     int64                  `protobuf:"varint,2,opt,name=processed,proto3" json:"processed,omitempty"`
	ReadBytes     int64                  `protobuf:"varint,3,opt,name=read_bytes,json=readBytes,proto3" json:"read_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScanInfo) Reset() {
	*x = ScanInfo{}
	mi := &file_kvrpcpb_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanInfo) ProtoMessage() {}

func (x *ScanInfo) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanInfo.ProtoReflect.Descriptor instead.
func (*ScanInfo) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{93}
}

func (x *ScanInfo) GetTotal() int64 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *ScanInfo) GetProcessed() int64 {
	if x != nil {
		return x.Processed
	}
	return 0
}

func (x *ScanInfo) GetReadBytes() int64 {
	if x != nil {
		return x.ReadBytes
	}
	return 0
}

// Only reserved for compatibility.
type ScanDetail struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Write         *ScanInfo              `protobuf:"bytes,1,opt,name=write,proto3" json:"write,omitempty"`
	Lock          *ScanInfo              `protobuf:"bytes,2,opt,name=lock,proto3" json:"lock,omitempty"`
	Data          *ScanInfo              `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScanDetail) Reset() {
	*x = ScanDetail{}
	mi := &file_kvrpcpb_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanDetail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanDetail) ProtoMessage() {}

func (x *ScanDetail) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanDetail.ProtoReflect.Descriptor instead.
func (*ScanDetail) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{94}
}

func (x *ScanDetail) GetWrite() *ScanInfo {
	if x != nil {
		return x.Write
	}
	return nil
}

func (x *ScanDetail) GetLock() *ScanInfo {
	if x != nil {
		return x.Lock
	}
	return nil
}

func (x *ScanDetail) GetData() *ScanInfo {
	if x != nil {
		return x.Data
	}
	return nil
}

type ScanDetailV2 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of user keys scanned from the storage.
	// It does not include deleted version or RocksDB tombstone keys.
	// For Coprocessor requests, it includes keys that has been filtered out by
	// Selection.
	ProcessedVersions uint64 `protobuf:"varint,1,opt,name=processed_versions,json=processedVersions,proto3" json:"processed_versions,omitempty"`
	// Number of bytes of user key-value pairs scanned from the storage, i.e.
	// total size of data returned from MVCC layer.
	ProcessedVersionsSize uint64 `protobuf:"varint,8,opt,name=processed_versions_size,json=processedVersionsSize,proto3" json:"processed_versions_size,omitempty"`
	// Approximate number of MVCC keys meet during scanning. It includes
	// deleted versions, but does not include RocksDB tombstone keys.
	//
	// When this field is notably larger than `processed_versions`, it means
	// there are a lot of deleted MVCC keys.
	TotalVersions uint64 `protobuf:"varint,2,opt,name=total_versions,json=totalVersions,proto3" json:"total_versions,omitempty"`
	// Total number of deletes and single deletes skipped over during
	// iteration, i.e. how many RocksDB tombstones are skipped.
	RocksdbDeleteSkippedCount uint64 `protobuf:"varint,3,opt,name=rocksdb_delete_skipped_count,json=rocksdbDeleteSkippedCount,proto3" json:"rocksdb_delete_skipped_count,omitempty"`
	// Total number of internal keys skipped over during iteration.
	// See https://github.com/facebook/rocksdb/blob/9f1c84ca471d8b1ad7be9f3eebfc2c7e07dfd7a7/include/rocksdb/perf_context.h#L84 for details.
	RocksdbKeySkippedCount uint64 `protobuf:"varint,4,opt,name=rocksdb_key_skipped_count,json=rocksdbKeySkippedCount,proto3" json:"rocksdb_key_skipped_count,omitempty"`
	// Total number of RocksDB block cache hits.
	RocksdbBlockCacheHitCount uint64 `protobuf:"varint,5,opt,name=rocksdb_block_cache_hit_count,json=rocksdbBlockCacheHitCount,proto3" json:"rocksdb_block_cache_hit_count,omitempty"`
	// Total number of block reads (with IO).
	RocksdbBlockReadCount uint64 `protobuf:"varint,6,opt,name=rocksdb_block_read_count,json=rocksdbBlockReadCount,proto3" json:"rocksdb_block_read_count,omitempty"`
	// Total number of bytes from block reads.
	RocksdbBlockReadByte uint64 `protobuf:"varint,7,opt,name=rocksdb_block_read_byte,json=rocksdbBlockReadByte,proto3" json:"rocksdb_block_read_byte,omitempty"`
	// Total time used for block reads.
	RocksdbBlockReadNanos uint64 `protobuf:"varint,9,opt,name=rocksdb_block_read_nanos,json=rocksdbBlockReadNanos,proto3" json:"rocksdb_block_read_nanos,omitempty"`
	// Time used for getting a raftstore snapshot (including proposing read index, leader confirmation and getting the RocksDB snapshot).
	GetSnapshotNanos uint64 `protobuf:"varint,10,opt,name=get_snapshot_nanos,json=getSnapshotNanos,proto3" json:"get_snapshot_nanos,omitempty"`
	// Time used for proposing read index from read pool to store pool, equals 0 when performing lease read.
	ReadIndexProposeWaitNanos uint64 `protobuf:"varint,11,opt,name=read_index_propose_wait_nanos,json=readIndexProposeWaitNanos,proto3" json:"read_index_propose_wait_nanos,omitempty"`
	// Time used for leader confirmation, equals 0 when performing lease read.
	ReadIndexConfirmWaitNanos uint64 `protobuf:"varint,12,opt,name=read_index_confirm_wait_nanos,json=readIndexConfirmWaitNanos,proto3" json:"read_index_confirm_wait_nanos,omitempty"`
	// Time used for read pool scheduling.
	ReadPoolScheduleWaitNanos uint64 `protobuf:"varint,13,opt,name=read_pool_schedule_wait_nanos,json=readPoolScheduleWaitNanos,proto3" json:"read_pool_schedule_wait_nanos,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *ScanDetailV2) Reset() {
	*x = ScanDetailV2{}
	mi := &file_kvrpcpb_proto_msgTypes[95]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanDetailV2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanDetailV2) ProtoMessage() {}

func (x *ScanDetailV2) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[95]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanDetailV2.ProtoReflect.Descriptor instead.
func (*ScanDetailV2) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{95}
}

func (x *ScanDetailV2) GetProcessedVersions() uint64 {
	if x != nil {
		return x.ProcessedVersions
	}
	return 0
}

func (x *ScanDetailV2) GetProcessedVersionsSize() uint64 {
	if x != nil {
		return x.ProcessedVersionsSize
	}
	return 0
}

func (x *ScanDetailV2) GetTotalVersions() uint64 {
	if x != nil {
		return x.TotalVersions
	}
	return 0
}

func (x *ScanDetailV2) GetRocksdbDeleteSkippedCount() uint64 {
	if x != nil {
		return x.RocksdbDeleteSkippedCount
	}
	return 0
}

func (x *ScanDetailV2) GetRocksdbKeySkippedCount() uint64 {
	if x != nil {
		return x.RocksdbKeySkippedCount
	}
	return 0
}

func (x *ScanDetailV2) GetRocksdbBlockCacheHitCount() uint64 {
	if x != nil {
		return x.RocksdbBlockCacheHitCount
	}
	return 0
}

func (x *ScanDetailV2) GetRocksdbBlockReadCount() uint64 {
	if x != nil {
		return x.RocksdbBlockReadCount
	}
	return 0
}

func (x *ScanDetailV2) GetRocksdbBlockReadByte() uint64 {
	if x != nil {
		return x.RocksdbBlockReadByte
	}
	return 0
}

func (x *ScanDetailV2) GetRocksdbBlockReadNanos() uint64 {
	if x != nil {
		return x.RocksdbBlockReadNanos
	}
	return 0
}

func (x *ScanDetailV2) GetGetSnapshotNanos() uint64 {
	if x != nil {
		return x.GetSnapshotNanos
	}
	return 0
}

func (x *ScanDetailV2) GetReadIndexProposeWaitNanos() uint64 {
	if x != nil {
		return x.ReadIndexProposeWaitNanos
	}
	return 0
}

func (x *ScanDetailV2) GetReadIndexConfirmWaitNanos() uint64 {
	if x != nil {
		return x.ReadIndexConfirmWaitNanos
	}
	return 0
}

func (x *ScanDetailV2) GetReadPoolScheduleWaitNanos() uint64 {
	if x != nil {
		return x.ReadPoolScheduleWaitNanos
	}
	return 0
}

type ExecDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Available when ctx.record_time_stat = true or meet slow query.
	TimeDetail *TimeDetail `protobuf:"bytes,1,opt,name=time_detail,json=timeDetail,proto3" json:"time_detail,omitempty"`
	// Available when ctx.record_scan_stat = true or meet slow query.
	ScanDetail    *ScanDetail `protobuf:"bytes,2,opt,name=scan_detail,json=scanDetail,proto3" json:"scan_detail,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecDetails) Reset() {
	*x = ExecDetails{}
	mi := &file_kvrpcpb_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecDetails) ProtoMessage() {}

func (x *ExecDetails) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecDetails.ProtoReflect.Descriptor instead.
func (*ExecDetails) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{96}
}

func (x *ExecDetails) GetTimeDetail() *TimeDetail {
	if x != nil {
		return x.TimeDetail
	}
	return nil
}

func (x *ExecDetails) GetScanDetail() *ScanDetail {
	if x != nil {
		return x.ScanDetail
	}
	return nil
}

type ExecDetailsV2 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Available when ctx.record_time_stat = true or meet slow query.
	// deprecated. Should use `time_detail_v2` instead.
	TimeDetail *TimeDetail `protobuf:"bytes,1,opt,name=time_detail,json=timeDetail,proto3" json:"time_detail,omitempty"`
	// Available when ctx.record_scan_stat = true or meet slow query.
	ScanDetailV2 *ScanDetailV2 `protobuf:"bytes,2,opt,name=scan_detail_v2,json=scanDetailV2,proto3" json:"scan_detail_v2,omitempty"`
	// Raftstore writing durations of the request. Only available for some write requests.
	WriteDetail *WriteDetail `protobuf:"bytes,3,opt,name=write_detail,json=writeDetail,proto3" json:"write_detail,omitempty"`
	// Available when ctx.record_time_stat = true or meet slow query.
	TimeDetailV2  *TimeDetailV2 `protobuf:"bytes,4,opt,name=time_detail_v2,json=timeDetailV2,proto3" json:"time_detail_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecDetailsV2) Reset() {
	*x = ExecDetailsV2{}
	mi := &file_kvrpcpb_proto_msgTypes[97]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecDetailsV2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecDetailsV2) ProtoMessage() {}

func (x *ExecDetailsV2) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[97]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecDetailsV2.ProtoReflect.Descriptor instead.
func (*ExecDetailsV2) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{97}
}

func (x *ExecDetailsV2) GetTimeDetail() *TimeDetail {
	if x != nil {
		return x.TimeDetail
	}
	return nil
}

func (x *ExecDetailsV2) GetScanDetailV2() *ScanDetailV2 {
	if x != nil {
		return x.ScanDetailV2
	}
	return nil
}

func (x *ExecDetailsV2) GetWriteDetail() *WriteDetail {
	if x != nil {
		return x.WriteDetail
	}
	return nil
}

func (x *ExecDetailsV2) GetTimeDetailV2() *TimeDetailV2 {
	if x != nil {
		return x.TimeDetailV2
	}
	return nil
}

type WriteDetail struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Wait duration in the store loop.
	StoreBatchWaitNanos uint64 `protobuf:"varint,1,opt,name=store_batch_wait_nanos,json=storeBatchWaitNanos,proto3" json:"store_batch_wait_nanos,omitempty"`
	// Wait duration before sending proposal to peers.
	ProposeSendWaitNanos uint64 `protobuf:"varint,2,opt,name=propose_send_wait_nanos,json=proposeSendWaitNanos,proto3" json:"propose_send_wait_nanos,omitempty"`
	// Total time spent on persisting the log.
	PersistLogNanos uint64 `protobuf:"varint,3,opt,name=persist_log_nanos,json=persistLogNanos,proto3" json:"persist_log_nanos,omitempty"`
	// Wait time until the Raft log write leader begins to write.
	RaftDbWriteLeaderWaitNanos uint64 `protobuf:"varint,4,opt,name=raft_db_write_leader_wait_nanos,json=raftDbWriteLeaderWaitNanos,proto3" json:"raft_db_write_leader_wait_nanos,omitempty"`
	// Time spent on synchronizing the Raft log to the disk.
	RaftDbSyncLogNanos uint64 `protobuf:"varint,5,opt,name=raft_db_sync_log_nanos,json=raftDbSyncLogNanos,proto3" json:"raft_db_sync_log_nanos,omitempty"`
	// Time spent on writing the Raft log to the Raft memtable.
	RaftDbWriteMemtableNanos uint64 `protobuf:"varint,6,opt,name=raft_db_write_memtable_nanos,json=raftDbWriteMemtableNanos,proto3" json:"raft_db_write_memtable_nanos,omitempty"`
	// Time waiting for peers to confirm the proposal (counting from the instant when the leader sends the proposal message).
	CommitLogNanos uint64 `protobuf:"varint,7,opt,name=commit_log_nanos,json=commitLogNanos,proto3" json:"commit_log_nanos,omitempty"`
	// Wait duration in the apply loop.
	ApplyBatchWaitNanos uint64 `protobuf:"varint,8,opt,name=apply_batch_wait_nanos,json=applyBatchWaitNanos,proto3" json:"apply_batch_wait_nanos,omitempty"`
	// Total time spend to applying the log.
	ApplyLogNanos uint64 `protobuf:"varint,9,opt,name=apply_log_nanos,json=applyLogNanos,proto3" json:"apply_log_nanos,omitempty"`
	// Wait time until the KV RocksDB lock is acquired.
	ApplyMutexLockNanos uint64 `protobuf:"varint,10,opt,name=apply_mutex_lock_nanos,json=applyMutexLockNanos,proto3" json:"apply_mutex_lock_nanos,omitempty"`
	// Wait time until becoming the KV RocksDB write leader.
	ApplyWriteLeaderWaitNanos uint64 `protobuf:"varint,11,opt,name=apply_write_leader_wait_nanos,json=applyWriteLeaderWaitNanos,proto3" json:"apply_write_leader_wait_nanos,omitempty"`
	// Time spent on writing the KV DB WAL to the disk.
	ApplyWriteWalNanos uint64 `protobuf:"varint,12,opt,name=apply_write_wal_nanos,json=applyWriteWalNanos,proto3" json:"apply_write_wal_nanos,omitempty"`
	// Time spent on writing to the memtable of the KV RocksDB.
	ApplyWriteMemtableNanos uint64 `protobuf:"varint,13,opt,name=apply_write_memtable_nanos,json=applyWriteMemtableNanos,proto3" json:"apply_write_memtable_nanos,omitempty"`
	// Time spent on waiting in the latch.
	LatchWaitNanos uint64 `protobuf:"varint,14,opt,name=latch_wait_nanos,json=latchWaitNanos,proto3" json:"latch_wait_nanos,omitempty"`
	// Processing time in the transaction layer.
	ProcessNanos uint64 `protobuf:"varint,15,opt,name=process_nanos,json=processNanos,proto3" json:"process_nanos,omitempty"`
	// Wait time because of the scheduler flow control or quota limiter throttling.
	ThrottleNanos uint64 `protobuf:"varint,16,opt,name=throttle_nanos,json=throttleNanos,proto3" json:"throttle_nanos,omitempty"`
	// Wait time in the waiter manager for pessimistic locking.
	PessimisticLockWaitNanos uint64 `protobuf:"varint,17,opt,name=pessimistic_lock_wait_nanos,json=pessimisticLockWaitNanos,proto3" json:"pessimistic_lock_wait_nanos,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *WriteDetail) Reset() {
	*x = WriteDetail{}
	mi := &file_kvrpcpb_proto_msgTypes[98]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteDetail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteDetail) ProtoMessage() {}

func (x *WriteDetail) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[98]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteDetail.ProtoReflect.Descriptor instead.
func (*WriteDetail) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{98}
}

func (x *WriteDetail) GetStoreBatchWaitNanos() uint64 {
	if x != nil {
		return x.StoreBatchWaitNanos
	}
	return 0
}

func (x *WriteDetail) GetProposeSendWaitNanos() uint64 {
	if x != nil {
		return x.ProposeSendWaitNanos
	}
	return 0
}

func (x *WriteDetail) GetPersistLogNanos() uint64 {
	if x != nil {
		return x.PersistLogNanos
	}
	return 0
}

func (x *WriteDetail) GetRaftDbWriteLeaderWaitNanos() uint64 {
	if x != nil {
		return x.RaftDbWriteLeaderWaitNanos
	}
	return 0
}

func (x *WriteDetail) GetRaftDbSyncLogNanos() uint64 {
	if x != nil {
		return x.RaftDbSyncLogNanos
	}
	return 0
}

func (x *WriteDetail) GetRaftDbWriteMemtableNanos() uint64 {
	if x != nil {
		return x.RaftDbWriteMemtableNanos
	}
	return 0
}

func (x *WriteDetail) GetCommitLogNanos() uint64 {
	if x != nil {
		return x.CommitLogNanos
	}
	return 0
}

func (x *WriteDetail) GetApplyBatchWaitNanos() uint64 {
	if x != nil {
		return x.ApplyBatchWaitNanos
	}
	return 0
}

func (x *WriteDetail) GetApplyLogNanos() uint64 {
	if x != nil {
		return x.ApplyLogNanos
	}
	return 0
}

func (x *WriteDetail) GetApplyMutexLockNanos() uint64 {
	if x != nil {
		return x.ApplyMutexLockNanos
	}
	return 0
}

func (x *WriteDetail) GetApplyWriteLeaderWaitNanos() uint64 {
	if x != nil {
		return x.ApplyWriteLeaderWaitNanos
	}
	return 0
}

func (x *WriteDetail) GetApplyWriteWalNanos() uint64 {
	if x != nil {
		return x.ApplyWriteWalNanos
	}
	return 0
}

func (x *WriteDetail) GetApplyWriteMemtableNanos() uint64 {
	if x != nil {
		return x.ApplyWriteMemtableNanos
	}
	return 0
}

func (x *WriteDetail) GetLatchWaitNanos() uint64 {
	if x != nil {
		return x.LatchWaitNanos
	}
	return 0
}

func (x *WriteDetail) GetProcessNanos() uint64 {
	if x != nil {
		return x.ProcessNanos
	}
	return 0
}

func (x *WriteDetail) GetThrottleNanos() uint64 {
	if x != nil {
		return x.ThrottleNanos
	}
	return 0
}

func (x *WriteDetail) GetPessimisticLockWaitNanos() uint64 {
	if x != nil {
		return x.PessimisticLockWaitNanos
	}
	return 0
}

type KvPair struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Error *KeyError              `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Key   []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// The commit timestamp of the key.
	// If it is zero, it means the commit timestamp is unknown.
	CommitTs      uint64 `protobuf:"varint,4,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KvPair) Reset() {
	*x = KvPair{}
	mi := &file_kvrpcpb_proto_msgTypes[99]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KvPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KvPair) ProtoMessage() {}

func (x *KvPair) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[99]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KvPair.ProtoReflect.Descriptor instead.
func (*KvPair) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{99}
}

func (x *KvPair) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *KvPair) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *KvPair) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *KvPair) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

type Mutation struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Op            Op                     `protobuf:"varint,1,opt,name=op,proto3,enum=kvrpcpb.Op" json:"op,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Assertion     Assertion              `protobuf:"varint,4,opt,name=assertion,proto3,enum=kvrpcpb.Assertion" json:"assertion,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Mutation) Reset() {
	*x = Mutation{}
	mi := &file_kvrpcpb_proto_msgTypes[100]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Mutation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Mutation) ProtoMessage() {}

func (x *Mutation) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[100]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Mutation.ProtoReflect.Descriptor instead.
func (*Mutation) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{100}
}

func (x *Mutation) GetOp() Op {
	if x != nil {
		return x.Op
	}
	return Op_Put
}

func (x *Mutation) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *Mutation) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Mutation) GetAssertion() Assertion {
	if x != nil {
		return x.Assertion
	}
	return Assertion_None
}

type MvccWrite struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Type                  Op                     `protobuf:"varint,1,opt,name=type,proto3,enum=kvrpcpb.Op" json:"type,omitempty"`
	StartTs               uint64                 `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs              uint64                 `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	ShortValue            []byte                 `protobuf:"bytes,4,opt,name=short_value,json=shortValue,proto3" json:"short_value,omitempty"`
	HasOverlappedRollback bool                   `protobuf:"varint,5,opt,name=has_overlapped_rollback,json=hasOverlappedRollback,proto3" json:"has_overlapped_rollback,omitempty"`
	HasGcFence            bool                   `protobuf:"varint,6,opt,name=has_gc_fence,json=hasGcFence,proto3" json:"has_gc_fence,omitempty"`
	GcFence               uint64                 `protobuf:"varint,7,opt,name=gc_fence,json=gcFence,proto3" json:"gc_fence,omitempty"`
	LastChangeTs          uint64                 `protobuf:"varint,8,opt,name=last_change_ts,json=lastChangeTs,proto3" json:"last_change_ts,omitempty"`
	VersionsToLastChange  uint64                 `protobuf:"varint,9,opt,name=versions_to_last_change,json=versionsToLastChange,proto3" json:"versions_to_last_change,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *MvccWrite) Reset() {
	*x = MvccWrite{}
	mi := &file_kvrpcpb_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccWrite) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccWrite) ProtoMessage() {}

func (x *MvccWrite) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccWrite.ProtoReflect.Descriptor instead.
func (*MvccWrite) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{101}
}

func (x *MvccWrite) GetType() Op {
	if x != nil {
		return x.Type
	}
	return Op_Put
}

func (x *MvccWrite) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *MvccWrite) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

func (x *MvccWrite) GetShortValue() []byte {
	if x != nil {
		return x.ShortValue
	}
	return nil
}

func (x *MvccWrite) GetHasOverlappedRollback() bool {
	if x != nil {
		return x.HasOverlappedRollback
	}
	return false
}

func (x *MvccWrite) GetHasGcFence() bool {
	if x != nil {
		return x.HasGcFence
	}
	return false
}

func (x *MvccWrite) GetGcFence() uint64 {
	if x != nil {
		return x.GcFence
	}
	return 0
}

func (x *MvccWrite) GetLastChangeTs() uint64 {
	if x != nil {
		return x.LastChangeTs
	}
	return 0
}

func (x *MvccWrite) GetVersionsToLastChange() uint64 {
	if x != nil {
		return x.VersionsToLastChange
	}
	return 0
}

type MvccValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StartTs       uint64                 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MvccValue) Reset() {
	*x = MvccValue{}
	mi := &file_kvrpcpb_proto_msgTypes[102]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccValue) ProtoMessage() {}

func (x *MvccValue) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[102]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccValue.ProtoReflect.Descriptor instead.
func (*MvccValue) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{102}
}

func (x *MvccValue) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *MvccValue) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

type MvccLock struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Type                 Op                     `protobuf:"varint,1,opt,name=type,proto3,enum=kvrpcpb.Op" json:"type,omitempty"`
	StartTs              uint64                 `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Primary              []byte                 `protobuf:"bytes,3,opt,name=primary,proto3" json:"primary,omitempty"`
	ShortValue           []byte                 `protobuf:"bytes,4,opt,name=short_value,json=shortValue,proto3" json:"short_value,omitempty"`
	Ttl                  uint64                 `protobuf:"varint,5,opt,name=ttl,proto3" json:"ttl,omitempty"`
	ForUpdateTs          uint64                 `protobuf:"varint,6,opt,name=for_update_ts,json=forUpdateTs,proto3" json:"for_update_ts,omitempty"`
	TxnSize              uint64                 `protobuf:"varint,7,opt,name=txn_size,json=txnSize,proto3" json:"txn_size,omitempty"`
	UseAsyncCommit       bool                   `protobuf:"varint,8,opt,name=use_async_commit,json=useAsyncCommit,proto3" json:"use_async_commit,omitempty"`
	Secondaries          [][]byte               `protobuf:"bytes,9,rep,name=secondaries,proto3" json:"secondaries,omitempty"`
	RollbackTs           []uint64               `protobuf:"varint,10,rep,packed,name=rollback_ts,json=rollbackTs,proto3" json:"rollback_ts,omitempty"`
	LastChangeTs         uint64                 `protobuf:"varint,11,opt,name=last_change_ts,json=lastChangeTs,proto3" json:"last_change_ts,omitempty"`
	VersionsToLastChange uint64                 `protobuf:"varint,12,opt,name=versions_to_last_change,json=versionsToLastChange,proto3" json:"versions_to_last_change,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *MvccLock) Reset() {
	*x = MvccLock{}
	mi := &file_kvrpcpb_proto_msgTypes[103]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccLock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccLock) ProtoMessage() {}

func (x *MvccLock) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[103]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccLock.ProtoReflect.Descriptor instead.
func (*MvccLock) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{103}
}

func (x *MvccLock) GetType() Op {
	if x != nil {
		return x.Type
	}
	return Op_Put
}

func (x *MvccLock) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *MvccLock) GetPrimary() []byte {
	if x != nil {
		return x.Primary
	}
	return nil
}

func (x *MvccLock) GetShortValue() []byte {
	if x != nil {
		return x.ShortValue
	}
	return nil
}

func (x *MvccLock) GetTtl() uint64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *MvccLock) GetForUpdateTs() uint64 {
	if x != nil {
		return x.ForUpdateTs
	}
	return 0
}

func (x *MvccLock) GetTxnSize() uint64 {
	if x != nil {
		return x.TxnSize
	}
	return 0
}

func (x *MvccLock) GetUseAsyncCommit() bool {
	if x != nil {
		return x.UseAsyncCommit
	}
	return false
}

func (x *MvccLock) GetSecondaries() [][]byte {
	if x != nil {
		return x.Secondaries
	}
	return nil
}

func (x *MvccLock) GetRollbackTs() []uint64 {
	if x != nil {
		return x.RollbackTs
	}
	return nil
}

func (x *MvccLock) GetLastChangeTs() uint64 {
	if x != nil {
		return x.LastChangeTs
	}
	return 0
}

func (x *MvccLock) GetVersionsToLastChange() uint64 {
	if x != nil {
		return x.VersionsToLastChange
	}
	return 0
}

type MvccInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Lock          *MvccLock              `protobuf:"bytes,1,opt,name=lock,proto3" json:"lock,omitempty"`
	Writes        []*MvccWrite           `protobuf:"bytes,2,rep,name=writes,proto3" json:"writes,omitempty"`
	Values        []*MvccValue           `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MvccInfo) Reset() {
	*x = MvccInfo{}
	mi := &file_kvrpcpb_proto_msgTypes[104]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MvccInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MvccInfo) ProtoMessage() {}

func (x *MvccInfo) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[104]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MvccInfo.ProtoReflect.Descriptor instead.
func (*MvccInfo) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{104}
}

func (x *MvccInfo) GetLock() *MvccLock {
	if x != nil {
		return x.Lock
	}
	return nil
}

func (x *MvccInfo) GetWrites() []*MvccWrite {
	if x != nil {
		return x.Writes
	}
	return nil
}

func (x *MvccInfo) GetValues() []*MvccValue {
	if x != nil {
		return x.Values
	}
	return nil
}

type TxnInfo struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Txn    uint64                 `protobuf:"varint,1,opt,name=txn,proto3" json:"txn,omitempty"`
	Status uint64                 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	// Reserved for file based transaction.
	IsTxnFile     bool `protobuf:"varint,100,opt,name=is_txn_file,json=isTxnFile,proto3" json:"is_txn_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxnInfo) Reset() {
	*x = TxnInfo{}
	mi := &file_kvrpcpb_proto_msgTypes[105]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxnInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxnInfo) ProtoMessage() {}

func (x *TxnInfo) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[105]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxnInfo.ProtoReflect.Descriptor instead.
func (*TxnInfo) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{105}
}

func (x *TxnInfo) GetTxn() uint64 {
	if x != nil {
		return x.Txn
	}
	return 0
}

func (x *TxnInfo) GetStatus() uint64 {
	if x != nil {
		return x.Status
	}
	return 0
}

func (x *TxnInfo) GetIsTxnFile() bool {
	if x != nil {
		return x.IsTxnFile
	}
	return false
}

type KeyRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StartKey      []byte                 `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey        []byte                 `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyRange) Reset() {
	*x = KeyRange{}
	mi := &file_kvrpcpb_proto_msgTypes[106]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyRange) ProtoMessage() {}

func (x *KeyRange) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[106]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyRange.ProtoReflect.Descriptor instead.
func (*KeyRange) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{106}
}

func (x *KeyRange) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *KeyRange) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

type LeaderInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionId      uint64                 `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	PeerId        uint64                 `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	Term          uint64                 `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	RegionEpoch   *metapb.RegionEpoch    `protobuf:"bytes,4,opt,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	ReadState     *ReadState             `protobuf:"bytes,5,opt,name=read_state,json=readState,proto3" json:"read_state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LeaderInfo) Reset() {
	*x = LeaderInfo{}
	mi := &file_kvrpcpb_proto_msgTypes[107]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LeaderInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeaderInfo) ProtoMessage() {}

func (x *LeaderInfo) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[107]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LeaderInfo.ProtoReflect.Descriptor instead.
func (*LeaderInfo) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{107}
}

func (x *LeaderInfo) GetRegionId() uint64 {
	if x != nil {
		return x.RegionId
	}
	return 0
}

func (x *LeaderInfo) GetPeerId() uint64 {
	if x != nil {
		return x.PeerId
	}
	return 0
}

func (x *LeaderInfo) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

func (x *LeaderInfo) GetRegionEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.RegionEpoch
	}
	return nil
}

func (x *LeaderInfo) GetReadState() *ReadState {
	if x != nil {
		return x.ReadState
	}
	return nil
}

type ReadState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AppliedIndex  uint64                 `protobuf:"varint,1,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	SafeTs        uint64                 `protobuf:"varint,2,opt,name=safe_ts,json=safeTs,proto3" json:"safe_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadState) Reset() {
	*x = ReadState{}
	mi := &file_kvrpcpb_proto_msgTypes[108]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadState) ProtoMessage() {}

func (x *ReadState) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[108]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadState.ProtoReflect.Descriptor instead.
func (*ReadState) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{108}
}

func (x *ReadState) GetAppliedIndex() uint64 {
	if x != nil {
		return x.AppliedIndex
	}
	return 0
}

func (x *ReadState) GetSafeTs() uint64 {
	if x != nil {
		return x.SafeTs
	}
	return 0
}

type CheckLeaderRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Regions       []*LeaderInfo          `protobuf:"bytes,1,rep,name=regions,proto3" json:"regions,omitempty"`
	Ts            uint64                 `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckLeaderRequest) Reset() {
	*x = CheckLeaderRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[109]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckLeaderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckLeaderRequest) ProtoMessage() {}

func (x *CheckLeaderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[109]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckLeaderRequest.ProtoReflect.Descriptor instead.
func (*CheckLeaderRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{109}
}

func (x *CheckLeaderRequest) GetRegions() []*LeaderInfo {
	if x != nil {
		return x.Regions
	}
	return nil
}

func (x *CheckLeaderRequest) GetTs() uint64 {
	if x != nil {
		return x.Ts
	}
	return 0
}

type CheckLeaderResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Regions       []uint64               `protobuf:"varint,1,rep,packed,name=regions,proto3" json:"regions,omitempty"`
	Ts            uint64                 `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckLeaderResponse) Reset() {
	*x = CheckLeaderResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[110]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckLeaderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckLeaderResponse) ProtoMessage() {}

func (x *CheckLeaderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[110]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckLeaderResponse.ProtoReflect.Descriptor instead.
func (*CheckLeaderResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{110}
}

func (x *CheckLeaderResponse) GetRegions() []uint64 {
	if x != nil {
		return x.Regions
	}
	return nil
}

func (x *CheckLeaderResponse) GetTs() uint64 {
	if x != nil {
		return x.Ts
	}
	return 0
}

type StoreSafeTSRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Get the minimal `safe_ts` from regions that overlap with the key range [`start_key`, `end_key`)
	// An empty key range means all regions in the store
	KeyRange      *KeyRange `protobuf:"bytes,1,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoreSafeTSRequest) Reset() {
	*x = StoreSafeTSRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[111]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoreSafeTSRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoreSafeTSRequest) ProtoMessage() {}

func (x *StoreSafeTSRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[111]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoreSafeTSRequest.ProtoReflect.Descriptor instead.
func (*StoreSafeTSRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{111}
}

func (x *StoreSafeTSRequest) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

type StoreSafeTSResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SafeTs        uint64                 `protobuf:"varint,1,opt,name=safe_ts,json=safeTs,proto3" json:"safe_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoreSafeTSResponse) Reset() {
	*x = StoreSafeTSResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[112]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoreSafeTSResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoreSafeTSResponse) ProtoMessage() {}

func (x *StoreSafeTSResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[112]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoreSafeTSResponse.ProtoReflect.Descriptor instead.
func (*StoreSafeTSResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{112}
}

func (x *StoreSafeTSResponse) GetSafeTs() uint64 {
	if x != nil {
		return x.SafeTs
	}
	return 0
}

type RawGetKeyTTLRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Cf            string                 `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawGetKeyTTLRequest) Reset() {
	*x = RawGetKeyTTLRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[113]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawGetKeyTTLRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawGetKeyTTLRequest) ProtoMessage() {}

func (x *RawGetKeyTTLRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[113]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawGetKeyTTLRequest.ProtoReflect.Descriptor instead.
func (*RawGetKeyTTLRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{113}
}

func (x *RawGetKeyTTLRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawGetKeyTTLRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *RawGetKeyTTLRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

type RawGetKeyTTLResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Ttl           uint64                 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	NotFound      bool                   `protobuf:"varint,4,opt,name=not_found,json=notFound,proto3" json:"not_found,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawGetKeyTTLResponse) Reset() {
	*x = RawGetKeyTTLResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[114]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawGetKeyTTLResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawGetKeyTTLResponse) ProtoMessage() {}

func (x *RawGetKeyTTLResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[114]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawGetKeyTTLResponse.ProtoReflect.Descriptor instead.
func (*RawGetKeyTTLResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{114}
}

func (x *RawGetKeyTTLResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawGetKeyTTLResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *RawGetKeyTTLResponse) GetTtl() uint64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *RawGetKeyTTLResponse) GetNotFound() bool {
	if x != nil {
		return x.NotFound
	}
	return false
}

type RawCASRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Context          *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Key              []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value            []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	PreviousNotExist bool                   `protobuf:"varint,4,opt,name=previous_not_exist,json=previousNotExist,proto3" json:"previous_not_exist,omitempty"`
	PreviousValue    []byte                 `protobuf:"bytes,5,opt,name=previous_value,json=previousValue,proto3" json:"previous_value,omitempty"`
	Cf               string                 `protobuf:"bytes,6,opt,name=cf,proto3" json:"cf,omitempty"`
	Ttl              uint64                 `protobuf:"varint,7,opt,name=ttl,proto3" json:"ttl,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RawCASRequest) Reset() {
	*x = RawCASRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[115]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawCASRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawCASRequest) ProtoMessage() {}

func (x *RawCASRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[115]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawCASRequest.ProtoReflect.Descriptor instead.
func (*RawCASRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{115}
}

func (x *RawCASRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawCASRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *RawCASRequest) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *RawCASRequest) GetPreviousNotExist() bool {
	if x != nil {
		return x.PreviousNotExist
	}
	return false
}

func (x *RawCASRequest) GetPreviousValue() []byte {
	if x != nil {
		return x.PreviousValue
	}
	return nil
}

func (x *RawCASRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *RawCASRequest) GetTtl() uint64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

type RawCASResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Succeed     bool                   `protobuf:"varint,3,opt,name=succeed,proto3" json:"succeed,omitempty"`
	// The previous value regardless of whether the comparison is succeed.
	PreviousNotExist bool   `protobuf:"varint,4,opt,name=previous_not_exist,json=previousNotExist,proto3" json:"previous_not_exist,omitempty"`
	PreviousValue    []byte `protobuf:"bytes,5,opt,name=previous_value,json=previousValue,proto3" json:"previous_value,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RawCASResponse) Reset() {
	*x = RawCASResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[116]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawCASResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawCASResponse) ProtoMessage() {}

func (x *RawCASResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[116]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawCASResponse.ProtoReflect.Descriptor instead.
func (*RawCASResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{116}
}

func (x *RawCASResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawCASResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *RawCASResponse) GetSucceed() bool {
	if x != nil {
		return x.Succeed
	}
	return false
}

func (x *RawCASResponse) GetPreviousNotExist() bool {
	if x != nil {
		return x.PreviousNotExist
	}
	return false
}

func (x *RawCASResponse) GetPreviousValue() []byte {
	if x != nil {
		return x.PreviousValue
	}
	return nil
}

type GetLockWaitInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLockWaitInfoRequest) Reset() {
	*x = GetLockWaitInfoRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[117]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLockWaitInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLockWaitInfoRequest) ProtoMessage() {}

func (x *GetLockWaitInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[117]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLockWaitInfoRequest.ProtoReflect.Descriptor instead.
func (*GetLockWaitInfoRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{117}
}

func (x *GetLockWaitInfoRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

type GetLockWaitInfoResponse struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	RegionError   *errorpb.Error           `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Entries       []*deadlock.WaitForEntry `protobuf:"bytes,3,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLockWaitInfoResponse) Reset() {
	*x = GetLockWaitInfoResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[118]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLockWaitInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLockWaitInfoResponse) ProtoMessage() {}

func (x *GetLockWaitInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[118]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLockWaitInfoResponse.ProtoReflect.Descriptor instead.
func (*GetLockWaitInfoResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{118}
}

func (x *GetLockWaitInfoResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *GetLockWaitInfoResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *GetLockWaitInfoResponse) GetEntries() []*deadlock.WaitForEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

type GetLockWaitHistoryRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLockWaitHistoryRequest) Reset() {
	*x = GetLockWaitHistoryRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[119]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLockWaitHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLockWaitHistoryRequest) ProtoMessage() {}

func (x *GetLockWaitHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[119]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLockWaitHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetLockWaitHistoryRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{119}
}

func (x *GetLockWaitHistoryRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

type GetLockWaitHistoryResponse struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	RegionError   *errorpb.Error           `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Entries       []*deadlock.WaitForEntry `protobuf:"bytes,3,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLockWaitHistoryResponse) Reset() {
	*x = GetLockWaitHistoryResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[120]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLockWaitHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLockWaitHistoryResponse) ProtoMessage() {}

func (x *GetLockWaitHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[120]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLockWaitHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetLockWaitHistoryResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{120}
}

func (x *GetLockWaitHistoryResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *GetLockWaitHistoryResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *GetLockWaitHistoryResponse) GetEntries() []*deadlock.WaitForEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

type RawCoprocessorRequest struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Context  *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	CoprName string                 `protobuf:"bytes,2,opt,name=copr_name,json=coprName,proto3" json:"copr_name,omitempty"`
	// Coprorcessor version constraint following SEMVER definition.
	CoprVersionReq string      `protobuf:"bytes,3,opt,name=copr_version_req,json=coprVersionReq,proto3" json:"copr_version_req,omitempty"`
	Ranges         []*KeyRange `protobuf:"bytes,4,rep,name=ranges,proto3" json:"ranges,omitempty"`
	Data           []byte      `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RawCoprocessorRequest) Reset() {
	*x = RawCoprocessorRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[121]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawCoprocessorRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawCoprocessorRequest) ProtoMessage() {}

func (x *RawCoprocessorRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[121]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawCoprocessorRequest.ProtoReflect.Descriptor instead.
func (*RawCoprocessorRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{121}
}

func (x *RawCoprocessorRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawCoprocessorRequest) GetCoprName() string {
	if x != nil {
		return x.CoprName
	}
	return ""
}

func (x *RawCoprocessorRequest) GetCoprVersionReq() string {
	if x != nil {
		return x.CoprVersionReq
	}
	return ""
}

func (x *RawCoprocessorRequest) GetRanges() []*KeyRange {
	if x != nil {
		return x.Ranges
	}
	return nil
}

func (x *RawCoprocessorRequest) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type RawCoprocessorResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	// Error message for cases like if no coprocessor with a matching name is found
	// or on a version mismatch between plugin_api and the coprocessor.
	Error         string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Data          []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawCoprocessorResponse) Reset() {
	*x = RawCoprocessorResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[122]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawCoprocessorResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawCoprocessorResponse) ProtoMessage() {}

func (x *RawCoprocessorResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[122]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawCoprocessorResponse.ProtoReflect.Descriptor instead.
func (*RawCoprocessorResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{122}
}

func (x *RawCoprocessorResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawCoprocessorResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *RawCoprocessorResponse) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type RawChecksumRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Algorithm     ChecksumAlgorithm      `protobuf:"varint,2,opt,name=algorithm,proto3,enum=kvrpcpb.ChecksumAlgorithm" json:"algorithm,omitempty"`
	Ranges        []*KeyRange            `protobuf:"bytes,3,rep,name=ranges,proto3" json:"ranges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawChecksumRequest) Reset() {
	*x = RawChecksumRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[123]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawChecksumRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawChecksumRequest) ProtoMessage() {}

func (x *RawChecksumRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[123]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawChecksumRequest.ProtoReflect.Descriptor instead.
func (*RawChecksumRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{123}
}

func (x *RawChecksumRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RawChecksumRequest) GetAlgorithm() ChecksumAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return ChecksumAlgorithm_Crc64_Xor
}

func (x *RawChecksumRequest) GetRanges() []*KeyRange {
	if x != nil {
		return x.Ranges
	}
	return nil
}

type RawChecksumResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Checksum      uint64                 `protobuf:"varint,3,opt,name=checksum,proto3" json:"checksum,omitempty"`
	TotalKvs      uint64                 `protobuf:"varint,4,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes    uint64                 `protobuf:"varint,5,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawChecksumResponse) Reset() {
	*x = RawChecksumResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[124]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawChecksumResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawChecksumResponse) ProtoMessage() {}

func (x *RawChecksumResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[124]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawChecksumResponse.ProtoReflect.Descriptor instead.
func (*RawChecksumResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{124}
}

func (x *RawChecksumResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *RawChecksumResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *RawChecksumResponse) GetChecksum() uint64 {
	if x != nil {
		return x.Checksum
	}
	return 0
}

func (x *RawChecksumResponse) GetTotalKvs() uint64 {
	if x != nil {
		return x.TotalKvs
	}
	return 0
}

func (x *RawChecksumResponse) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

type CompactError struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Error:
	//
	//	*CompactError_ErrInvalidStartKey
	//	*CompactError_ErrPhysicalTableNotExist
	//	*CompactError_ErrCompactInProgress
	//	*CompactError_ErrTooManyPendingTasks
	Error         isCompactError_Error `protobuf_oneof:"error"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactError) Reset() {
	*x = CompactError{}
	mi := &file_kvrpcpb_proto_msgTypes[125]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactError) ProtoMessage() {}

func (x *CompactError) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[125]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactError.ProtoReflect.Descriptor instead.
func (*CompactError) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{125}
}

func (x *CompactError) GetError() isCompactError_Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CompactError) GetErrInvalidStartKey() *CompactErrorInvalidStartKey {
	if x != nil {
		if x, ok := x.Error.(*CompactError_ErrInvalidStartKey); ok {
			return x.ErrInvalidStartKey
		}
	}
	return nil
}

func (x *CompactError) GetErrPhysicalTableNotExist() *CompactErrorPhysicalTableNotExist {
	if x != nil {
		if x, ok := x.Error.(*CompactError_ErrPhysicalTableNotExist); ok {
			return x.ErrPhysicalTableNotExist
		}
	}
	return nil
}

func (x *CompactError) GetErrCompactInProgress() *CompactErrorCompactInProgress {
	if x != nil {
		if x, ok := x.Error.(*CompactError_ErrCompactInProgress); ok {
			return x.ErrCompactInProgress
		}
	}
	return nil
}

func (x *CompactError) GetErrTooManyPendingTasks() *CompactErrorTooManyPendingTasks {
	if x != nil {
		if x, ok := x.Error.(*CompactError_ErrTooManyPendingTasks); ok {
			return x.ErrTooManyPendingTasks
		}
	}
	return nil
}

type isCompactError_Error interface {
	isCompactError_Error()
}

type CompactError_ErrInvalidStartKey struct {
	ErrInvalidStartKey *CompactErrorInvalidStartKey `protobuf:"bytes,1,opt,name=err_invalid_start_key,json=errInvalidStartKey,proto3,oneof"`
}

type CompactError_ErrPhysicalTableNotExist struct {
	ErrPhysicalTableNotExist *CompactErrorPhysicalTableNotExist `protobuf:"bytes,2,opt,name=err_physical_table_not_exist,json=errPhysicalTableNotExist,proto3,oneof"`
}

type CompactError_ErrCompactInProgress struct {
	ErrCompactInProgress *CompactErrorCompactInProgress `protobuf:"bytes,3,opt,name=err_compact_in_progress,json=errCompactInProgress,proto3,oneof"`
}

type CompactError_ErrTooManyPendingTasks struct {
	ErrTooManyPendingTasks *CompactErrorTooManyPendingTasks `protobuf:"bytes,4,opt,name=err_too_many_pending_tasks,json=errTooManyPendingTasks,proto3,oneof"`
}

func (*CompactError_ErrInvalidStartKey) isCompactError_Error() {}

func (*CompactError_ErrPhysicalTableNotExist) isCompactError_Error() {}

func (*CompactError_ErrCompactInProgress) isCompactError_Error() {}

func (*CompactError_ErrTooManyPendingTasks) isCompactError_Error() {}

type CompactErrorInvalidStartKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactErrorInvalidStartKey) Reset() {
	*x = CompactErrorInvalidStartKey{}
	mi := &file_kvrpcpb_proto_msgTypes[126]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactErrorInvalidStartKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactErrorInvalidStartKey) ProtoMessage() {}

func (x *CompactErrorInvalidStartKey) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[126]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactErrorInvalidStartKey.ProtoReflect.Descriptor instead.
func (*CompactErrorInvalidStartKey) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{126}
}

type CompactErrorPhysicalTableNotExist struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactErrorPhysicalTableNotExist) Reset() {
	*x = CompactErrorPhysicalTableNotExist{}
	mi := &file_kvrpcpb_proto_msgTypes[127]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactErrorPhysicalTableNotExist) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactErrorPhysicalTableNotExist) ProtoMessage() {}

func (x *CompactErrorPhysicalTableNotExist) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[127]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactErrorPhysicalTableNotExist.ProtoReflect.Descriptor instead.
func (*CompactErrorPhysicalTableNotExist) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{127}
}

type CompactErrorCompactInProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactErrorCompactInProgress) Reset() {
	*x = CompactErrorCompactInProgress{}
	mi := &file_kvrpcpb_proto_msgTypes[128]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactErrorCompactInProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactErrorCompactInProgress) ProtoMessage() {}

func (x *CompactErrorCompactInProgress) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[128]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactErrorCompactInProgress.ProtoReflect.Descriptor instead.
func (*CompactErrorCompactInProgress) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{128}
}

type CompactErrorTooManyPendingTasks struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactErrorTooManyPendingTasks) Reset() {
	*x = CompactErrorTooManyPendingTasks{}
	mi := &file_kvrpcpb_proto_msgTypes[129]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactErrorTooManyPendingTasks) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactErrorTooManyPendingTasks) ProtoMessage() {}

func (x *CompactErrorTooManyPendingTasks) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[129]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactErrorTooManyPendingTasks.ProtoReflect.Descriptor instead.
func (*CompactErrorTooManyPendingTasks) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{129}
}

type CompactRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If specified, the compaction will start from this start key.
	// If unspecified, the compaction will start from beginning.
	// NOTE 1: The start key should be never manually constructed. You should always use a key
	// returned in CompactResponse.
	// NOTE 2: the compaction range will be always restricted by physical_table_id.
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// The physical table that will be compacted.
	//
	// TODO: this is information that TiKV doesn't need to know.
	// See https://github.com/pingcap/kvproto/issues/912
	PhysicalTableId int64 `protobuf:"varint,2,opt,name=physical_table_id,json=physicalTableId,proto3" json:"physical_table_id,omitempty"`
	// The logical table id of the compaction. When receiving parallel requests with the same
	// logical table id, err_compact_in_progress will be returned.
	//
	// TODO: this is information that TiKV doesn't need to know.
	// See https://github.com/pingcap/kvproto/issues/912
	LogicalTableId int64 `protobuf:"varint,3,opt,name=logical_table_id,json=logicalTableId,proto3" json:"logical_table_id,omitempty"`
	// API version of the request
	ApiVersion APIVersion `protobuf:"varint,7,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// Keyspace of the table located in.
	KeyspaceId    uint32 `protobuf:"varint,8,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactRequest) Reset() {
	*x = CompactRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[130]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactRequest) ProtoMessage() {}

func (x *CompactRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[130]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactRequest.ProtoReflect.Descriptor instead.
func (*CompactRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{130}
}

func (x *CompactRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *CompactRequest) GetPhysicalTableId() int64 {
	if x != nil {
		return x.PhysicalTableId
	}
	return 0
}

func (x *CompactRequest) GetLogicalTableId() int64 {
	if x != nil {
		return x.LogicalTableId
	}
	return 0
}

func (x *CompactRequest) GetApiVersion() APIVersion {
	if x != nil {
		return x.ApiVersion
	}
	return APIVersion_V1
}

func (x *CompactRequest) GetKeyspaceId() uint32 {
	if x != nil {
		return x.KeyspaceId
	}
	return 0
}

type CompactResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Error *CompactError          `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// The compaction is done incrementally. If there are more data to compact, this field
	// will be set. The client can request to compact more data according to the `compacted_end_key`.
	HasRemaining      bool   `protobuf:"varint,2,opt,name=has_remaining,json=hasRemaining,proto3" json:"has_remaining,omitempty"`
	CompactedStartKey []byte `protobuf:"bytes,3,opt,name=compacted_start_key,json=compactedStartKey,proto3" json:"compacted_start_key,omitempty"`
	CompactedEndKey   []byte `protobuf:"bytes,4,opt,name=compacted_end_key,json=compactedEndKey,proto3" json:"compacted_end_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *CompactResponse) Reset() {
	*x = CompactResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[131]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactResponse) ProtoMessage() {}

func (x *CompactResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[131]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactResponse.ProtoReflect.Descriptor instead.
func (*CompactResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{131}
}

func (x *CompactResponse) GetError() *CompactError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CompactResponse) GetHasRemaining() bool {
	if x != nil {
		return x.HasRemaining
	}
	return false
}

func (x *CompactResponse) GetCompactedStartKey() []byte {
	if x != nil {
		return x.CompactedStartKey
	}
	return nil
}

func (x *CompactResponse) GetCompactedEndKey() []byte {
	if x != nil {
		return x.CompactedEndKey
	}
	return nil
}

type TiFlashSystemTableRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Sql           string                 `protobuf:"bytes,1,opt,name=sql,proto3" json:"sql,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TiFlashSystemTableRequest) Reset() {
	*x = TiFlashSystemTableRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[132]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TiFlashSystemTableRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TiFlashSystemTableRequest) ProtoMessage() {}

func (x *TiFlashSystemTableRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[132]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TiFlashSystemTableRequest.ProtoReflect.Descriptor instead.
func (*TiFlashSystemTableRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{132}
}

func (x *TiFlashSystemTableRequest) GetSql() string {
	if x != nil {
		return x.Sql
	}
	return ""
}

type TiFlashSystemTableResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TiFlashSystemTableResponse) Reset() {
	*x = TiFlashSystemTableResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[133]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TiFlashSystemTableResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TiFlashSystemTableResponse) ProtoMessage() {}

func (x *TiFlashSystemTableResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[133]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TiFlashSystemTableResponse.ProtoReflect.Descriptor instead.
func (*TiFlashSystemTableResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{133}
}

// Flush is introduced from the pipelined DML protocol.
// A Flush request writes some keys and values to TiKV, storing in LOCK and DEFAULT CF, just like a Prewrite request.
type FlushRequest struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Context     *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Mutations   []*Mutation            `protobuf:"bytes,2,rep,name=mutations,proto3" json:"mutations,omitempty"`
	PrimaryKey  []byte                 `protobuf:"bytes,3,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	StartTs     uint64                 `protobuf:"varint,4,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	MinCommitTs uint64                 `protobuf:"varint,5,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// generation of the flush request. It is a monotonically increasing number in each transaction.
	Generation     uint64         `protobuf:"varint,6,opt,name=generation,proto3" json:"generation,omitempty"`
	LockTtl        uint64         `protobuf:"varint,7,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	AssertionLevel AssertionLevel `protobuf:"varint,8,opt,name=assertion_level,json=assertionLevel,proto3,enum=kvrpcpb.AssertionLevel" json:"assertion_level,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FlushRequest) Reset() {
	*x = FlushRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[134]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlushRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlushRequest) ProtoMessage() {}

func (x *FlushRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[134]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlushRequest.ProtoReflect.Descriptor instead.
func (*FlushRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{134}
}

func (x *FlushRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *FlushRequest) GetMutations() []*Mutation {
	if x != nil {
		return x.Mutations
	}
	return nil
}

func (x *FlushRequest) GetPrimaryKey() []byte {
	if x != nil {
		return x.PrimaryKey
	}
	return nil
}

func (x *FlushRequest) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *FlushRequest) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

func (x *FlushRequest) GetGeneration() uint64 {
	if x != nil {
		return x.Generation
	}
	return 0
}

func (x *FlushRequest) GetLockTtl() uint64 {
	if x != nil {
		return x.LockTtl
	}
	return 0
}

func (x *FlushRequest) GetAssertionLevel() AssertionLevel {
	if x != nil {
		return x.AssertionLevel
	}
	return AssertionLevel_Off
}

type FlushResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionError   *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Errors        []*KeyError            `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`
	ExecDetailsV2 *ExecDetailsV2         `protobuf:"bytes,3,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlushResponse) Reset() {
	*x = FlushResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[135]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlushResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlushResponse) ProtoMessage() {}

func (x *FlushResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[135]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlushResponse.ProtoReflect.Descriptor instead.
func (*FlushResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{135}
}

func (x *FlushResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *FlushResponse) GetErrors() []*KeyError {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *FlushResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// BufferBatchGet is introduced from the pipelined DML protocol.
// It is similar to a BatchGet request, except that it can only read the data that has been flushed by itself.
type BufferBatchGetRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Keys          [][]byte               `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	Version       uint64                 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BufferBatchGetRequest) Reset() {
	*x = BufferBatchGetRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[136]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BufferBatchGetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BufferBatchGetRequest) ProtoMessage() {}

func (x *BufferBatchGetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[136]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BufferBatchGetRequest.ProtoReflect.Descriptor instead.
func (*BufferBatchGetRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{136}
}

func (x *BufferBatchGetRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *BufferBatchGetRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *BufferBatchGetRequest) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

type BufferBatchGetResponse struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionError *errorpb.Error         `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	Error       *KeyError              `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Pairs       []*KvPair              `protobuf:"bytes,3,rep,name=pairs,proto3" json:"pairs,omitempty"`
	// Time and scan details when processing the request.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2,proto3" json:"exec_details_v2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BufferBatchGetResponse) Reset() {
	*x = BufferBatchGetResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[137]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BufferBatchGetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BufferBatchGetResponse) ProtoMessage() {}

func (x *BufferBatchGetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[137]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BufferBatchGetResponse.ProtoReflect.Descriptor instead.
func (*BufferBatchGetResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{137}
}

func (x *BufferBatchGetResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *BufferBatchGetResponse) GetError() *KeyError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *BufferBatchGetResponse) GetPairs() []*KvPair {
	if x != nil {
		return x.Pairs
	}
	return nil
}

func (x *BufferBatchGetResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if x != nil {
		return x.ExecDetailsV2
	}
	return nil
}

// Actively request TiKV to report health feedback information. TiKV won't omit the health feedback information when sending the
// `BatchCommandsResponse` that contains this response.
// The health feedback information won't be replied in the response, but will be attached to `BatchCommandsResponse.health_feedback` field as usual.
// Only works when batch RPC is enabled.
type GetHealthFeedbackRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetHealthFeedbackRequest) Reset() {
	*x = GetHealthFeedbackRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[138]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetHealthFeedbackRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetHealthFeedbackRequest) ProtoMessage() {}

func (x *GetHealthFeedbackRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[138]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetHealthFeedbackRequest.ProtoReflect.Descriptor instead.
func (*GetHealthFeedbackRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{138}
}

func (x *GetHealthFeedbackRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

type GetHealthFeedbackResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The error field is added for keeping consistent. This request won't meet any region error as it's store level rather than region level.
	RegionError    *errorpb.Error  `protobuf:"bytes,1,opt,name=region_error,json=regionError,proto3" json:"region_error,omitempty"`
	HealthFeedback *HealthFeedback `protobuf:"bytes,2,opt,name=health_feedback,json=healthFeedback,proto3" json:"health_feedback,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GetHealthFeedbackResponse) Reset() {
	*x = GetHealthFeedbackResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[139]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetHealthFeedbackResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetHealthFeedbackResponse) ProtoMessage() {}

func (x *GetHealthFeedbackResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[139]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetHealthFeedbackResponse.ProtoReflect.Descriptor instead.
func (*GetHealthFeedbackResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{139}
}

func (x *GetHealthFeedbackResponse) GetRegionError() *errorpb.Error {
	if x != nil {
		return x.RegionError
	}
	return nil
}

func (x *GetHealthFeedbackResponse) GetHealthFeedback() *HealthFeedback {
	if x != nil {
		return x.HealthFeedback
	}
	return nil
}

type HealthFeedback struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	StoreId uint64                 `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	// The sequence number of the feedback message.
	// It's defined as an incrementing integer, starting from the unix timestamp (milliseconds) at
	// the time that the TiKV node is started.
	// This can be useful for filtering out out-of-order feedback messages.
	// Note that considering the possibility of system clock changing, this field doesn't guarantee
	// uniqueness and monotonic if the TiKV node is restarted.
	FeedbackSeqNo uint64 `protobuf:"varint,2,opt,name=feedback_seq_no,json=feedbackSeqNo,proto3" json:"feedback_seq_no,omitempty"`
	// The slow_score calculated in raftstore module. Due to some limitations of slow score, this would
	// be replaced by `SlowTrend` in the future.
	SlowScore     int32 `protobuf:"varint,3,opt,name=slow_score,json=slowScore,proto3" json:"slow_score,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthFeedback) Reset() {
	*x = HealthFeedback{}
	mi := &file_kvrpcpb_proto_msgTypes[140]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthFeedback) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthFeedback) ProtoMessage() {}

func (x *HealthFeedback) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[140]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthFeedback.ProtoReflect.Descriptor instead.
func (*HealthFeedback) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{140}
}

func (x *HealthFeedback) GetStoreId() uint64 {
	if x != nil {
		return x.StoreId
	}
	return 0
}

func (x *HealthFeedback) GetFeedbackSeqNo() uint64 {
	if x != nil {
		return x.FeedbackSeqNo
	}
	return 0
}

func (x *HealthFeedback) GetSlowScore() int32 {
	if x != nil {
		return x.SlowScore
	}
	return 0
}

type BroadcastTxnStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Context       *Context               `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	TxnStatus     []*TxnStatus           `protobuf:"bytes,2,rep,name=txn_status,json=txnStatus,proto3" json:"txn_status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BroadcastTxnStatusRequest) Reset() {
	*x = BroadcastTxnStatusRequest{}
	mi := &file_kvrpcpb_proto_msgTypes[141]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BroadcastTxnStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BroadcastTxnStatusRequest) ProtoMessage() {}

func (x *BroadcastTxnStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[141]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BroadcastTxnStatusRequest.ProtoReflect.Descriptor instead.
func (*BroadcastTxnStatusRequest) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{141}
}

func (x *BroadcastTxnStatusRequest) GetContext() *Context {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *BroadcastTxnStatusRequest) GetTxnStatus() []*TxnStatus {
	if x != nil {
		return x.TxnStatus
	}
	return nil
}

type TxnStatus struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	StartTs uint64                 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// a non-zero min_commit_ts indicates the transaction is ongoing
	MinCommitTs uint64 `protobuf:"varint,2,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// a non-zero commit_ts indicates the transaction is committed
	CommitTs   uint64 `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	RolledBack bool   `protobuf:"varint,4,opt,name=rolled_back,json=rolledBack,proto3" json:"rolled_back,omitempty"`
	// The txn has unlocked all keys, implying that it can be removed from txn_status_cache.
	IsCompleted   bool `protobuf:"varint,5,opt,name=is_completed,json=isCompleted,proto3" json:"is_completed,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxnStatus) Reset() {
	*x = TxnStatus{}
	mi := &file_kvrpcpb_proto_msgTypes[142]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxnStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxnStatus) ProtoMessage() {}

func (x *TxnStatus) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[142]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxnStatus.ProtoReflect.Descriptor instead.
func (*TxnStatus) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{142}
}

func (x *TxnStatus) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *TxnStatus) GetMinCommitTs() uint64 {
	if x != nil {
		return x.MinCommitTs
	}
	return 0
}

func (x *TxnStatus) GetCommitTs() uint64 {
	if x != nil {
		return x.CommitTs
	}
	return 0
}

func (x *TxnStatus) GetRolledBack() bool {
	if x != nil {
		return x.RolledBack
	}
	return false
}

func (x *TxnStatus) GetIsCompleted() bool {
	if x != nil {
		return x.IsCompleted
	}
	return false
}

type BroadcastTxnStatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BroadcastTxnStatusResponse) Reset() {
	*x = BroadcastTxnStatusResponse{}
	mi := &file_kvrpcpb_proto_msgTypes[143]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BroadcastTxnStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BroadcastTxnStatusResponse) ProtoMessage() {}

func (x *BroadcastTxnStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[143]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BroadcastTxnStatusResponse.ProtoReflect.Descriptor instead.
func (*BroadcastTxnStatusResponse) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{143}
}

// for_update_ts constriants that should be checked when prewriting a pessimistic transaction.
type PrewriteRequest_ForUpdateTSConstraint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The index of key in the prewrite request that should be checked.
	Index uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The expected for_update_ts of the pessimistic lock of the key.
	ExpectedForUpdateTs uint64 `protobuf:"varint,2,opt,name=expected_for_update_ts,json=expectedForUpdateTs,proto3" json:"expected_for_update_ts,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *PrewriteRequest_ForUpdateTSConstraint) Reset() {
	*x = PrewriteRequest_ForUpdateTSConstraint{}
	mi := &file_kvrpcpb_proto_msgTypes[144]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrewriteRequest_ForUpdateTSConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrewriteRequest_ForUpdateTSConstraint) ProtoMessage() {}

func (x *PrewriteRequest_ForUpdateTSConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_kvrpcpb_proto_msgTypes[144]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrewriteRequest_ForUpdateTSConstraint.ProtoReflect.Descriptor instead.
func (*PrewriteRequest_ForUpdateTSConstraint) Descriptor() ([]byte, []int) {
	return file_kvrpcpb_proto_rawDescGZIP(), []int{4, 0}
}

func (x *PrewriteRequest_ForUpdateTSConstraint) GetIndex() uint32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *PrewriteRequest_ForUpdateTSConstraint) GetExpectedForUpdateTs() uint64 {
	if x != nil {
		return x.ExpectedForUpdateTs
	}
	return 0
}

var File_kvrpcpb_proto protoreflect.FileDescriptor

const file_kvrpcpb_proto_rawDesc = "" +
	"\n" +
	"\rkvrpcpb.proto\x12\akvrpcpb\x1a\fmetapb.proto\x1a\rerrorpb.proto\x1a\x0edeadlock.proto\x1a\rtracepb.proto\x1a\x16resource_manager.proto\x1a\x0frustproto.proto\"\x8a\x01\n" +
	"\n" +
	"GetRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x18\n" +
	"\aversion\x18\x03 \x01(\x04R\aversion\x12$\n" +
	"\x0eneed_commit_ts\x18\x04 \x01(\bR\fneedCommitTs\"\xff\x01\n" +
	"\vGetResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\x12\x1b\n" +
	"\tnot_found\x18\x04 \x01(\bR\bnotFound\x12>\n" +
	"\x0fexec_details_v2\x18\x06 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\x12\x1b\n" +
	"\tcommit_ts\x18\a \x01(\x04R\bcommitTsJ\x04\b\x05\x10\x06\"\xf5\x01\n" +
	"\vScanRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x14\n" +
	"\x05limit\x18\x03 \x01(\rR\x05limit\x12\x18\n" +
	"\aversion\x18\x04 \x01(\x04R\aversion\x12\x19\n" +
	"\bkey_only\x18\x05 \x01(\bR\akeyOnly\x12\x18\n" +
	"\areverse\x18\x06 \x01(\bR\areverse\x12\x17\n" +
	"\aend_key\x18\a \x01(\fR\x06endKey\x12\x1f\n" +
	"\vsample_step\x18\b \x01(\rR\n" +
	"sampleStep\"\x91\x01\n" +
	"\fScanResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12%\n" +
	"\x05pairs\x18\x02 \x03(\v2\x0f.kvrpcpb.KvPairR\x05pairs\x12'\n" +
	"\x05error\x18\x03 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\"\xf0\a\n" +
	"\x0fPrewriteRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12/\n" +
	"\tmutations\x18\x02 \x03(\v2\x11.kvrpcpb.MutationR\tmutations\x12!\n" +
	"\fprimary_lock\x18\x03 \x01(\fR\vprimaryLock\x12#\n" +
	"\rstart_version\x18\x04 \x01(\x04R\fstartVersion\x12\x19\n" +
	"\block_ttl\x18\x05 \x01(\x04R\alockTtl\x122\n" +
	"\x15skip_constraint_check\x18\x06 \x01(\bR\x13skipConstraintCheck\x12[\n" +
	"\x13pessimistic_actions\x18\a \x03(\x0e2*.kvrpcpb.PrewriteRequest.PessimisticActionR\x12pessimisticActions\x12\x19\n" +
	"\btxn_size\x18\b \x01(\x04R\atxnSize\x12\"\n" +
	"\rfor_update_ts\x18\t \x01(\x04R\vforUpdateTs\x12\"\n" +
	"\rmin_commit_ts\x18\n" +
	" \x01(\x04R\vminCommitTs\x12(\n" +
	"\x10use_async_commit\x18\v \x01(\bR\x0euseAsyncCommit\x12 \n" +
	"\vsecondaries\x18\f \x03(\fR\vsecondaries\x12\x1c\n" +
	"\n" +
	"try_one_pc\x18\r \x01(\bR\btryOnePc\x12\"\n" +
	"\rmax_commit_ts\x18\x0e \x01(\x04R\vmaxCommitTs\x12@\n" +
	"\x0fassertion_level\x18\x0f \x01(\x0e2\x17.kvrpcpb.AssertionLevelR\x0eassertionLevel\x12i\n" +
	"\x19for_update_ts_constraints\x18\x10 \x03(\v2..kvrpcpb.PrewriteRequest.ForUpdateTSConstraintR\x16forUpdateTsConstraints\x12&\n" +
	"\x0ftxn_file_chunks\x18d \x03(\x04R\rtxnFileChunks\x1ab\n" +
	"\x15ForUpdateTSConstraint\x12\x14\n" +
	"\x05index\x18\x01 \x01(\rR\x05index\x123\n" +
	"\x16expected_for_update_ts\x18\x02 \x01(\x04R\x13expectedForUpdateTs\"b\n" +
	"\x11PessimisticAction\x12\x1a\n" +
	"\x16SKIP_PESSIMISTIC_CHECK\x10\x00\x12\x18\n" +
	"\x14DO_PESSIMISTIC_CHECK\x10\x01\x12\x17\n" +
	"\x13DO_CONSTRAINT_CHECK\x10\x02\"\xfd\x01\n" +
	"\x10PrewriteResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12)\n" +
	"\x06errors\x18\x02 \x03(\v2\x11.kvrpcpb.KeyErrorR\x06errors\x12\"\n" +
	"\rmin_commit_ts\x18\x03 \x01(\x04R\vminCommitTs\x12'\n" +
	"\x10one_pc_commit_ts\x18\x04 \x01(\x04R\ronePcCommitTs\x12>\n" +
	"\x0fexec_details_v2\x18\x05 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"\xc4\x04\n" +
	"\x16PessimisticLockRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12/\n" +
	"\tmutations\x18\x02 \x03(\v2\x11.kvrpcpb.MutationR\tmutations\x12!\n" +
	"\fprimary_lock\x18\x03 \x01(\fR\vprimaryLock\x12#\n" +
	"\rstart_version\x18\x04 \x01(\x04R\fstartVersion\x12\x19\n" +
	"\block_ttl\x18\x05 \x01(\x04R\alockTtl\x12\"\n" +
	"\rfor_update_ts\x18\x06 \x01(\x04R\vforUpdateTs\x12\"\n" +
	"\ris_first_lock\x18\a \x01(\bR\visFirstLock\x12!\n" +
	"\fwait_timeout\x18\b \x01(\x03R\vwaitTimeout\x12\x18\n" +
	"\x05force\x18\t \x01(\bB\x02\x18\x01R\x05force\x12#\n" +
	"\rreturn_values\x18\n" +
	" \x01(\bR\freturnValues\x12\"\n" +
	"\rmin_commit_ts\x18\v \x01(\x04R\vminCommitTs\x12'\n" +
	"\x0fcheck_existence\x18\f \x01(\bR\x0echeckExistence\x12-\n" +
	"\x13lock_only_if_exists\x18\r \x01(\bR\x10lockOnlyIfExists\x12D\n" +
	"\fwake_up_mode\x18\x0e \x01(\x0e2\".kvrpcpb.PessimisticLockWakeUpModeR\n" +
	"wakeUpMode\"\xf0\x01\n" +
	"\x18PessimisticLockKeyResult\x129\n" +
	"\x04type\x18\x01 \x01(\x0e2%.kvrpcpb.PessimisticLockKeyResultTypeR\x04type\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\x12\x1c\n" +
	"\texistence\x18\x03 \x01(\bR\texistence\x125\n" +
	"\x17locked_with_conflict_ts\x18\x04 \x01(\x04R\x14lockedWithConflictTs\x12.\n" +
	"\x13skip_resolving_lock\x18\v \x01(\bR\x11skipResolvingLock\"\xe6\x02\n" +
	"\x17PessimisticLockResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12)\n" +
	"\x06errors\x18\x02 \x03(\v2\x11.kvrpcpb.KeyErrorR\x06errors\x12\x1f\n" +
	"\tcommit_ts\x18\x03 \x01(\x04B\x02\x18\x01R\bcommitTs\x12\x18\n" +
	"\x05value\x18\x04 \x01(\fB\x02\x18\x01R\x05value\x12\x16\n" +
	"\x06values\x18\x05 \x03(\fR\x06values\x12\x1d\n" +
	"\n" +
	"not_founds\x18\x06 \x03(\bR\tnotFounds\x12>\n" +
	"\x0fexec_details_v2\x18\a \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\x12;\n" +
	"\aresults\x18\b \x03(\v2!.kvrpcpb.PessimisticLockKeyResultR\aresults\"\xa5\x01\n" +
	"\x1aPessimisticRollbackRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12#\n" +
	"\rstart_version\x18\x02 \x01(\x04R\fstartVersion\x12\"\n" +
	"\rfor_update_ts\x18\x03 \x01(\x04R\vforUpdateTs\x12\x12\n" +
	"\x04keys\x18\x04 \x03(\fR\x04keys\"\xbb\x01\n" +
	"\x1bPessimisticRollbackResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12)\n" +
	"\x06errors\x18\x02 \x03(\v2\x11.kvrpcpb.KeyErrorR\x06errors\x12>\n" +
	"\x0fexec_details_v2\x18\x03 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"\xf5\x01\n" +
	"\x13TxnHeartBeatRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12!\n" +
	"\fprimary_lock\x18\x02 \x01(\fR\vprimaryLock\x12#\n" +
	"\rstart_version\x18\x03 \x01(\x04R\fstartVersion\x12&\n" +
	"\x0fadvise_lock_ttl\x18\x04 \x01(\x04R\radviseLockTtl\x12\"\n" +
	"\rmin_commit_ts\x18\x05 \x01(\x04R\vminCommitTs\x12\x1e\n" +
	"\vis_txn_file\x18d \x01(\bR\tisTxnFile\"\xcd\x01\n" +
	"\x14TxnHeartBeatResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12\x19\n" +
	"\block_ttl\x18\x03 \x01(\x04R\alockTtl\x12>\n" +
	"\x0fexec_details_v2\x18\x04 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"\xad\x03\n" +
	"\x15CheckTxnStatusRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1f\n" +
	"\vprimary_key\x18\x02 \x01(\fR\n" +
	"primaryKey\x12\x17\n" +
	"\alock_ts\x18\x03 \x01(\x04R\x06lockTs\x12&\n" +
	"\x0fcaller_start_ts\x18\x04 \x01(\x04R\rcallerStartTs\x12\x1d\n" +
	"\n" +
	"current_ts\x18\x05 \x01(\x04R\tcurrentTs\x121\n" +
	"\x15rollback_if_not_exist\x18\x06 \x01(\bR\x12rollbackIfNotExist\x12*\n" +
	"\x11force_sync_commit\x18\a \x01(\bR\x0fforceSyncCommit\x12<\n" +
	"\x1aresolving_pessimistic_lock\x18\b \x01(\bR\x18resolvingPessimisticLock\x12*\n" +
	"\x11verify_is_primary\x18\t \x01(\bR\x0fverifyIsPrimary\x12\x1e\n" +
	"\vis_txn_file\x18d \x01(\bR\tisTxnFile\"\xcf\x02\n" +
	"\x16CheckTxnStatusResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12\x19\n" +
	"\block_ttl\x18\x03 \x01(\x04R\alockTtl\x12%\n" +
	"\x0ecommit_version\x18\x04 \x01(\x04R\rcommitVersion\x12'\n" +
	"\x06action\x18\x05 \x01(\x0e2\x0f.kvrpcpb.ActionR\x06action\x12.\n" +
	"\tlock_info\x18\x06 \x01(\v2\x11.kvrpcpb.LockInfoR\blockInfo\x12>\n" +
	"\x0fexec_details_v2\x18\a \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"\x81\x01\n" +
	"\x1aCheckSecondaryLocksRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x12\n" +
	"\x04keys\x18\x02 \x03(\fR\x04keys\x12#\n" +
	"\rstart_version\x18\x03 \x01(\x04R\fstartVersion\"\xff\x01\n" +
	"\x1bCheckSecondaryLocksResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12'\n" +
	"\x05locks\x18\x03 \x03(\v2\x11.kvrpcpb.LockInfoR\x05locks\x12\x1b\n" +
	"\tcommit_ts\x18\x04 \x01(\x04R\bcommitTs\x12>\n" +
	"\x0fexec_details_v2\x18\x05 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"\xca\x02\n" +
	"\rCommitRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12#\n" +
	"\rstart_version\x18\x02 \x01(\x04R\fstartVersion\x12\x12\n" +
	"\x04keys\x18\x03 \x03(\fR\x04keys\x12%\n" +
	"\x0ecommit_version\x18\x04 \x01(\x04R\rcommitVersion\x124\n" +
	"\vcommit_role\x18\x06 \x01(\x0e2\x13.kvrpcpb.CommitRoleR\n" +
	"commitRole\x12\x1f\n" +
	"\vprimary_key\x18\a \x01(\fR\n" +
	"primaryKey\x12(\n" +
	"\x10use_async_commit\x18\b \x01(\bR\x0euseAsyncCommit\x12\x1e\n" +
	"\vis_txn_file\x18d \x01(\bR\tisTxnFileJ\x04\b\x05\x10\x06R\x06binlog\"\xd3\x01\n" +
	"\x0eCommitResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12%\n" +
	"\x0ecommit_version\x18\x03 \x01(\x04R\rcommitVersion\x12>\n" +
	"\x0fexec_details_v2\x18\x04 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"g\n" +
	"\rImportRequest\x12/\n" +
	"\tmutations\x18\x01 \x03(\v2\x11.kvrpcpb.MutationR\tmutations\x12%\n" +
	"\x0ecommit_version\x18\x02 \x01(\x04R\rcommitVersion\"Y\n" +
	"\x0eImportResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\x92\x01\n" +
	"\x0eCleanupRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12#\n" +
	"\rstart_version\x18\x03 \x01(\x04R\fstartVersion\x12\x1d\n" +
	"\n" +
	"current_ts\x18\x04 \x01(\x04R\tcurrentTs\"\x94\x01\n" +
	"\x0fCleanupResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12%\n" +
	"\x0ecommit_version\x18\x03 \x01(\x04R\rcommitVersion\"\x91\x01\n" +
	"\x0fBatchGetRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x12\n" +
	"\x04keys\x18\x02 \x03(\fR\x04keys\x12\x18\n" +
	"\aversion\x18\x03 \x01(\x04R\aversion\x12$\n" +
	"\x0eneed_commit_ts\x18\x04 \x01(\bR\fneedCommitTs\"\xdb\x01\n" +
	"\x10BatchGetResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12%\n" +
	"\x05pairs\x18\x02 \x03(\v2\x0f.kvrpcpb.KvPairR\x05pairs\x12>\n" +
	"\x0fexec_details_v2\x18\x04 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\x12'\n" +
	"\x05error\x18\x05 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05errorJ\x04\b\x03\x10\x04\"\x9b\x01\n" +
	"\x14BatchRollbackRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12#\n" +
	"\rstart_version\x18\x02 \x01(\x04R\fstartVersion\x12\x12\n" +
	"\x04keys\x18\x03 \x03(\fR\x04keys\x12\x1e\n" +
	"\vis_txn_file\x18d \x01(\bR\tisTxnFile\"\xb3\x01\n" +
	"\x15BatchRollbackResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12>\n" +
	"\x0fexec_details_v2\x18\x03 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"\xaa\x01\n" +
	"\x0fScanLockRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1f\n" +
	"\vmax_version\x18\x02 \x01(\x04R\n" +
	"maxVersion\x12\x1b\n" +
	"\tstart_key\x18\x03 \x01(\fR\bstartKey\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\rR\x05limit\x12\x17\n" +
	"\aend_key\x18\x05 \x01(\fR\x06endKey\"\xd7\x01\n" +
	"\x10ScanLockResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12'\n" +
	"\x05locks\x18\x03 \x03(\v2\x11.kvrpcpb.LockInfoR\x05locks\x12>\n" +
	"\x0fexec_details_v2\x18\x04 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"\xef\x01\n" +
	"\x12ResolveLockRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12#\n" +
	"\rstart_version\x18\x02 \x01(\x04R\fstartVersion\x12%\n" +
	"\x0ecommit_version\x18\x03 \x01(\x04R\rcommitVersion\x12-\n" +
	"\ttxn_infos\x18\x04 \x03(\v2\x10.kvrpcpb.TxnInfoR\btxnInfos\x12\x12\n" +
	"\x04keys\x18\x05 \x03(\fR\x04keys\x12\x1e\n" +
	"\vis_txn_file\x18d \x01(\bR\tisTxnFile\"\xb1\x01\n" +
	"\x13ResolveLockResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12>\n" +
	"\x0fexec_details_v2\x18\x03 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"V\n" +
	"\tGCRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1d\n" +
	"\n" +
	"safe_point\x18\x02 \x01(\x04R\tsafePoint\"h\n" +
	"\n" +
	"GCResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\"\x97\x01\n" +
	"\x12DeleteRangeRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x03 \x01(\fR\x06endKey\x12\x1f\n" +
	"\vnotify_only\x18\x04 \x01(\bR\n" +
	"notifyOnly\"^\n" +
	"\x13DeleteRangeResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xb9\x01\n" +
	" PrepareFlashbackToVersionRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x03 \x01(\fR\x06endKey\x12\x19\n" +
	"\bstart_ts\x18\x04 \x01(\x04R\astartTs\x12\x18\n" +
	"\aversion\x18\x05 \x01(\x04R\aversion\"l\n" +
	"!PrepareFlashbackToVersionResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xcf\x01\n" +
	"\x19FlashbackToVersionRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x18\n" +
	"\aversion\x18\x02 \x01(\x04R\aversion\x12\x1b\n" +
	"\tstart_key\x18\x03 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x04 \x01(\fR\x06endKey\x12\x19\n" +
	"\bstart_ts\x18\x05 \x01(\x04R\astartTs\x12\x1b\n" +
	"\tcommit_ts\x18\x06 \x01(\x04R\bcommitTs\"e\n" +
	"\x1aFlashbackToVersionResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"]\n" +
	"\rRawGetRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\"\x8c\x01\n" +
	"\x0eRawGetResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\x12\x1b\n" +
	"\tnot_found\x18\x04 \x01(\bR\bnotFound\"d\n" +
	"\x12RawBatchGetRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x12\n" +
	"\x04keys\x18\x02 \x03(\fR\x04keys\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\"o\n" +
	"\x13RawBatchGetResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12%\n" +
	"\x05pairs\x18\x02 \x03(\v2\x0f.kvrpcpb.KvPairR\x05pairs\"\x9e\x01\n" +
	"\rRawPutRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\x12\x0e\n" +
	"\x02cf\x18\x04 \x01(\tR\x02cf\x12\x10\n" +
	"\x03ttl\x18\x05 \x01(\x04R\x03ttl\x12\x17\n" +
	"\afor_cas\x18\x06 \x01(\bR\x06forCas\"Y\n" +
	"\x0eRawPutResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xba\x01\n" +
	"\x12RawBatchPutRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12%\n" +
	"\x05pairs\x18\x02 \x03(\v2\x0f.kvrpcpb.KvPairR\x05pairs\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\x12\x14\n" +
	"\x03ttl\x18\x04 \x01(\x04B\x02\x18\x01R\x03ttl\x12\x17\n" +
	"\afor_cas\x18\x05 \x01(\bR\x06forCas\x12\x12\n" +
	"\x04ttls\x18\x06 \x03(\x04R\x04ttls\"^\n" +
	"\x13RawBatchPutResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"y\n" +
	"\x10RawDeleteRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\x12\x17\n" +
	"\afor_cas\x18\x04 \x01(\bR\x06forCas\"\\\n" +
	"\x11RawDeleteResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\x80\x01\n" +
	"\x15RawBatchDeleteRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x12\n" +
	"\x04keys\x18\x02 \x03(\fR\x04keys\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\x12\x17\n" +
	"\afor_cas\x18\x04 \x01(\bR\x06forCas\"a\n" +
	"\x16RawBatchDeleteResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xcd\x01\n" +
	"\x0eRawScanRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x14\n" +
	"\x05limit\x18\x03 \x01(\rR\x05limit\x12\x19\n" +
	"\bkey_only\x18\x04 \x01(\bR\akeyOnly\x12\x0e\n" +
	"\x02cf\x18\x05 \x01(\tR\x02cf\x12\x18\n" +
	"\areverse\x18\x06 \x01(\bR\areverse\x12\x17\n" +
	"\aend_key\x18\a \x01(\fR\x06endKey\"g\n" +
	"\x0fRawScanResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12!\n" +
	"\x03kvs\x18\x02 \x03(\v2\x0f.kvrpcpb.KvPairR\x03kvs\"\x89\x01\n" +
	"\x15RawDeleteRangeRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x03 \x01(\fR\x06endKey\x12\x0e\n" +
	"\x02cf\x18\x04 \x01(\tR\x02cf\"a\n" +
	"\x16RawDeleteRangeResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\xd0\x01\n" +
	"\x13RawBatchScanRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12)\n" +
	"\x06ranges\x18\x02 \x03(\v2\x11.kvrpcpb.KeyRangeR\x06ranges\x12\x1d\n" +
	"\n" +
	"each_limit\x18\x03 \x01(\rR\teachLimit\x12\x19\n" +
	"\bkey_only\x18\x04 \x01(\bR\akeyOnly\x12\x0e\n" +
	"\x02cf\x18\x05 \x01(\tR\x02cf\x12\x18\n" +
	"\areverse\x18\x06 \x01(\bR\areverse\"l\n" +
	"\x14RawBatchScanResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12!\n" +
	"\x03kvs\x18\x02 \x03(\v2\x0f.kvrpcpb.KvPairR\x03kvs\"}\n" +
	"\x19UnsafeDestroyRangeRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x03 \x01(\fR\x06endKey\"e\n" +
	"\x1aUnsafeDestroyRangeResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"`\n" +
	"\x1bRegisterLockObserverRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x15\n" +
	"\x06max_ts\x18\x02 \x01(\x04R\x05maxTs\"4\n" +
	"\x1cRegisterLockObserverResponse\x12\x14\n" +
	"\x05error\x18\x01 \x01(\tR\x05error\"]\n" +
	"\x18CheckLockObserverRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x15\n" +
	"\x06max_ts\x18\x02 \x01(\x04R\x05maxTs\"u\n" +
	"\x19CheckLockObserverResponse\x12\x14\n" +
	"\x05error\x18\x01 \x01(\tR\x05error\x12\x19\n" +
	"\bis_clean\x18\x02 \x01(\bR\aisClean\x12'\n" +
	"\x05locks\x18\x03 \x03(\v2\x11.kvrpcpb.LockInfoR\x05locks\"^\n" +
	"\x19RemoveLockObserverRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x15\n" +
	"\x06max_ts\x18\x02 \x01(\x04R\x05maxTs\"2\n" +
	"\x1aRemoveLockObserverResponse\x12\x14\n" +
	"\x05error\x18\x01 \x01(\tR\x05error\"\x8f\x01\n" +
	"\x17PhysicalScanLockRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x15\n" +
	"\x06max_ts\x18\x02 \x01(\x04R\x05maxTs\x12\x1b\n" +
	"\tstart_key\x18\x03 \x01(\fR\bstartKey\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\rR\x05limit\"Y\n" +
	"\x18PhysicalScanLockResponse\x12\x14\n" +
	"\x05error\x18\x01 \x01(\tR\x05error\x12'\n" +
	"\x05locks\x18\x02 \x03(\v2\x11.kvrpcpb.LockInfoR\x05locks\"\x9c\x01\n" +
	"\x12SplitRegionRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1f\n" +
	"\tsplit_key\x18\x02 \x01(\fB\x02\x18\x01R\bsplitKey\x12\x1d\n" +
	"\n" +
	"split_keys\x18\x03 \x03(\fR\tsplitKeys\x12\x1a\n" +
	"\tis_raw_kv\x18\x04 \x01(\bR\aisRawKv\"\xef\x01\n" +
	"\x13SplitRegionResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12&\n" +
	"\x04left\x18\x02 \x01(\v2\x0e.metapb.RegionB\x02\x18\x01R\x04left\x12(\n" +
	"\x05right\x18\x03 \x01(\v2\x0e.metapb.RegionB\x02\x18\x01R\x05right\x12(\n" +
	"\aregions\x18\x04 \x03(\v2\x0e.metapb.RegionR\aregions\x12)\n" +
	"\x06errors\x18d \x03(\v2\x11.kvrpcpb.KeyErrorR\x06errors\"\x84\x01\n" +
	"\x10ReadIndexRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x19\n" +
	"\bstart_ts\x18\x02 \x01(\x04R\astartTs\x12)\n" +
	"\x06ranges\x18\x03 \x03(\v2\x11.kvrpcpb.KeyRangeR\x06ranges\"\x90\x01\n" +
	"\x11ReadIndexResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x1d\n" +
	"\n" +
	"read_index\x18\x02 \x01(\x04R\treadIndex\x12)\n" +
	"\x06locked\x18\x03 \x01(\v2\x11.kvrpcpb.LockInfoR\x06locked\"S\n" +
	"\x13MvccGetByKeyRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\"\x86\x01\n" +
	"\x14MvccGetByKeyResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12%\n" +
	"\x04info\x18\x03 \x01(\v2\x11.kvrpcpb.MvccInfoR\x04info\"`\n" +
	"\x17MvccGetByStartTsRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x19\n" +
	"\bstart_ts\x18\x02 \x01(\x04R\astartTs\"\x9c\x01\n" +
	"\x18MvccGetByStartTsResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x10\n" +
	"\x03key\x18\x03 \x01(\fR\x03key\x12%\n" +
	"\x04info\x18\x04 \x01(\v2\x11.kvrpcpb.MvccInfoR\x04info\"\xa0\v\n" +
	"\aContext\x12\x1b\n" +
	"\tregion_id\x18\x01 \x01(\x04R\bregionId\x126\n" +
	"\fregion_epoch\x18\x02 \x01(\v2\x13.metapb.RegionEpochR\vregionEpoch\x12 \n" +
	"\x04peer\x18\x03 \x01(\v2\f.metapb.PeerR\x04peer\x12\x12\n" +
	"\x04term\x18\x05 \x01(\x04R\x04term\x12/\n" +
	"\bpriority\x18\x06 \x01(\x0e2\x13.kvrpcpb.CommandPriR\bpriority\x12@\n" +
	"\x0fisolation_level\x18\a \x01(\x0e2\x17.kvrpcpb.IsolationLevelR\x0eisolationLevel\x12$\n" +
	"\x0enot_fill_cache\x18\b \x01(\bR\fnotFillCache\x12\x19\n" +
	"\bsync_log\x18\t \x01(\bR\asyncLog\x12(\n" +
	"\x10record_time_stat\x18\n" +
	" \x01(\bR\x0erecordTimeStat\x12(\n" +
	"\x10record_scan_stat\x18\v \x01(\bR\x0erecordScanStat\x12!\n" +
	"\freplica_read\x18\f \x01(\bR\vreplicaRead\x12%\n" +
	"\x0eresolved_locks\x18\r \x03(\x04R\rresolvedLocks\x129\n" +
	"\x19max_execution_duration_ms\x18\x0e \x01(\x04R\x16maxExecutionDurationMs\x12#\n" +
	"\rapplied_index\x18\x0f \x01(\x04R\fappliedIndex\x12\x17\n" +
	"\atask_id\x18\x10 \x01(\x04R\x06taskId\x12\x1d\n" +
	"\n" +
	"stale_read\x18\x11 \x01(\bR\tstaleRead\x12,\n" +
	"\x12resource_group_tag\x18\x12 \x01(\fR\x10resourceGroupTag\x128\n" +
	"\rdisk_full_opt\x18\x13 \x01(\x0e2\x14.kvrpcpb.DiskFullOptR\vdiskFullOpt\x12(\n" +
	"\x10is_retry_request\x18\x14 \x01(\bR\x0eisRetryRequest\x124\n" +
	"\vapi_version\x18\x15 \x01(\x0e2\x13.kvrpcpb.APIVersionR\n" +
	"apiVersion\x12'\n" +
	"\x0fcommitted_locks\x18\x16 \x03(\x04R\x0ecommittedLocks\x12:\n" +
	"\rtrace_context\x18\x17 \x01(\v2\x15.tracepb.TraceContextR\ftraceContext\x12%\n" +
	"\x0erequest_source\x18\x18 \x01(\tR\rrequestSource\x12\x1d\n" +
	"\n" +
	"txn_source\x18\x19 \x01(\x04R\ttxnSource\x12*\n" +
	"\x11busy_threshold_ms\x18\x1b \x01(\rR\x0fbusyThresholdMs\x12Y\n" +
	"\x18resource_control_context\x18\x1c \x01(\v2\x1f.kvrpcpb.ResourceControlContextR\x16resourceControlContext\x12#\n" +
	"\rkeyspace_name\x18\x1f \x01(\tR\fkeyspaceName\x12\x1f\n" +
	"\vkeyspace_id\x18  \x01(\rR\n" +
	"keyspaceId\x12'\n" +
	"\x0fbuckets_version\x18! \x01(\x04R\x0ebucketsVersion\x124\n" +
	"\vsource_stmt\x18\" \x01(\v2\x13.kvrpcpb.SourceStmtR\n" +
	"sourceStmt\x12\x1d\n" +
	"\n" +
	"cluster_id\x18# \x01(\x04R\tclusterId\x12\x19\n" +
	"\btrace_id\x18$ \x01(\fR\atraceId\x12.\n" +
	"\x13trace_control_flags\x18% \x01(\x04R\x11traceControlFlagsJ\x04\b\x04\x10\x05J\x04\b\x1a\x10\x1bR\vread_quorum\"\xae\x01\n" +
	"\x16ResourceControlContext\x12.\n" +
	"\x13resource_group_name\x18\x01 \x01(\tR\x11resourceGroupName\x127\n" +
	"\apenalty\x18\x02 \x01(\v2\x1d.resource_manager.ConsumptionR\apenalty\x12+\n" +
	"\x11override_priority\x18\x03 \x01(\x04R\x10overridePriority\"\x8a\x01\n" +
	"\n" +
	"SourceStmt\x12\x19\n" +
	"\bstart_ts\x18\x01 \x01(\x04R\astartTs\x12#\n" +
	"\rconnection_id\x18\x02 \x01(\x04R\fconnectionId\x12\x17\n" +
	"\astmt_id\x18\x03 \x01(\x04R\x06stmtId\x12#\n" +
	"\rsession_alias\x18\x04 \x01(\tR\fsessionAlias\"\xfa\x03\n" +
	"\bLockInfo\x12!\n" +
	"\fprimary_lock\x18\x01 \x01(\fR\vprimaryLock\x12!\n" +
	"\flock_version\x18\x02 \x01(\x04R\vlockVersion\x12\x10\n" +
	"\x03key\x18\x03 \x01(\fR\x03key\x12\x19\n" +
	"\block_ttl\x18\x04 \x01(\x04R\alockTtl\x12\x19\n" +
	"\btxn_size\x18\x05 \x01(\x04R\atxnSize\x12(\n" +
	"\tlock_type\x18\x06 \x01(\x0e2\v.kvrpcpb.OpR\blockType\x12+\n" +
	"\x12lock_for_update_ts\x18\a \x01(\x04R\x0flockForUpdateTs\x12(\n" +
	"\x10use_async_commit\x18\b \x01(\bR\x0euseAsyncCommit\x12\"\n" +
	"\rmin_commit_ts\x18\t \x01(\x04R\vminCommitTs\x12 \n" +
	"\vsecondaries\x18\n" +
	" \x03(\fR\vsecondaries\x12:\n" +
	"\x1aduration_to_last_update_ms\x18\v \x01(\x04R\x16durationToLastUpdateMs\x12=\n" +
	"\x11shared_lock_infos\x18\f \x03(\v2\x11.kvrpcpb.LockInfoR\x0fsharedLockInfos\x12\x1e\n" +
	"\vis_txn_file\x18d \x01(\bR\tisTxnFile\"\xd6\x05\n" +
	"\bKeyError\x12)\n" +
	"\x06locked\x18\x01 \x01(\v2\x11.kvrpcpb.LockInfoR\x06locked\x12\x1c\n" +
	"\tretryable\x18\x02 \x01(\tR\tretryable\x12\x14\n" +
	"\x05abort\x18\x03 \x01(\tR\x05abort\x122\n" +
	"\bconflict\x18\x04 \x01(\v2\x16.kvrpcpb.WriteConflictR\bconflict\x12:\n" +
	"\ralready_exist\x18\x05 \x01(\v2\x15.kvrpcpb.AlreadyExistR\falreadyExist\x12-\n" +
	"\bdeadlock\x18\x06 \x01(\v2\x11.kvrpcpb.DeadlockR\bdeadlock\x12D\n" +
	"\x11commit_ts_expired\x18\a \x01(\v2\x18.kvrpcpb.CommitTsExpiredR\x0fcommitTsExpired\x128\n" +
	"\rtxn_not_found\x18\b \x01(\v2\x14.kvrpcpb.TxnNotFoundR\vtxnNotFound\x12H\n" +
	"\x13commit_ts_too_large\x18\t \x01(\v2\x19.kvrpcpb.CommitTsTooLargeR\x10commitTsTooLarge\x12C\n" +
	"\x10assertion_failed\x18\n" +
	" \x01(\v2\x18.kvrpcpb.AssertionFailedR\x0fassertionFailed\x12C\n" +
	"\x10primary_mismatch\x18\v \x01(\v2\x18.kvrpcpb.PrimaryMismatchR\x0fprimaryMismatch\x12E\n" +
	"\x12txn_lock_not_found\x18\f \x01(\v2\x18.kvrpcpb.TxnLockNotFoundR\x0ftxnLockNotFound\x121\n" +
	"\n" +
	"debug_info\x18d \x01(\v2\x12.kvrpcpb.DebugInfoR\tdebugInfo\"\xf0\x02\n" +
	"\rWriteConflict\x12\x19\n" +
	"\bstart_ts\x18\x01 \x01(\x04R\astartTs\x12\x1f\n" +
	"\vconflict_ts\x18\x02 \x01(\x04R\n" +
	"conflictTs\x12\x10\n" +
	"\x03key\x18\x03 \x01(\fR\x03key\x12\x18\n" +
	"\aprimary\x18\x04 \x01(\fR\aprimary\x12,\n" +
	"\x12conflict_commit_ts\x18\x05 \x01(\x04R\x10conflictCommitTs\x125\n" +
	"\x06reason\x18\x06 \x01(\x0e2\x1d.kvrpcpb.WriteConflict.ReasonR\x06reason\"\x91\x01\n" +
	"\x06Reason\x12\v\n" +
	"\aUnknown\x10\x00\x12\x0e\n" +
	"\n" +
	"Optimistic\x10\x01\x12\x14\n" +
	"\x10PessimisticRetry\x10\x02\x12\x12\n" +
	"\x0eSelfRolledBack\x10\x03\x12\r\n" +
	"\tRcCheckTs\x10\x04\x12\x17\n" +
	"\x13LazyUniquenessCheck\x10\x05\x12\x18\n" +
	"\x14NotLockedKeyConflict\x10\x06\" \n" +
	"\fAlreadyExist\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\"\xc4\x01\n" +
	"\bDeadlock\x12\x17\n" +
	"\alock_ts\x18\x01 \x01(\x04R\x06lockTs\x12\x19\n" +
	"\block_key\x18\x02 \x01(\fR\alockKey\x12*\n" +
	"\x11deadlock_key_hash\x18\x03 \x01(\x04R\x0fdeadlockKeyHash\x125\n" +
	"\n" +
	"wait_chain\x18\x04 \x03(\v2\x16.deadlock.WaitForEntryR\twaitChain\x12!\n" +
	"\fdeadlock_key\x18\x05 \x01(\fR\vdeadlockKey\"\x92\x01\n" +
	"\x0fCommitTsExpired\x12\x19\n" +
	"\bstart_ts\x18\x01 \x01(\x04R\astartTs\x12.\n" +
	"\x13attempted_commit_ts\x18\x02 \x01(\x04R\x11attemptedCommitTs\x12\x10\n" +
	"\x03key\x18\x03 \x01(\fR\x03key\x12\"\n" +
	"\rmin_commit_ts\x18\x04 \x01(\x04R\vminCommitTs\"I\n" +
	"\vTxnNotFound\x12\x19\n" +
	"\bstart_ts\x18\x01 \x01(\x04R\astartTs\x12\x1f\n" +
	"\vprimary_key\x18\x02 \x01(\fR\n" +
	"primaryKey\"/\n" +
	"\x10CommitTsTooLarge\x12\x1b\n" +
	"\tcommit_ts\x18\x01 \x01(\x04R\bcommitTs\"\xca\x01\n" +
	"\x0fAssertionFailed\x12\x19\n" +
	"\bstart_ts\x18\x01 \x01(\x04R\astartTs\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x120\n" +
	"\tassertion\x18\x03 \x01(\x0e2\x12.kvrpcpb.AssertionR\tassertion\x12*\n" +
	"\x11existing_start_ts\x18\x04 \x01(\x04R\x0fexistingStartTs\x12,\n" +
	"\x12existing_commit_ts\x18\x05 \x01(\x04R\x10existingCommitTs\"A\n" +
	"\x0fPrimaryMismatch\x12.\n" +
	"\tlock_info\x18\x01 \x01(\v2\x11.kvrpcpb.LockInfoR\blockInfo\"#\n" +
	"\x0fTxnLockNotFound\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\"H\n" +
	"\rMvccDebugInfo\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12%\n" +
	"\x04mvcc\x18\x02 \x01(\v2\x11.kvrpcpb.MvccInfoR\x04mvcc\"@\n" +
	"\tDebugInfo\x123\n" +
	"\tmvcc_info\x18\x01 \x03(\v2\x16.kvrpcpb.MvccDebugInfoR\bmvccInfo\"\xcc\x01\n" +
	"\n" +
	"TimeDetail\x12)\n" +
	"\x11wait_wall_time_ms\x18\x01 \x01(\x04R\x0ewaitWallTimeMs\x12/\n" +
	"\x14process_wall_time_ms\x18\x02 \x01(\x04R\x11processWallTimeMs\x12.\n" +
	"\x14kv_read_wall_time_ms\x18\x03 \x01(\x04R\x10kvReadWallTimeMs\x122\n" +
	"\x16total_rpc_wall_time_ns\x18\x04 \x01(\x04R\x12totalRpcWallTimeNs\"\xf4\x02\n" +
	"\fTimeDetailV2\x12)\n" +
	"\x11wait_wall_time_ns\x18\x01 \x01(\x04R\x0ewaitWallTimeNs\x12/\n" +
	"\x14process_wall_time_ns\x18\x02 \x01(\x04R\x11processWallTimeNs\x12>\n" +
	"\x1cprocess_suspend_wall_time_ns\x18\x03 \x01(\x04R\x18processSuspendWallTimeNs\x12.\n" +
	"\x14kv_read_wall_time_ns\x18\x04 \x01(\x04R\x10kvReadWallTimeNs\x122\n" +
	"\x16total_rpc_wall_time_ns\x18\x05 \x01(\x04R\x12totalRpcWallTimeNs\x124\n" +
	"\x17kv_grpc_process_time_ns\x18\x06 \x01(\x04R\x13kvGrpcProcessTimeNs\x12.\n" +
	"\x14kv_grpc_wait_time_ns\x18\a \x01(\x04R\x10kvGrpcWaitTimeNs\"]\n" +
	"\bScanInfo\x12\x14\n" +
	"\x05total\x18\x01 \x01(\x03R\x05total\x12\x1c\n" +
	"\tprocessed\x18\x02 \x01(\x03R\tprocessed\x12\x1d\n" +
	"\n" +
	"read_bytes\x18\x03 \x01(\x03R\treadBytes\"\x83\x01\n" +
	"\n" +
	"ScanDetail\x12'\n" +
	"\x05write\x18\x01 \x01(\v2\x11.kvrpcpb.ScanInfoR\x05write\x12%\n" +
	"\x04lock\x18\x02 \x01(\v2\x11.kvrpcpb.ScanInfoR\x04lock\x12%\n" +
	"\x04data\x18\x03 \x01(\v2\x11.kvrpcpb.ScanInfoR\x04data\"\xf7\x05\n" +
	"\fScanDetailV2\x12-\n" +
	"\x12processed_versions\x18\x01 \x01(\x04R\x11processedVersions\x126\n" +
	"\x17processed_versions_size\x18\b \x01(\x04R\x15processedVersionsSize\x12%\n" +
	"\x0etotal_versions\x18\x02 \x01(\x04R\rtotalVersions\x12?\n" +
	"\x1crocksdb_delete_skipped_count\x18\x03 \x01(\x04R\x19rocksdbDeleteSkippedCount\x129\n" +
	"\x19rocksdb_key_skipped_count\x18\x04 \x01(\x04R\x16rocksdbKeySkippedCount\x12@\n" +
	"\x1drocksdb_block_cache_hit_count\x18\x05 \x01(\x04R\x19rocksdbBlockCacheHitCount\x127\n" +
	"\x18rocksdb_block_read_count\x18\x06 \x01(\x04R\x15rocksdbBlockReadCount\x125\n" +
	"\x17rocksdb_block_read_byte\x18\a \x01(\x04R\x14rocksdbBlockReadByte\x127\n" +
	"\x18rocksdb_block_read_nanos\x18\t \x01(\x04R\x15rocksdbBlockReadNanos\x12,\n" +
	"\x12get_snapshot_nanos\x18\n" +
	" \x01(\x04R\x10getSnapshotNanos\x12@\n" +
	"\x1dread_index_propose_wait_nanos\x18\v \x01(\x04R\x19readIndexProposeWaitNanos\x12@\n" +
	"\x1dread_index_confirm_wait_nanos\x18\f \x01(\x04R\x19readIndexConfirmWaitNanos\x12@\n" +
	"\x1dread_pool_schedule_wait_nanos\x18\r \x01(\x04R\x19readPoolScheduleWaitNanos\"\x85\x01\n" +
	"\vExecDetails\x124\n" +
	"\vtime_detail\x18\x01 \x01(\v2\x13.kvrpcpb.TimeDetailR\n" +
	"timeDetail\x124\n" +
	"\vscan_detail\x18\x02 \x01(\v2\x13.kvrpcpb.ScanDetailR\n" +
	"scanDetailJ\x04\b\x03\x10\x04J\x04\b\x04\x10\x05\"\xf8\x01\n" +
	"\rExecDetailsV2\x124\n" +
	"\vtime_detail\x18\x01 \x01(\v2\x13.kvrpcpb.TimeDetailR\n" +
	"timeDetail\x12;\n" +
	"\x0escan_detail_v2\x18\x02 \x01(\v2\x15.kvrpcpb.ScanDetailV2R\fscanDetailV2\x127\n" +
	"\fwrite_detail\x18\x03 \x01(\v2\x14.kvrpcpb.WriteDetailR\vwriteDetail\x12;\n" +
	"\x0etime_detail_v2\x18\x04 \x01(\v2\x15.kvrpcpb.TimeDetailV2R\ftimeDetailV2\"\x81\a\n" +
	"\vWriteDetail\x123\n" +
	"\x16store_batch_wait_nanos\x18\x01 \x01(\x04R\x13storeBatchWaitNanos\x125\n" +
	"\x17propose_send_wait_nanos\x18\x02 \x01(\x04R\x14proposeSendWaitNanos\x12*\n" +
	"\x11persist_log_nanos\x18\x03 \x01(\x04R\x0fpersistLogNanos\x12C\n" +
	"\x1fraft_db_write_leader_wait_nanos\x18\x04 \x01(\x04R\x1araftDbWriteLeaderWaitNanos\x122\n" +
	"\x16raft_db_sync_log_nanos\x18\x05 \x01(\x04R\x12raftDbSyncLogNanos\x12>\n" +
	"\x1craft_db_write_memtable_nanos\x18\x06 \x01(\x04R\x18raftDbWriteMemtableNanos\x12(\n" +
	"\x10commit_log_nanos\x18\a \x01(\x04R\x0ecommitLogNanos\x123\n" +
	"\x16apply_batch_wait_nanos\x18\b \x01(\x04R\x13applyBatchWaitNanos\x12&\n" +
	"\x0fapply_log_nanos\x18\t \x01(\x04R\rapplyLogNanos\x123\n" +
	"\x16apply_mutex_lock_nanos\x18\n" +
	" \x01(\x04R\x13applyMutexLockNanos\x12@\n" +
	"\x1dapply_write_leader_wait_nanos\x18\v \x01(\x04R\x19applyWriteLeaderWaitNanos\x121\n" +
	"\x15apply_write_wal_nanos\x18\f \x01(\x04R\x12applyWriteWalNanos\x12;\n" +
	"\x1aapply_write_memtable_nanos\x18\r \x01(\x04R\x17applyWriteMemtableNanos\x12(\n" +
	"\x10latch_wait_nanos\x18\x0e \x01(\x04R\x0elatchWaitNanos\x12#\n" +
	"\rprocess_nanos\x18\x0f \x01(\x04R\fprocessNanos\x12%\n" +
	"\x0ethrottle_nanos\x18\x10 \x01(\x04R\rthrottleNanos\x12=\n" +
	"\x1bpessimistic_lock_wait_nanos\x18\x11 \x01(\x04R\x18pessimisticLockWaitNanos\"v\n" +
	"\x06KvPair\x12'\n" +
	"\x05error\x18\x01 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\x12\x1b\n" +
	"\tcommit_ts\x18\x04 \x01(\x04R\bcommitTs\"\x81\x01\n" +
	"\bMutation\x12\x1b\n" +
	"\x02op\x18\x01 \x01(\x0e2\v.kvrpcpb.OpR\x02op\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\x120\n" +
	"\tassertion\x18\x04 \x01(\x0e2\x12.kvrpcpb.AssertionR\tassertion\"\xd7\x02\n" +
	"\tMvccWrite\x12\x1f\n" +
	"\x04type\x18\x01 \x01(\x0e2\v.kvrpcpb.OpR\x04type\x12\x19\n" +
	"\bstart_ts\x18\x02 \x01(\x04R\astartTs\x12\x1b\n" +
	"\tcommit_ts\x18\x03 \x01(\x04R\bcommitTs\x12\x1f\n" +
	"\vshort_value\x18\x04 \x01(\fR\n" +
	"shortValue\x126\n" +
	"\x17has_overlapped_rollback\x18\x05 \x01(\bR\x15hasOverlappedRollback\x12 \n" +
	"\fhas_gc_fence\x18\x06 \x01(\bR\n" +
	"hasGcFence\x12\x19\n" +
	"\bgc_fence\x18\a \x01(\x04R\agcFence\x12$\n" +
	"\x0elast_change_ts\x18\b \x01(\x04R\flastChangeTs\x125\n" +
	"\x17versions_to_last_change\x18\t \x01(\x04R\x14versionsToLastChange\"<\n" +
	"\tMvccValue\x12\x19\n" +
	"\bstart_ts\x18\x01 \x01(\x04R\astartTs\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\"\x9c\x03\n" +
	"\bMvccLock\x12\x1f\n" +
	"\x04type\x18\x01 \x01(\x0e2\v.kvrpcpb.OpR\x04type\x12\x19\n" +
	"\bstart_ts\x18\x02 \x01(\x04R\astartTs\x12\x18\n" +
	"\aprimary\x18\x03 \x01(\fR\aprimary\x12\x1f\n" +
	"\vshort_value\x18\x04 \x01(\fR\n" +
	"shortValue\x12\x10\n" +
	"\x03ttl\x18\x05 \x01(\x04R\x03ttl\x12\"\n" +
	"\rfor_update_ts\x18\x06 \x01(\x04R\vforUpdateTs\x12\x19\n" +
	"\btxn_size\x18\a \x01(\x04R\atxnSize\x12(\n" +
	"\x10use_async_commit\x18\b \x01(\bR\x0euseAsyncCommit\x12 \n" +
	"\vsecondaries\x18\t \x03(\fR\vsecondaries\x12\x1f\n" +
	"\vrollback_ts\x18\n" +
	" \x03(\x04R\n" +
	"rollbackTs\x12$\n" +
	"\x0elast_change_ts\x18\v \x01(\x04R\flastChangeTs\x125\n" +
	"\x17versions_to_last_change\x18\f \x01(\x04R\x14versionsToLastChange\"\x89\x01\n" +
	"\bMvccInfo\x12%\n" +
	"\x04lock\x18\x01 \x01(\v2\x11.kvrpcpb.MvccLockR\x04lock\x12*\n" +
	"\x06writes\x18\x02 \x03(\v2\x12.kvrpcpb.MvccWriteR\x06writes\x12*\n" +
	"\x06values\x18\x03 \x03(\v2\x12.kvrpcpb.MvccValueR\x06values\"S\n" +
	"\aTxnInfo\x12\x10\n" +
	"\x03txn\x18\x01 \x01(\x04R\x03txn\x12\x16\n" +
	"\x06status\x18\x02 \x01(\x04R\x06status\x12\x1e\n" +
	"\vis_txn_file\x18d \x01(\bR\tisTxnFile\"@\n" +
	"\bKeyRange\x12\x1b\n" +
	"\tstart_key\x18\x01 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x02 \x01(\fR\x06endKey\"\xc1\x01\n" +
	"\n" +
	"LeaderInfo\x12\x1b\n" +
	"\tregion_id\x18\x01 \x01(\x04R\bregionId\x12\x17\n" +
	"\apeer_id\x18\x02 \x01(\x04R\x06peerId\x12\x12\n" +
	"\x04term\x18\x03 \x01(\x04R\x04term\x126\n" +
	"\fregion_epoch\x18\x04 \x01(\v2\x13.metapb.RegionEpochR\vregionEpoch\x121\n" +
	"\n" +
	"read_state\x18\x05 \x01(\v2\x12.kvrpcpb.ReadStateR\treadState\"I\n" +
	"\tReadState\x12#\n" +
	"\rapplied_index\x18\x01 \x01(\x04R\fappliedIndex\x12\x17\n" +
	"\asafe_ts\x18\x02 \x01(\x04R\x06safeTs\"S\n" +
	"\x12CheckLeaderRequest\x12-\n" +
	"\aregions\x18\x01 \x03(\v2\x13.kvrpcpb.LeaderInfoR\aregions\x12\x0e\n" +
	"\x02ts\x18\x02 \x01(\x04R\x02ts\"?\n" +
	"\x13CheckLeaderResponse\x12\x18\n" +
	"\aregions\x18\x01 \x03(\x04R\aregions\x12\x0e\n" +
	"\x02ts\x18\x02 \x01(\x04R\x02ts\"D\n" +
	"\x12StoreSafeTSRequest\x12.\n" +
	"\tkey_range\x18\x01 \x01(\v2\x11.kvrpcpb.KeyRangeR\bkeyRange\".\n" +
	"\x13StoreSafeTSResponse\x12\x17\n" +
	"\asafe_ts\x18\x01 \x01(\x04R\x06safeTs\"c\n" +
	"\x13RawGetKeyTTLRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\"\x8e\x01\n" +
	"\x14RawGetKeyTTLResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x10\n" +
	"\x03ttl\x18\x03 \x01(\x04R\x03ttl\x12\x1b\n" +
	"\tnot_found\x18\x04 \x01(\bR\bnotFound\"\xda\x01\n" +
	"\rRawCASRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\x12,\n" +
	"\x12previous_not_exist\x18\x04 \x01(\bR\x10previousNotExist\x12%\n" +
	"\x0eprevious_value\x18\x05 \x01(\fR\rpreviousValue\x12\x0e\n" +
	"\x02cf\x18\x06 \x01(\tR\x02cf\x12\x10\n" +
	"\x03ttl\x18\a \x01(\x04R\x03ttl\"\xc8\x01\n" +
	"\x0eRawCASResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x18\n" +
	"\asucceed\x18\x03 \x01(\bR\asucceed\x12,\n" +
	"\x12previous_not_exist\x18\x04 \x01(\bR\x10previousNotExist\x12%\n" +
	"\x0eprevious_value\x18\x05 \x01(\fR\rpreviousValue\"D\n" +
	"\x16GetLockWaitInfoRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\"\x94\x01\n" +
	"\x17GetLockWaitInfoResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x120\n" +
	"\aentries\x18\x03 \x03(\v2\x16.deadlock.WaitForEntryR\aentries\"G\n" +
	"\x19GetLockWaitHistoryRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\"\x97\x01\n" +
	"\x1aGetLockWaitHistoryResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x120\n" +
	"\aentries\x18\x03 \x03(\v2\x16.deadlock.WaitForEntryR\aentries\"\xc9\x01\n" +
	"\x15RawCoprocessorRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x1b\n" +
	"\tcopr_name\x18\x02 \x01(\tR\bcoprName\x12(\n" +
	"\x10copr_version_req\x18\x03 \x01(\tR\x0ecoprVersionReq\x12)\n" +
	"\x06ranges\x18\x04 \x03(\v2\x11.kvrpcpb.KeyRangeR\x06ranges\x12\x12\n" +
	"\x04data\x18\x05 \x01(\fR\x04data\"u\n" +
	"\x16RawCoprocessorResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\"\xa5\x01\n" +
	"\x12RawChecksumRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x128\n" +
	"\talgorithm\x18\x02 \x01(\x0e2\x1a.kvrpcpb.ChecksumAlgorithmR\talgorithm\x12)\n" +
	"\x06ranges\x18\x03 \x03(\v2\x11.kvrpcpb.KeyRangeR\x06ranges\"\xb8\x01\n" +
	"\x13RawChecksumResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x1a\n" +
	"\bchecksum\x18\x03 \x01(\x04R\bchecksum\x12\x1b\n" +
	"\ttotal_kvs\x18\x04 \x01(\x04R\btotalKvs\x12\x1f\n" +
	"\vtotal_bytes\x18\x05 \x01(\x04R\n" +
	"totalBytes\"\xa9\x03\n" +
	"\fCompactError\x12Y\n" +
	"\x15err_invalid_start_key\x18\x01 \x01(\v2$.kvrpcpb.CompactErrorInvalidStartKeyH\x00R\x12errInvalidStartKey\x12l\n" +
	"\x1cerr_physical_table_not_exist\x18\x02 \x01(\v2*.kvrpcpb.CompactErrorPhysicalTableNotExistH\x00R\x18errPhysicalTableNotExist\x12_\n" +
	"\x17err_compact_in_progress\x18\x03 \x01(\v2&.kvrpcpb.CompactErrorCompactInProgressH\x00R\x14errCompactInProgress\x12f\n" +
	"\x1aerr_too_many_pending_tasks\x18\x04 \x01(\v2(.kvrpcpb.CompactErrorTooManyPendingTasksH\x00R\x16errTooManyPendingTasksB\a\n" +
	"\x05error\"\x1d\n" +
	"\x1bCompactErrorInvalidStartKey\"#\n" +
	"!CompactErrorPhysicalTableNotExist\"\x1f\n" +
	"\x1dCompactErrorCompactInProgress\"!\n" +
	"\x1fCompactErrorTooManyPendingTasks\"\xda\x01\n" +
	"\x0eCompactRequest\x12\x1b\n" +
	"\tstart_key\x18\x01 \x01(\fR\bstartKey\x12*\n" +
	"\x11physical_table_id\x18\x02 \x01(\x03R\x0fphysicalTableId\x12(\n" +
	"\x10logical_table_id\x18\x03 \x01(\x03R\x0elogicalTableId\x124\n" +
	"\vapi_version\x18\a \x01(\x0e2\x13.kvrpcpb.APIVersionR\n" +
	"apiVersion\x12\x1f\n" +
	"\vkeyspace_id\x18\b \x01(\rR\n" +
	"keyspaceId\"\xbf\x01\n" +
	"\x0fCompactResponse\x12+\n" +
	"\x05error\x18\x01 \x01(\v2\x15.kvrpcpb.CompactErrorR\x05error\x12#\n" +
	"\rhas_remaining\x18\x02 \x01(\bR\fhasRemaining\x12.\n" +
	"\x13compacted_start_key\x18\x03 \x01(\fR\x11compactedStartKey\x12*\n" +
	"\x11compacted_end_key\x18\x04 \x01(\fR\x0fcompactedEndKey\"-\n" +
	"\x19TiFlashSystemTableRequest\x12\x10\n" +
	"\x03sql\x18\x01 \x01(\tR\x03sql\"\x1c\n" +
	"\x1aTiFlashSystemTableResponse\"\xc8\x02\n" +
	"\fFlushRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12/\n" +
	"\tmutations\x18\x02 \x03(\v2\x11.kvrpcpb.MutationR\tmutations\x12\x1f\n" +
	"\vprimary_key\x18\x03 \x01(\fR\n" +
	"primaryKey\x12\x19\n" +
	"\bstart_ts\x18\x04 \x01(\x04R\astartTs\x12\"\n" +
	"\rmin_commit_ts\x18\x05 \x01(\x04R\vminCommitTs\x12\x1e\n" +
	"\n" +
	"generation\x18\x06 \x01(\x04R\n" +
	"generation\x12\x19\n" +
	"\block_ttl\x18\a \x01(\x04R\alockTtl\x12@\n" +
	"\x0fassertion_level\x18\b \x01(\x0e2\x17.kvrpcpb.AssertionLevelR\x0eassertionLevel\"\xad\x01\n" +
	"\rFlushResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12)\n" +
	"\x06errors\x18\x02 \x03(\v2\x11.kvrpcpb.KeyErrorR\x06errors\x12>\n" +
	"\x0fexec_details_v2\x18\x03 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"q\n" +
	"\x15BufferBatchGetRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x12\x12\n" +
	"\x04keys\x18\x02 \x03(\fR\x04keys\x12\x18\n" +
	"\aversion\x18\x03 \x01(\x04R\aversion\"\xdb\x01\n" +
	"\x16BufferBatchGetResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12'\n" +
	"\x05error\x18\x02 \x01(\v2\x11.kvrpcpb.KeyErrorR\x05error\x12%\n" +
	"\x05pairs\x18\x03 \x03(\v2\x0f.kvrpcpb.KvPairR\x05pairs\x12>\n" +
	"\x0fexec_details_v2\x18\x04 \x01(\v2\x16.kvrpcpb.ExecDetailsV2R\rexecDetailsV2\"F\n" +
	"\x18GetHealthFeedbackRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\"\x90\x01\n" +
	"\x19GetHealthFeedbackResponse\x121\n" +
	"\fregion_error\x18\x01 \x01(\v2\x0e.errorpb.ErrorR\vregionError\x12@\n" +
	"\x0fhealth_feedback\x18\x02 \x01(\v2\x17.kvrpcpb.HealthFeedbackR\x0ehealthFeedback\"r\n" +
	"\x0eHealthFeedback\x12\x19\n" +
	"\bstore_id\x18\x01 \x01(\x04R\astoreId\x12&\n" +
	"\x0ffeedback_seq_no\x18\x02 \x01(\x04R\rfeedbackSeqNo\x12\x1d\n" +
	"\n" +
	"slow_score\x18\x03 \x01(\x05R\tslowScore\"z\n" +
	"\x19BroadcastTxnStatusRequest\x12*\n" +
	"\acontext\x18\x01 \x01(\v2\x10.kvrpcpb.ContextR\acontext\x121\n" +
	"\n" +
	"txn_status\x18\x02 \x03(\v2\x12.kvrpcpb.TxnStatusR\ttxnStatus\"\xab\x01\n" +
	"\tTxnStatus\x12\x19\n" +
	"\bstart_ts\x18\x01 \x01(\x04R\astartTs\x12\"\n" +
	"\rmin_commit_ts\x18\x02 \x01(\x04R\vminCommitTs\x12\x1b\n" +
	"\tcommit_ts\x18\x03 \x01(\x04R\bcommitTs\x12\x1f\n" +
	"\vrolled_back\x18\x04 \x01(\bR\n" +
	"rolledBack\x12!\n" +
	"\fis_completed\x18\x05 \x01(\bR\visCompleted\"\x1c\n" +
	"\x1aBroadcastTxnStatusResponse*J\n" +
	"\x19PessimisticLockWakeUpMode\x12\x14\n" +
	"\x10WakeUpModeNormal\x10\x00\x12\x17\n" +
	"\x13WakeUpModeForceLock\x10\x01*l\n" +
	"\x1cPessimisticLockKeyResultType\x12\x14\n" +
	"\x10LockResultNormal\x10\x00\x12 \n" +
	"\x1cLockResultLockedWithConflict\x10\x01\x12\x14\n" +
	"\x10LockResultFailed\x10\x02*5\n" +
	"\n" +
	"CommitRole\x12\v\n" +
	"\aUnknown\x10\x00\x12\v\n" +
	"\aPrimary\x10\x01\x12\r\n" +
	"\tSecondary\x10\x02*'\n" +
	"\n" +
	"APIVersion\x12\x06\n" +
	"\x02V1\x10\x00\x12\t\n" +
	"\x05V1TTL\x10\x01\x12\x06\n" +
	"\x02V2\x10\x02*+\n" +
	"\n" +
	"CommandPri\x12\n" +
	"\n" +
	"\x06Normal\x10\x00\x12\a\n" +
	"\x03Low\x10\x01\x12\b\n" +
	"\x04High\x10\x02*/\n" +
	"\x0eIsolationLevel\x12\x06\n" +
	"\x02SI\x10\x00\x12\x06\n" +
	"\x02RC\x10\x01\x12\r\n" +
	"\tRCCheckTS\x10\x02*V\n" +
	"\vDiskFullOpt\x12\x14\n" +
	"\x10NotAllowedOnFull\x10\x00\x12\x17\n" +
	"\x13AllowedOnAlmostFull\x10\x01\x12\x18\n" +
	"\x14AllowedOnAlreadyFull\x10\x02*\x8e\x01\n" +
	"\x02Op\x12\a\n" +
	"\x03Put\x10\x00\x12\a\n" +
	"\x03Del\x10\x01\x12\b\n" +
	"\x04Lock\x10\x02\x12\f\n" +
	"\bRollback\x10\x03\x12\n" +
	"\n" +
	"\x06Insert\x10\x04\x12\x13\n" +
	"\x0fPessimisticLock\x10\x05\x12\x12\n" +
	"\x0eCheckNotExists\x10\x06\x12\x0e\n" +
	"\n" +
	"SharedLock\x10\a\x12\x19\n" +
	"\x15SharedPessimisticLock\x10\b*.\n" +
	"\tAssertion\x12\b\n" +
	"\x04None\x10\x00\x12\t\n" +
	"\x05Exist\x10\x01\x12\f\n" +
	"\bNotExist\x10\x02*/\n" +
	"\x0eAssertionLevel\x12\a\n" +
	"\x03Off\x10\x00\x12\b\n" +
	"\x04Fast\x10\x01\x12\n" +
	"\n" +
	"\x06Strict\x10\x02*\x9b\x01\n" +
	"\x06Action\x12\f\n" +
	"\bNoAction\x10\x00\x12\x15\n" +
	"\x11TTLExpireRollback\x10\x01\x12\x18\n" +
	"\x14LockNotExistRollback\x10\x02\x12\x15\n" +
	"\x11MinCommitTSPushed\x10\x03\x12 \n" +
	"\x1cTTLExpirePessimisticRollback\x10\x04\x12\x19\n" +
	"\x15LockNotExistDoNothing\x10\x05*%\n" +
	"\aExtraOp\x12\b\n" +
	"\x04Noop\x10\x00\x12\x10\n" +
	"\fReadOldValue\x10\x01*\"\n" +
	"\x11ChecksumAlgorithm\x12\r\n" +
	"\tCrc64_Xor\x10\x00B\x16\b\x01\n" +
	"\x10org.tikv.kvprotob\x06proto3"

var (
	file_kvrpcpb_proto_rawDescOnce sync.Once
	file_kvrpcpb_proto_rawDescData []byte
)

func file_kvrpcpb_proto_rawDescGZIP() []byte {
	file_kvrpcpb_proto_rawDescOnce.Do(func() {
		file_kvrpcpb_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_kvrpcpb_proto_rawDesc), len(file_kvrpcpb_proto_rawDesc)))
	})
	return file_kvrpcpb_proto_rawDescData
}

var file_kvrpcpb_proto_enumTypes = make([]protoimpl.EnumInfo, 15)
var file_kvrpcpb_proto_msgTypes = make([]protoimpl.MessageInfo, 145)
var file_kvrpcpb_proto_goTypes = []any{
	(PessimisticLockWakeUpMode)(0),                // 0: kvrpcpb.PessimisticLockWakeUpMode
	(PessimisticLockKeyResultType)(0),             // 1: kvrpcpb.PessimisticLockKeyResultType
	(CommitRole)(0),                               // 2: kvrpcpb.CommitRole
	(APIVersion)(0),                               // 3: kvrpcpb.APIVersion
	(CommandPri)(0),                               // 4: kvrpcpb.CommandPri
	(IsolationLevel)(0),                           // 5: kvrpcpb.IsolationLevel
	(DiskFullOpt)(0),                              // 6: kvrpcpb.DiskFullOpt
	(Op)(0),                                       // 7: kvrpcpb.Op
	(Assertion)(0),                                // 8: kvrpcpb.Assertion
	(AssertionLevel)(0),                           // 9: kvrpcpb.AssertionLevel
	(Action)(0),                                   // 10: kvrpcpb.Action
	(ExtraOp)(0),                                  // 11: kvrpcpb.ExtraOp
	(ChecksumAlgorithm)(0),                        // 12: kvrpcpb.ChecksumAlgorithm
	(PrewriteRequest_PessimisticAction)(0),        // 13: kvrpcpb.PrewriteRequest.PessimisticAction
	(WriteConflict_Reason)(0),                     // 14: kvrpcpb.WriteConflict.Reason
	(*GetRequest)(nil),                            // 15: kvrpcpb.GetRequest
	(*GetResponse)(nil),                           // 16: kvrpcpb.GetResponse
	(*ScanRequest)(nil),                           // 17: kvrpcpb.ScanRequest
	(*ScanResponse)(nil),                          // 18: kvrpcpb.ScanResponse
	(*PrewriteRequest)(nil),                       // 19: kvrpcpb.PrewriteRequest
	(*PrewriteResponse)(nil),                      // 20: kvrpcpb.PrewriteResponse
	(*PessimisticLockRequest)(nil),                // 21: kvrpcpb.PessimisticLockRequest
	(*PessimisticLockKeyResult)(nil),              // 22: kvrpcpb.PessimisticLockKeyResult
	(*PessimisticLockResponse)(nil),               // 23: kvrpcpb.PessimisticLockResponse
	(*PessimisticRollbackRequest)(nil),            // 24: kvrpcpb.PessimisticRollbackRequest
	(*PessimisticRollbackResponse)(nil),           // 25: kvrpcpb.PessimisticRollbackResponse
	(*TxnHeartBeatRequest)(nil),                   // 26: kvrpcpb.TxnHeartBeatRequest
	(*TxnHeartBeatResponse)(nil),                  // 27: kvrpcpb.TxnHeartBeatResponse
	(*CheckTxnStatusRequest)(nil),                 // 28: kvrpcpb.CheckTxnStatusRequest
	(*CheckTxnStatusResponse)(nil),                // 29: kvrpcpb.CheckTxnStatusResponse
	(*CheckSecondaryLocksRequest)(nil),            // 30: kvrpcpb.CheckSecondaryLocksRequest
	(*CheckSecondaryLocksResponse)(nil),           // 31: kvrpcpb.CheckSecondaryLocksResponse
	(*CommitRequest)(nil),                         // 32: kvrpcpb.CommitRequest
	(*CommitResponse)(nil),                        // 33: kvrpcpb.CommitResponse
	(*ImportRequest)(nil),                         // 34: kvrpcpb.ImportRequest
	(*ImportResponse)(nil),                        // 35: kvrpcpb.ImportResponse
	(*CleanupRequest)(nil),                        // 36: kvrpcpb.CleanupRequest
	(*CleanupResponse)(nil),                       // 37: kvrpcpb.CleanupResponse
	(*BatchGetRequest)(nil),                       // 38: kvrpcpb.BatchGetRequest
	(*BatchGetResponse)(nil),                      // 39: kvrpcpb.BatchGetResponse
	(*BatchRollbackRequest)(nil),                  // 40: kvrpcpb.BatchRollbackRequest
	(*BatchRollbackResponse)(nil),                 // 41: kvrpcpb.BatchRollbackResponse
	(*ScanLockRequest)(nil),                       // 42: kvrpcpb.ScanLockRequest
	(*ScanLockResponse)(nil),                      // 43: kvrpcpb.ScanLockResponse
	(*ResolveLockRequest)(nil),                    // 44: kvrpcpb.ResolveLockRequest
	(*ResolveLockResponse)(nil),                   // 45: kvrpcpb.ResolveLockResponse
	(*GCRequest)(nil),                             // 46: kvrpcpb.GCRequest
	(*GCResponse)(nil),                            // 47: kvrpcpb.GCResponse
	(*DeleteRangeRequest)(nil),                    // 48: kvrpcpb.DeleteRangeRequest
	(*DeleteRangeResponse)(nil),                   // 49: kvrpcpb.DeleteRangeResponse
	(*PrepareFlashbackToVersionRequest)(nil),      // 50: kvrpcpb.PrepareFlashbackToVersionRequest
	(*PrepareFlashbackToVersionResponse)(nil),     // 51: kvrpcpb.PrepareFlashbackToVersionResponse
	(*FlashbackToVersionRequest)(nil),             // 52: kvrpcpb.FlashbackToVersionRequest
	(*FlashbackToVersionResponse)(nil),            // 53: kvrpcpb.FlashbackToVersionResponse
	(*RawGetRequest)(nil),                         // 54: kvrpcpb.RawGetRequest
	(*RawGetResponse)(nil),                        // 55: kvrpcpb.RawGetResponse
	(*RawBatchGetRequest)(nil),                    // 56: kvrpcpb.RawBatchGetRequest
	(*RawBatchGetResponse)(nil),                   // 57: kvrpcpb.RawBatchGetResponse
	(*RawPutRequest)(nil),                         // 58: kvrpcpb.RawPutRequest
	(*RawPutResponse)(nil),                        // 59: kvrpcpb.RawPutResponse
	(*RawBatchPutRequest)(nil),                    // 60: kvrpcpb.RawBatchPutRequest
	(*RawBatchPutResponse)(nil),                   // 61: kvrpcpb.RawBatchPutResponse
	(*RawDeleteRequest)(nil),                      // 62: kvrpcpb.RawDeleteRequest
	(*RawDeleteResponse)(nil),                     // 63: kvrpcpb.RawDeleteResponse
	(*RawBatchDeleteRequest)(nil),                 // 64: kvrpcpb.RawBatchDeleteRequest
	(*RawBatchDeleteResponse)(nil),                // 65: kvrpcpb.RawBatchDeleteResponse
	(*RawScanRequest)(nil),                        // 66: kvrpcpb.RawScanRequest
	(*RawScanResponse)(nil),                       // 67: kvrpcpb.RawScanResponse
	(*RawDeleteRangeRequest)(nil),                 // 68: kvrpcpb.RawDeleteRangeRequest
	(*RawDeleteRangeResponse)(nil),                // 69: kvrpcpb.RawDeleteRangeResponse
	(*RawBatchScanRequest)(nil),                   // 70: kvrpcpb.RawBatchScanRequest
	(*RawBatchScanResponse)(nil),                  // 71: kvrpcpb.RawBatchScanResponse
	(*UnsafeDestroyRangeRequest)(nil),             // 72: kvrpcpb.UnsafeDestroyRangeRequest
	(*UnsafeDestroyRangeResponse)(nil),            // 73: kvrpcpb.UnsafeDestroyRangeResponse
	(*RegisterLockObserverRequest)(nil),           // 74: kvrpcpb.RegisterLockObserverRequest
	(*RegisterLockObserverResponse)(nil),          // 75: kvrpcpb.RegisterLockObserverResponse
	(*CheckLockObserverRequest)(nil),              // 76: kvrpcpb.CheckLockObserverRequest
	(*CheckLockObserverResponse)(nil),             // 77: kvrpcpb.CheckLockObserverResponse
	(*RemoveLockObserverRequest)(nil),             // 78: kvrpcpb.RemoveLockObserverRequest
	(*RemoveLockObserverResponse)(nil),            // 79: kvrpcpb.RemoveLockObserverResponse
	(*PhysicalScanLockRequest)(nil),               // 80: kvrpcpb.PhysicalScanLockRequest
	(*PhysicalScanLockResponse)(nil),              // 81: kvrpcpb.PhysicalScanLockResponse
	(*SplitRegionRequest)(nil),                    // 82: kvrpcpb.SplitRegionRequest
	(*SplitRegionResponse)(nil),                   // 83: kvrpcpb.SplitRegionResponse
	(*ReadIndexRequest)(nil),                      // 84: kvrpcpb.ReadIndexRequest
	(*ReadIndexResponse)(nil),                     // 85: kvrpcpb.ReadIndexResponse
	(*MvccGetByKeyRequest)(nil),                   // 86: kvrpcpb.MvccGetByKeyRequest
	(*MvccGetByKeyResponse)(nil),                  // 87: kvrpcpb.MvccGetByKeyResponse
	(*MvccGetByStartTsRequest)(nil),               // 88: kvrpcpb.MvccGetByStartTsRequest
	(*MvccGetByStartTsResponse)(nil),              // 89: kvrpcpb.MvccGetByStartTsResponse
	(*Context)(nil),                               // 90: kvrpcpb.Context
	(*ResourceControlContext)(nil),                // 91: kvrpcpb.ResourceControlContext
	(*SourceStmt)(nil),                            // 92: kvrpcpb.SourceStmt
	(*LockInfo)(nil),                              // 93: kvrpcpb.LockInfo
	(*KeyError)(nil),                              // 94: kvrpcpb.KeyError
	(*WriteConflict)(nil),                         // 95: kvrpcpb.WriteConflict
	(*AlreadyExist)(nil),                          // 96: kvrpcpb.AlreadyExist
	(*Deadlock)(nil),                              // 97: kvrpcpb.Deadlock
	(*CommitTsExpired)(nil),                       // 98: kvrpcpb.CommitTsExpired
	(*TxnNotFound)(nil),                           // 99: kvrpcpb.TxnNotFound
	(*CommitTsTooLarge)(nil),                      // 100: kvrpcpb.CommitTsTooLarge
	(*AssertionFailed)(nil),                       // 101: kvrpcpb.AssertionFailed
	(*PrimaryMismatch)(nil),                       // 102: kvrpcpb.PrimaryMismatch
	(*TxnLockNotFound)(nil),                       // 103: kvrpcpb.TxnLockNotFound
	(*MvccDebugInfo)(nil),                         // 104: kvrpcpb.MvccDebugInfo
	(*DebugInfo)(nil),                             // 105: kvrpcpb.DebugInfo
	(*TimeDetail)(nil),                            // 106: kvrpcpb.TimeDetail
	(*TimeDetailV2)(nil),                          // 107: kvrpcpb.TimeDetailV2
	(*ScanInfo)(nil),                              // 108: kvrpcpb.ScanInfo
	(*ScanDetail)(nil),                            // 109: kvrpcpb.ScanDetail
	(*ScanDetailV2)(nil),                          // 110: kvrpcpb.ScanDetailV2
	(*ExecDetails)(nil),                           // 111: kvrpcpb.ExecDetails
	(*ExecDetailsV2)(nil),                         // 112: kvrpcpb.ExecDetailsV2
	(*WriteDetail)(nil),                           // 113: kvrpcpb.WriteDetail
	(*KvPair)(nil),                                // 114: kvrpcpb.KvPair
	(*Mutation)(nil),                              // 115: kvrpcpb.Mutation
	(*MvccWrite)(nil),                             // 116: kvrpcpb.MvccWrite
	(*MvccValue)(nil),                             // 117: kvrpcpb.MvccValue
	(*MvccLock)(nil),                              // 118: kvrpcpb.MvccLock
	(*MvccInfo)(nil),                              // 119: kvrpcpb.MvccInfo
	(*TxnInfo)(nil),                               // 120: kvrpcpb.TxnInfo
	(*KeyRange)(nil),                              // 121: kvrpcpb.KeyRange
	(*LeaderInfo)(nil),                            // 122: kvrpcpb.LeaderInfo
	(*ReadState)(nil),                             // 123: kvrpcpb.ReadState
	(*CheckLeaderRequest)(nil),                    // 124: kvrpcpb.CheckLeaderRequest
	(*CheckLeaderResponse)(nil),                   // 125: kvrpcpb.CheckLeaderResponse
	(*StoreSafeTSRequest)(nil),                    // 126: kvrpcpb.StoreSafeTSRequest
	(*StoreSafeTSResponse)(nil),                   // 127: kvrpcpb.StoreSafeTSResponse
	(*RawGetKeyTTLRequest)(nil),                   // 128: kvrpcpb.RawGetKeyTTLRequest
	(*RawGetKeyTTLResponse)(nil),                  // 129: kvrpcpb.RawGetKeyTTLResponse
	(*RawCASRequest)(nil),                         // 130: kvrpcpb.RawCASRequest
	(*RawCASResponse)(nil),                        // 131: kvrpcpb.RawCASResponse
	(*GetLockWaitInfoRequest)(nil),                // 132: kvrpcpb.GetLockWaitInfoRequest
	(*GetLockWaitInfoResponse)(nil),               // 133: kvrpcpb.GetLockWaitInfoResponse
	(*GetLockWaitHistoryRequest)(nil),             // 134: kvrpcpb.GetLockWaitHistoryRequest
	(*GetLockWaitHistoryResponse)(nil),            // 135: kvrpcpb.GetLockWaitHistoryResponse
	(*RawCoprocessorRequest)(nil),                 // 136: kvrpcpb.RawCoprocessorRequest
	(*RawCoprocessorResponse)(nil),                // 137: kvrpcpb.RawCoprocessorResponse
	(*RawChecksumRequest)(nil),                    // 138: kvrpcpb.RawChecksumRequest
	(*RawChecksumResponse)(nil),                   // 139: kvrpcpb.RawChecksumResponse
	(*CompactError)(nil),                          // 140: kvrpcpb.CompactError
	(*CompactErrorInvalidStartKey)(nil),           // 141: kvrpcpb.CompactErrorInvalidStartKey
	(*CompactErrorPhysicalTableNotExist)(nil),     // 142: kvrpcpb.CompactErrorPhysicalTableNotExist
	(*CompactErrorCompactInProgress)(nil),         // 143: kvrpcpb.CompactErrorCompactInProgress
	(*CompactErrorTooManyPendingTasks)(nil),       // 144: kvrpcpb.CompactErrorTooManyPendingTasks
	(*CompactRequest)(nil),                        // 145: kvrpcpb.CompactRequest
	(*CompactResponse)(nil),                       // 146: kvrpcpb.CompactResponse
	(*TiFlashSystemTableRequest)(nil),             // 147: kvrpcpb.TiFlashSystemTableRequest
	(*TiFlashSystemTableResponse)(nil),            // 148: kvrpcpb.TiFlashSystemTableResponse
	(*FlushRequest)(nil),                          // 149: kvrpcpb.FlushRequest
	(*FlushResponse)(nil),                         // 150: kvrpcpb.FlushResponse
	(*BufferBatchGetRequest)(nil),                 // 151: kvrpcpb.BufferBatchGetRequest
	(*BufferBatchGetResponse)(nil),                // 152: kvrpcpb.BufferBatchGetResponse
	(*GetHealthFeedbackRequest)(nil),              // 153: kvrpcpb.GetHealthFeedbackRequest
	(*GetHealthFeedbackResponse)(nil),             // 154: kvrpcpb.GetHealthFeedbackResponse
	(*HealthFeedback)(nil),                        // 155: kvrpcpb.HealthFeedback
	(*BroadcastTxnStatusRequest)(nil),             // 156: kvrpcpb.BroadcastTxnStatusRequest
	(*TxnStatus)(nil),                             // 157: kvrpcpb.TxnStatus
	(*BroadcastTxnStatusResponse)(nil),            // 158: kvrpcpb.BroadcastTxnStatusResponse
	(*PrewriteRequest_ForUpdateTSConstraint)(nil), // 159: kvrpcpb.PrewriteRequest.ForUpdateTSConstraint
	(*errorpb.Error)(nil),                         // 160: errorpb.Error
	(*metapb.Region)(nil),                         // 161: metapb.Region
	(*metapb.RegionEpoch)(nil),                    // 162: metapb.RegionEpoch
	(*metapb.Peer)(nil),                           // 163: metapb.Peer
	(*tracepb.TraceContext)(nil),                  // 164: tracepb.TraceContext
	(*resource_manager.Consumption)(nil),          // 165: resource_manager.Consumption
	(*deadlock.WaitForEntry)(nil),                 // 166: deadlock.WaitForEntry
}
var file_kvrpcpb_proto_depIdxs = []int32{
	90,  // 0: kvrpcpb.GetRequest.context:type_name -> kvrpcpb.Context
	160, // 1: kvrpcpb.GetResponse.region_error:type_name -> errorpb.Error
	94,  // 2: kvrpcpb.GetResponse.error:type_name -> kvrpcpb.KeyError
	112, // 3: kvrpcpb.GetResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 4: kvrpcpb.ScanRequest.context:type_name -> kvrpcpb.Context
	160, // 5: kvrpcpb.ScanResponse.region_error:type_name -> errorpb.Error
	114, // 6: kvrpcpb.ScanResponse.pairs:type_name -> kvrpcpb.KvPair
	94,  // 7: kvrpcpb.ScanResponse.error:type_name -> kvrpcpb.KeyError
	90,  // 8: kvrpcpb.PrewriteRequest.context:type_name -> kvrpcpb.Context
	115, // 9: kvrpcpb.PrewriteRequest.mutations:type_name -> kvrpcpb.Mutation
	13,  // 10: kvrpcpb.PrewriteRequest.pessimistic_actions:type_name -> kvrpcpb.PrewriteRequest.PessimisticAction
	9,   // 11: kvrpcpb.PrewriteRequest.assertion_level:type_name -> kvrpcpb.AssertionLevel
	159, // 12: kvrpcpb.PrewriteRequest.for_update_ts_constraints:type_name -> kvrpcpb.PrewriteRequest.ForUpdateTSConstraint
	160, // 13: kvrpcpb.PrewriteResponse.region_error:type_name -> errorpb.Error
	94,  // 14: kvrpcpb.PrewriteResponse.errors:type_name -> kvrpcpb.KeyError
	112, // 15: kvrpcpb.PrewriteResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 16: kvrpcpb.PessimisticLockRequest.context:type_name -> kvrpcpb.Context
	115, // 17: kvrpcpb.PessimisticLockRequest.mutations:type_name -> kvrpcpb.Mutation
	0,   // 18: kvrpcpb.PessimisticLockRequest.wake_up_mode:type_name -> kvrpcpb.PessimisticLockWakeUpMode
	1,   // 19: kvrpcpb.PessimisticLockKeyResult.type:type_name -> kvrpcpb.PessimisticLockKeyResultType
	160, // 20: kvrpcpb.PessimisticLockResponse.region_error:type_name -> errorpb.Error
	94,  // 21: kvrpcpb.PessimisticLockResponse.errors:type_name -> kvrpcpb.KeyError
	112, // 22: kvrpcpb.PessimisticLockResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	22,  // 23: kvrpcpb.PessimisticLockResponse.results:type_name -> kvrpcpb.PessimisticLockKeyResult
	90,  // 24: kvrpcpb.PessimisticRollbackRequest.context:type_name -> kvrpcpb.Context
	160, // 25: kvrpcpb.PessimisticRollbackResponse.region_error:type_name -> errorpb.Error
	94,  // 26: kvrpcpb.PessimisticRollbackResponse.errors:type_name -> kvrpcpb.KeyError
	112, // 27: kvrpcpb.PessimisticRollbackResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 28: kvrpcpb.TxnHeartBeatRequest.context:type_name -> kvrpcpb.Context
	160, // 29: kvrpcpb.TxnHeartBeatResponse.region_error:type_name -> errorpb.Error
	94,  // 30: kvrpcpb.TxnHeartBeatResponse.error:type_name -> kvrpcpb.KeyError
	112, // 31: kvrpcpb.TxnHeartBeatResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 32: kvrpcpb.CheckTxnStatusRequest.context:type_name -> kvrpcpb.Context
	160, // 33: kvrpcpb.CheckTxnStatusResponse.region_error:type_name -> errorpb.Error
	94,  // 34: kvrpcpb.CheckTxnStatusResponse.error:type_name -> kvrpcpb.KeyError
	10,  // 35: kvrpcpb.CheckTxnStatusResponse.action:type_name -> kvrpcpb.Action
	93,  // 36: kvrpcpb.CheckTxnStatusResponse.lock_info:type_name -> kvrpcpb.LockInfo
	112, // 37: kvrpcpb.CheckTxnStatusResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 38: kvrpcpb.CheckSecondaryLocksRequest.context:type_name -> kvrpcpb.Context
	160, // 39: kvrpcpb.CheckSecondaryLocksResponse.region_error:type_name -> errorpb.Error
	94,  // 40: kvrpcpb.CheckSecondaryLocksResponse.error:type_name -> kvrpcpb.KeyError
	93,  // 41: kvrpcpb.CheckSecondaryLocksResponse.locks:type_name -> kvrpcpb.LockInfo
	112, // 42: kvrpcpb.CheckSecondaryLocksResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 43: kvrpcpb.CommitRequest.context:type_name -> kvrpcpb.Context
	2,   // 44: kvrpcpb.CommitRequest.commit_role:type_name -> kvrpcpb.CommitRole
	160, // 45: kvrpcpb.CommitResponse.region_error:type_name -> errorpb.Error
	94,  // 46: kvrpcpb.CommitResponse.error:type_name -> kvrpcpb.KeyError
	112, // 47: kvrpcpb.CommitResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	115, // 48: kvrpcpb.ImportRequest.mutations:type_name -> kvrpcpb.Mutation
	160, // 49: kvrpcpb.ImportResponse.region_error:type_name -> errorpb.Error
	90,  // 50: kvrpcpb.CleanupRequest.context:type_name -> kvrpcpb.Context
	160, // 51: kvrpcpb.CleanupResponse.region_error:type_name -> errorpb.Error
	94,  // 52: kvrpcpb.CleanupResponse.error:type_name -> kvrpcpb.KeyError
	90,  // 53: kvrpcpb.BatchGetRequest.context:type_name -> kvrpcpb.Context
	160, // 54: kvrpcpb.BatchGetResponse.region_error:type_name -> errorpb.Error
	114, // 55: kvrpcpb.BatchGetResponse.pairs:type_name -> kvrpcpb.KvPair
	112, // 56: kvrpcpb.BatchGetResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	94,  // 57: kvrpcpb.BatchGetResponse.error:type_name -> kvrpcpb.KeyError
	90,  // 58: kvrpcpb.BatchRollbackRequest.context:type_name -> kvrpcpb.Context
	160, // 59: kvrpcpb.BatchRollbackResponse.region_error:type_name -> errorpb.Error
	94,  // 60: kvrpcpb.BatchRollbackResponse.error:type_name -> kvrpcpb.KeyError
	112, // 61: kvrpcpb.BatchRollbackResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 62: kvrpcpb.ScanLockRequest.context:type_name -> kvrpcpb.Context
	160, // 63: kvrpcpb.ScanLockResponse.region_error:type_name -> errorpb.Error
	94,  // 64: kvrpcpb.ScanLockResponse.error:type_name -> kvrpcpb.KeyError
	93,  // 65: kvrpcpb.ScanLockResponse.locks:type_name -> kvrpcpb.LockInfo
	112, // 66: kvrpcpb.ScanLockResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 67: kvrpcpb.ResolveLockRequest.context:type_name -> kvrpcpb.Context
	120, // 68: kvrpcpb.ResolveLockRequest.txn_infos:type_name -> kvrpcpb.TxnInfo
	160, // 69: kvrpcpb.ResolveLockResponse.region_error:type_name -> errorpb.Error
	94,  // 70: kvrpcpb.ResolveLockResponse.error:type_name -> kvrpcpb.KeyError
	112, // 71: kvrpcpb.ResolveLockResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 72: kvrpcpb.GCRequest.context:type_name -> kvrpcpb.Context
	160, // 73: kvrpcpb.GCResponse.region_error:type_name -> errorpb.Error
	94,  // 74: kvrpcpb.GCResponse.error:type_name -> kvrpcpb.KeyError
	90,  // 75: kvrpcpb.DeleteRangeRequest.context:type_name -> kvrpcpb.Context
	160, // 76: kvrpcpb.DeleteRangeResponse.region_error:type_name -> errorpb.Error
	90,  // 77: kvrpcpb.PrepareFlashbackToVersionRequest.context:type_name -> kvrpcpb.Context
	160, // 78: kvrpcpb.PrepareFlashbackToVersionResponse.region_error:type_name -> errorpb.Error
	90,  // 79: kvrpcpb.FlashbackToVersionRequest.context:type_name -> kvrpcpb.Context
	160, // 80: kvrpcpb.FlashbackToVersionResponse.region_error:type_name -> errorpb.Error
	90,  // 81: kvrpcpb.RawGetRequest.context:type_name -> kvrpcpb.Context
	160, // 82: kvrpcpb.RawGetResponse.region_error:type_name -> errorpb.Error
	90,  // 83: kvrpcpb.RawBatchGetRequest.context:type_name -> kvrpcpb.Context
	160, // 84: kvrpcpb.RawBatchGetResponse.region_error:type_name -> errorpb.Error
	114, // 85: kvrpcpb.RawBatchGetResponse.pairs:type_name -> kvrpcpb.KvPair
	90,  // 86: kvrpcpb.RawPutRequest.context:type_name -> kvrpcpb.Context
	160, // 87: kvrpcpb.RawPutResponse.region_error:type_name -> errorpb.Error
	90,  // 88: kvrpcpb.RawBatchPutRequest.context:type_name -> kvrpcpb.Context
	114, // 89: kvrpcpb.RawBatchPutRequest.pairs:type_name -> kvrpcpb.KvPair
	160, // 90: kvrpcpb.RawBatchPutResponse.region_error:type_name -> errorpb.Error
	90,  // 91: kvrpcpb.RawDeleteRequest.context:type_name -> kvrpcpb.Context
	160, // 92: kvrpcpb.RawDeleteResponse.region_error:type_name -> errorpb.Error
	90,  // 93: kvrpcpb.RawBatchDeleteRequest.context:type_name -> kvrpcpb.Context
	160, // 94: kvrpcpb.RawBatchDeleteResponse.region_error:type_name -> errorpb.Error
	90,  // 95: kvrpcpb.RawScanRequest.context:type_name -> kvrpcpb.Context
	160, // 96: kvrpcpb.RawScanResponse.region_error:type_name -> errorpb.Error
	114, // 97: kvrpcpb.RawScanResponse.kvs:type_name -> kvrpcpb.KvPair
	90,  // 98: kvrpcpb.RawDeleteRangeRequest.context:type_name -> kvrpcpb.Context
	160, // 99: kvrpcpb.RawDeleteRangeResponse.region_error:type_name -> errorpb.Error
	90,  // 100: kvrpcpb.RawBatchScanRequest.context:type_name -> kvrpcpb.Context
	121, // 101: kvrpcpb.RawBatchScanRequest.ranges:type_name -> kvrpcpb.KeyRange
	160, // 102: kvrpcpb.RawBatchScanResponse.region_error:type_name -> errorpb.Error
	114, // 103: kvrpcpb.RawBatchScanResponse.kvs:type_name -> kvrpcpb.KvPair
	90,  // 104: kvrpcpb.UnsafeDestroyRangeRequest.context:type_name -> kvrpcpb.Context
	160, // 105: kvrpcpb.UnsafeDestroyRangeResponse.region_error:type_name -> errorpb.Error
	90,  // 106: kvrpcpb.RegisterLockObserverRequest.context:type_name -> kvrpcpb.Context
	90,  // 107: kvrpcpb.CheckLockObserverRequest.context:type_name -> kvrpcpb.Context
	93,  // 108: kvrpcpb.CheckLockObserverResponse.locks:type_name -> kvrpcpb.LockInfo
	90,  // 109: kvrpcpb.RemoveLockObserverRequest.context:type_name -> kvrpcpb.Context
	90,  // 110: kvrpcpb.PhysicalScanLockRequest.context:type_name -> kvrpcpb.Context
	93,  // 111: kvrpcpb.PhysicalScanLockResponse.locks:type_name -> kvrpcpb.LockInfo
	90,  // 112: kvrpcpb.SplitRegionRequest.context:type_name -> kvrpcpb.Context
	160, // 113: kvrpcpb.SplitRegionResponse.region_error:type_name -> errorpb.Error
	161, // 114: kvrpcpb.SplitRegionResponse.left:type_name -> metapb.Region
	161, // 115: kvrpcpb.SplitRegionResponse.right:type_name -> metapb.Region
	161, // 116: kvrpcpb.SplitRegionResponse.regions:type_name -> metapb.Region
	94,  // 117: kvrpcpb.SplitRegionResponse.errors:type_name -> kvrpcpb.KeyError
	90,  // 118: kvrpcpb.ReadIndexRequest.context:type_name -> kvrpcpb.Context
	121, // 119: kvrpcpb.ReadIndexRequest.ranges:type_name -> kvrpcpb.KeyRange
	160, // 120: kvrpcpb.ReadIndexResponse.region_error:type_name -> errorpb.Error
	93,  // 121: kvrpcpb.ReadIndexResponse.locked:type_name -> kvrpcpb.LockInfo
	90,  // 122: kvrpcpb.MvccGetByKeyRequest.context:type_name -> kvrpcpb.Context
	160, // 123: kvrpcpb.MvccGetByKeyResponse.region_error:type_name -> errorpb.Error
	119, // 124: kvrpcpb.MvccGetByKeyResponse.info:type_name -> kvrpcpb.MvccInfo
	90,  // 125: kvrpcpb.MvccGetByStartTsRequest.context:type_name -> kvrpcpb.Context
	160, // 126: kvrpcpb.MvccGetByStartTsResponse.region_error:type_name -> errorpb.Error
	119, // 127: kvrpcpb.MvccGetByStartTsResponse.info:type_name -> kvrpcpb.MvccInfo
	162, // 128: kvrpcpb.Context.region_epoch:type_name -> metapb.RegionEpoch
	163, // 129: kvrpcpb.Context.peer:type_name -> metapb.Peer
	4,   // 130: kvrpcpb.Context.priority:type_name -> kvrpcpb.CommandPri
	5,   // 131: kvrpcpb.Context.isolation_level:type_name -> kvrpcpb.IsolationLevel
	6,   // 132: kvrpcpb.Context.disk_full_opt:type_name -> kvrpcpb.DiskFullOpt
	3,   // 133: kvrpcpb.Context.api_version:type_name -> kvrpcpb.APIVersion
	164, // 134: kvrpcpb.Context.trace_context:type_name -> tracepb.TraceContext
	91,  // 135: kvrpcpb.Context.resource_control_context:type_name -> kvrpcpb.ResourceControlContext
	92,  // 136: kvrpcpb.Context.source_stmt:type_name -> kvrpcpb.SourceStmt
	165, // 137: kvrpcpb.ResourceControlContext.penalty:type_name -> resource_manager.Consumption
	7,   // 138: kvrpcpb.LockInfo.lock_type:type_name -> kvrpcpb.Op
	93,  // 139: kvrpcpb.LockInfo.shared_lock_infos:type_name -> kvrpcpb.LockInfo
	93,  // 140: kvrpcpb.KeyError.locked:type_name -> kvrpcpb.LockInfo
	95,  // 141: kvrpcpb.KeyError.conflict:type_name -> kvrpcpb.WriteConflict
	96,  // 142: kvrpcpb.KeyError.already_exist:type_name -> kvrpcpb.AlreadyExist
	97,  // 143: kvrpcpb.KeyError.deadlock:type_name -> kvrpcpb.Deadlock
	98,  // 144: kvrpcpb.KeyError.commit_ts_expired:type_name -> kvrpcpb.CommitTsExpired
	99,  // 145: kvrpcpb.KeyError.txn_not_found:type_name -> kvrpcpb.TxnNotFound
	100, // 146: kvrpcpb.KeyError.commit_ts_too_large:type_name -> kvrpcpb.CommitTsTooLarge
	101, // 147: kvrpcpb.KeyError.assertion_failed:type_name -> kvrpcpb.AssertionFailed
	102, // 148: kvrpcpb.KeyError.primary_mismatch:type_name -> kvrpcpb.PrimaryMismatch
	103, // 149: kvrpcpb.KeyError.txn_lock_not_found:type_name -> kvrpcpb.TxnLockNotFound
	105, // 150: kvrpcpb.KeyError.debug_info:type_name -> kvrpcpb.DebugInfo
	14,  // 151: kvrpcpb.WriteConflict.reason:type_name -> kvrpcpb.WriteConflict.Reason
	166, // 152: kvrpcpb.Deadlock.wait_chain:type_name -> deadlock.WaitForEntry
	8,   // 153: kvrpcpb.AssertionFailed.assertion:type_name -> kvrpcpb.Assertion
	93,  // 154: kvrpcpb.PrimaryMismatch.lock_info:type_name -> kvrpcpb.LockInfo
	119, // 155: kvrpcpb.MvccDebugInfo.mvcc:type_name -> kvrpcpb.MvccInfo
	104, // 156: kvrpcpb.DebugInfo.mvcc_info:type_name -> kvrpcpb.MvccDebugInfo
	108, // 157: kvrpcpb.ScanDetail.write:type_name -> kvrpcpb.ScanInfo
	108, // 158: kvrpcpb.ScanDetail.lock:type_name -> kvrpcpb.ScanInfo
	108, // 159: kvrpcpb.ScanDetail.data:type_name -> kvrpcpb.ScanInfo
	106, // 160: kvrpcpb.ExecDetails.time_detail:type_name -> kvrpcpb.TimeDetail
	109, // 161: kvrpcpb.ExecDetails.scan_detail:type_name -> kvrpcpb.ScanDetail
	106, // 162: kvrpcpb.ExecDetailsV2.time_detail:type_name -> kvrpcpb.TimeDetail
	110, // 163: kvrpcpb.ExecDetailsV2.scan_detail_v2:type_name -> kvrpcpb.ScanDetailV2
	113, // 164: kvrpcpb.ExecDetailsV2.write_detail:type_name -> kvrpcpb.WriteDetail
	107, // 165: kvrpcpb.ExecDetailsV2.time_detail_v2:type_name -> kvrpcpb.TimeDetailV2
	94,  // 166: kvrpcpb.KvPair.error:type_name -> kvrpcpb.KeyError
	7,   // 167: kvrpcpb.Mutation.op:type_name -> kvrpcpb.Op
	8,   // 168: kvrpcpb.Mutation.assertion:type_name -> kvrpcpb.Assertion
	7,   // 169: kvrpcpb.MvccWrite.type:type_name -> kvrpcpb.Op
	7,   // 170: kvrpcpb.MvccLock.type:type_name -> kvrpcpb.Op
	118, // 171: kvrpcpb.MvccInfo.lock:type_name -> kvrpcpb.MvccLock
	116, // 172: kvrpcpb.MvccInfo.writes:type_name -> kvrpcpb.MvccWrite
	117, // 173: kvrpcpb.MvccInfo.values:type_name -> kvrpcpb.MvccValue
	162, // 174: kvrpcpb.LeaderInfo.region_epoch:type_name -> metapb.RegionEpoch
	123, // 175: kvrpcpb.LeaderInfo.read_state:type_name -> kvrpcpb.ReadState
	122, // 176: kvrpcpb.CheckLeaderRequest.regions:type_name -> kvrpcpb.LeaderInfo
	121, // 177: kvrpcpb.StoreSafeTSRequest.key_range:type_name -> kvrpcpb.KeyRange
	90,  // 178: kvrpcpb.RawGetKeyTTLRequest.context:type_name -> kvrpcpb.Context
	160, // 179: kvrpcpb.RawGetKeyTTLResponse.region_error:type_name -> errorpb.Error
	90,  // 180: kvrpcpb.RawCASRequest.context:type_name -> kvrpcpb.Context
	160, // 181: kvrpcpb.RawCASResponse.region_error:type_name -> errorpb.Error
	90,  // 182: kvrpcpb.GetLockWaitInfoRequest.context:type_name -> kvrpcpb.Context
	160, // 183: kvrpcpb.GetLockWaitInfoResponse.region_error:type_name -> errorpb.Error
	166, // 184: kvrpcpb.GetLockWaitInfoResponse.entries:type_name -> deadlock.WaitForEntry
	90,  // 185: kvrpcpb.GetLockWaitHistoryRequest.context:type_name -> kvrpcpb.Context
	160, // 186: kvrpcpb.GetLockWaitHistoryResponse.region_error:type_name -> errorpb.Error
	166, // 187: kvrpcpb.GetLockWaitHistoryResponse.entries:type_name -> deadlock.WaitForEntry
	90,  // 188: kvrpcpb.RawCoprocessorRequest.context:type_name -> kvrpcpb.Context
	121, // 189: kvrpcpb.RawCoprocessorRequest.ranges:type_name -> kvrpcpb.KeyRange
	160, // 190: kvrpcpb.RawCoprocessorResponse.region_error:type_name -> errorpb.Error
	90,  // 191: kvrpcpb.RawChecksumRequest.context:type_name -> kvrpcpb.Context
	12,  // 192: kvrpcpb.RawChecksumRequest.algorithm:type_name -> kvrpcpb.ChecksumAlgorithm
	121, // 193: kvrpcpb.RawChecksumRequest.ranges:type_name -> kvrpcpb.KeyRange
	160, // 194: kvrpcpb.RawChecksumResponse.region_error:type_name -> errorpb.Error
	141, // 195: kvrpcpb.CompactError.err_invalid_start_key:type_name -> kvrpcpb.CompactErrorInvalidStartKey
	142, // 196: kvrpcpb.CompactError.err_physical_table_not_exist:type_name -> kvrpcpb.CompactErrorPhysicalTableNotExist
	143, // 197: kvrpcpb.CompactError.err_compact_in_progress:type_name -> kvrpcpb.CompactErrorCompactInProgress
	144, // 198: kvrpcpb.CompactError.err_too_many_pending_tasks:type_name -> kvrpcpb.CompactErrorTooManyPendingTasks
	3,   // 199: kvrpcpb.CompactRequest.api_version:type_name -> kvrpcpb.APIVersion
	140, // 200: kvrpcpb.CompactResponse.error:type_name -> kvrpcpb.CompactError
	90,  // 201: kvrpcpb.FlushRequest.context:type_name -> kvrpcpb.Context
	115, // 202: kvrpcpb.FlushRequest.mutations:type_name -> kvrpcpb.Mutation
	9,   // 203: kvrpcpb.FlushRequest.assertion_level:type_name -> kvrpcpb.AssertionLevel
	160, // 204: kvrpcpb.FlushResponse.region_error:type_name -> errorpb.Error
	94,  // 205: kvrpcpb.FlushResponse.errors:type_name -> kvrpcpb.KeyError
	112, // 206: kvrpcpb.FlushResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 207: kvrpcpb.BufferBatchGetRequest.context:type_name -> kvrpcpb.Context
	160, // 208: kvrpcpb.BufferBatchGetResponse.region_error:type_name -> errorpb.Error
	94,  // 209: kvrpcpb.BufferBatchGetResponse.error:type_name -> kvrpcpb.KeyError
	114, // 210: kvrpcpb.BufferBatchGetResponse.pairs:type_name -> kvrpcpb.KvPair
	112, // 211: kvrpcpb.BufferBatchGetResponse.exec_details_v2:type_name -> kvrpcpb.ExecDetailsV2
	90,  // 212: kvrpcpb.GetHealthFeedbackRequest.context:type_name -> kvrpcpb.Context
	160, // 213: kvrpcpb.GetHealthFeedbackResponse.region_error:type_name -> errorpb.Error
	155, // 214: kvrpcpb.GetHealthFeedbackResponse.health_feedback:type_name -> kvrpcpb.HealthFeedback
	90,  // 215: kvrpcpb.BroadcastTxnStatusRequest.context:type_name -> kvrpcpb.Context
	157, // 216: kvrpcpb.BroadcastTxnStatusRequest.txn_status:type_name -> kvrpcpb.TxnStatus
	217, // [217:217] is the sub-list for method output_type
	217, // [217:217] is the sub-list for method input_type
	217, // [217:217] is the sub-list for extension type_name
	217, // [217:217] is the sub-list for extension extendee
	0,   // [0:217] is the sub-list for field type_name
}

func init() { file_kvrpcpb_proto_init() }
func file_kvrpcpb_proto_init() {
	if File_kvrpcpb_proto != nil {
		return
	}
	file_kvrpcpb_proto_msgTypes[125].OneofWrappers = []any{
		(*CompactError_ErrInvalidStartKey)(nil),
		(*CompactError_ErrPhysicalTableNotExist)(nil),
		(*CompactError_ErrCompactInProgress)(nil),
		(*CompactError_ErrTooManyPendingTasks)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_kvrpcpb_proto_rawDesc), len(file_kvrpcpb_proto_rawDesc)),
			NumEnums:      15,
			NumMessages:   145,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_kvrpcpb_proto_goTypes,
		DependencyIndexes: file_kvrpcpb_proto_depIdxs,
		EnumInfos:         file_kvrpcpb_proto_enumTypes,
		MessageInfos:      file_kvrpcpb_proto_msgTypes,
	}.Build()
	File_kvrpcpb_proto = out.File
	file_kvrpcpb_proto_goTypes = nil
	file_kvrpcpb_proto_depIdxs = nil
}
