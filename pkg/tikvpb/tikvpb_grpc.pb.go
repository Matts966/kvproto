// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: tikvpb.proto

package tikvpb

import (
	"context"

	coprocessor "github.com/pingcap/kvproto/pkg/coprocessor"
	disaggregated "github.com/pingcap/kvproto/pkg/disaggregated"
	kvrpcpb "github.com/pingcap/kvproto/pkg/kvrpcpb"
	mpp "github.com/pingcap/kvproto/pkg/mpp"
	raft_serverpb "github.com/pingcap/kvproto/pkg/raft_serverpb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Tikv_KvGet_FullMethodName                       = "/tikvpb.Tikv/KvGet"
	Tikv_KvScan_FullMethodName                      = "/tikvpb.Tikv/KvScan"
	Tikv_KvPrewrite_FullMethodName                  = "/tikvpb.Tikv/KvPrewrite"
	Tikv_KvPessimisticLock_FullMethodName           = "/tikvpb.Tikv/KvPessimisticLock"
	Tikv_KVPessimisticRollback_FullMethodName       = "/tikvpb.Tikv/KVPessimisticRollback"
	Tikv_KvTxnHeartBeat_FullMethodName              = "/tikvpb.Tikv/KvTxnHeartBeat"
	Tikv_KvCheckTxnStatus_FullMethodName            = "/tikvpb.Tikv/KvCheckTxnStatus"
	Tikv_KvCheckSecondaryLocks_FullMethodName       = "/tikvpb.Tikv/KvCheckSecondaryLocks"
	Tikv_KvCommit_FullMethodName                    = "/tikvpb.Tikv/KvCommit"
	Tikv_KvImport_FullMethodName                    = "/tikvpb.Tikv/KvImport"
	Tikv_KvCleanup_FullMethodName                   = "/tikvpb.Tikv/KvCleanup"
	Tikv_KvBatchGet_FullMethodName                  = "/tikvpb.Tikv/KvBatchGet"
	Tikv_KvBatchRollback_FullMethodName             = "/tikvpb.Tikv/KvBatchRollback"
	Tikv_KvScanLock_FullMethodName                  = "/tikvpb.Tikv/KvScanLock"
	Tikv_KvResolveLock_FullMethodName               = "/tikvpb.Tikv/KvResolveLock"
	Tikv_KvGC_FullMethodName                        = "/tikvpb.Tikv/KvGC"
	Tikv_KvDeleteRange_FullMethodName               = "/tikvpb.Tikv/KvDeleteRange"
	Tikv_KvPrepareFlashbackToVersion_FullMethodName = "/tikvpb.Tikv/KvPrepareFlashbackToVersion"
	Tikv_KvFlashbackToVersion_FullMethodName        = "/tikvpb.Tikv/KvFlashbackToVersion"
	Tikv_KvFlush_FullMethodName                     = "/tikvpb.Tikv/KvFlush"
	Tikv_KvBufferBatchGet_FullMethodName            = "/tikvpb.Tikv/KvBufferBatchGet"
	Tikv_RawGet_FullMethodName                      = "/tikvpb.Tikv/RawGet"
	Tikv_RawBatchGet_FullMethodName                 = "/tikvpb.Tikv/RawBatchGet"
	Tikv_RawPut_FullMethodName                      = "/tikvpb.Tikv/RawPut"
	Tikv_RawBatchPut_FullMethodName                 = "/tikvpb.Tikv/RawBatchPut"
	Tikv_RawDelete_FullMethodName                   = "/tikvpb.Tikv/RawDelete"
	Tikv_RawBatchDelete_FullMethodName              = "/tikvpb.Tikv/RawBatchDelete"
	Tikv_RawScan_FullMethodName                     = "/tikvpb.Tikv/RawScan"
	Tikv_RawDeleteRange_FullMethodName              = "/tikvpb.Tikv/RawDeleteRange"
	Tikv_RawBatchScan_FullMethodName                = "/tikvpb.Tikv/RawBatchScan"
	Tikv_RawGetKeyTTL_FullMethodName                = "/tikvpb.Tikv/RawGetKeyTTL"
	Tikv_RawCompareAndSwap_FullMethodName           = "/tikvpb.Tikv/RawCompareAndSwap"
	Tikv_RawChecksum_FullMethodName                 = "/tikvpb.Tikv/RawChecksum"
	Tikv_UnsafeDestroyRange_FullMethodName          = "/tikvpb.Tikv/UnsafeDestroyRange"
	Tikv_RegisterLockObserver_FullMethodName        = "/tikvpb.Tikv/RegisterLockObserver"
	Tikv_CheckLockObserver_FullMethodName           = "/tikvpb.Tikv/CheckLockObserver"
	Tikv_RemoveLockObserver_FullMethodName          = "/tikvpb.Tikv/RemoveLockObserver"
	Tikv_PhysicalScanLock_FullMethodName            = "/tikvpb.Tikv/PhysicalScanLock"
	Tikv_Coprocessor_FullMethodName                 = "/tikvpb.Tikv/Coprocessor"
	Tikv_CoprocessorStream_FullMethodName           = "/tikvpb.Tikv/CoprocessorStream"
	Tikv_BatchCoprocessor_FullMethodName            = "/tikvpb.Tikv/BatchCoprocessor"
	Tikv_DelegateCoprocessor_FullMethodName         = "/tikvpb.Tikv/DelegateCoprocessor"
	Tikv_RawCoprocessor_FullMethodName              = "/tikvpb.Tikv/RawCoprocessor"
	Tikv_Raft_FullMethodName                        = "/tikvpb.Tikv/Raft"
	Tikv_BatchRaft_FullMethodName                   = "/tikvpb.Tikv/BatchRaft"
	Tikv_Snapshot_FullMethodName                    = "/tikvpb.Tikv/Snapshot"
	Tikv_TabletSnapshot_FullMethodName              = "/tikvpb.Tikv/TabletSnapshot"
	Tikv_SplitRegion_FullMethodName                 = "/tikvpb.Tikv/SplitRegion"
	Tikv_ReadIndex_FullMethodName                   = "/tikvpb.Tikv/ReadIndex"
	Tikv_MvccGetByKey_FullMethodName                = "/tikvpb.Tikv/MvccGetByKey"
	Tikv_MvccGetByStartTs_FullMethodName            = "/tikvpb.Tikv/MvccGetByStartTs"
	Tikv_BatchCommands_FullMethodName               = "/tikvpb.Tikv/BatchCommands"
	Tikv_DispatchMPPTask_FullMethodName             = "/tikvpb.Tikv/DispatchMPPTask"
	Tikv_CancelMPPTask_FullMethodName               = "/tikvpb.Tikv/CancelMPPTask"
	Tikv_EstablishMPPConnection_FullMethodName      = "/tikvpb.Tikv/EstablishMPPConnection"
	Tikv_IsAlive_FullMethodName                     = "/tikvpb.Tikv/IsAlive"
	Tikv_ReportMPPTaskStatus_FullMethodName         = "/tikvpb.Tikv/ReportMPPTaskStatus"
	Tikv_CheckLeader_FullMethodName                 = "/tikvpb.Tikv/CheckLeader"
	Tikv_GetStoreSafeTS_FullMethodName              = "/tikvpb.Tikv/GetStoreSafeTS"
	Tikv_GetLockWaitInfo_FullMethodName             = "/tikvpb.Tikv/GetLockWaitInfo"
	Tikv_Compact_FullMethodName                     = "/tikvpb.Tikv/Compact"
	Tikv_GetLockWaitHistory_FullMethodName          = "/tikvpb.Tikv/GetLockWaitHistory"
	Tikv_GetTiFlashSystemTable_FullMethodName       = "/tikvpb.Tikv/GetTiFlashSystemTable"
	Tikv_TryAddLock_FullMethodName                  = "/tikvpb.Tikv/tryAddLock"
	Tikv_TryMarkDelete_FullMethodName               = "/tikvpb.Tikv/tryMarkDelete"
	Tikv_EstablishDisaggTask_FullMethodName         = "/tikvpb.Tikv/EstablishDisaggTask"
	Tikv_CancelDisaggTask_FullMethodName            = "/tikvpb.Tikv/CancelDisaggTask"
	Tikv_FetchDisaggPages_FullMethodName            = "/tikvpb.Tikv/FetchDisaggPages"
	Tikv_GetDisaggConfig_FullMethodName             = "/tikvpb.Tikv/GetDisaggConfig"
	Tikv_GetHealthFeedback_FullMethodName           = "/tikvpb.Tikv/GetHealthFeedback"
	Tikv_BroadcastTxnStatus_FullMethodName          = "/tikvpb.Tikv/BroadcastTxnStatus"
)

// TikvClient is the client API for Tikv service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Key/value store API for TiKV.
type TikvClient interface {
	// Commands using a transactional interface.
	KvGet(ctx context.Context, in *kvrpcpb.GetRequest, opts ...grpc.CallOption) (*kvrpcpb.GetResponse, error)
	KvScan(ctx context.Context, in *kvrpcpb.ScanRequest, opts ...grpc.CallOption) (*kvrpcpb.ScanResponse, error)
	KvPrewrite(ctx context.Context, in *kvrpcpb.PrewriteRequest, opts ...grpc.CallOption) (*kvrpcpb.PrewriteResponse, error)
	KvPessimisticLock(ctx context.Context, in *kvrpcpb.PessimisticLockRequest, opts ...grpc.CallOption) (*kvrpcpb.PessimisticLockResponse, error)
	KVPessimisticRollback(ctx context.Context, in *kvrpcpb.PessimisticRollbackRequest, opts ...grpc.CallOption) (*kvrpcpb.PessimisticRollbackResponse, error)
	KvTxnHeartBeat(ctx context.Context, in *kvrpcpb.TxnHeartBeatRequest, opts ...grpc.CallOption) (*kvrpcpb.TxnHeartBeatResponse, error)
	KvCheckTxnStatus(ctx context.Context, in *kvrpcpb.CheckTxnStatusRequest, opts ...grpc.CallOption) (*kvrpcpb.CheckTxnStatusResponse, error)
	KvCheckSecondaryLocks(ctx context.Context, in *kvrpcpb.CheckSecondaryLocksRequest, opts ...grpc.CallOption) (*kvrpcpb.CheckSecondaryLocksResponse, error)
	KvCommit(ctx context.Context, in *kvrpcpb.CommitRequest, opts ...grpc.CallOption) (*kvrpcpb.CommitResponse, error)
	KvImport(ctx context.Context, in *kvrpcpb.ImportRequest, opts ...grpc.CallOption) (*kvrpcpb.ImportResponse, error)
	KvCleanup(ctx context.Context, in *kvrpcpb.CleanupRequest, opts ...grpc.CallOption) (*kvrpcpb.CleanupResponse, error)
	KvBatchGet(ctx context.Context, in *kvrpcpb.BatchGetRequest, opts ...grpc.CallOption) (*kvrpcpb.BatchGetResponse, error)
	KvBatchRollback(ctx context.Context, in *kvrpcpb.BatchRollbackRequest, opts ...grpc.CallOption) (*kvrpcpb.BatchRollbackResponse, error)
	KvScanLock(ctx context.Context, in *kvrpcpb.ScanLockRequest, opts ...grpc.CallOption) (*kvrpcpb.ScanLockResponse, error)
	KvResolveLock(ctx context.Context, in *kvrpcpb.ResolveLockRequest, opts ...grpc.CallOption) (*kvrpcpb.ResolveLockResponse, error)
	KvGC(ctx context.Context, in *kvrpcpb.GCRequest, opts ...grpc.CallOption) (*kvrpcpb.GCResponse, error)
	KvDeleteRange(ctx context.Context, in *kvrpcpb.DeleteRangeRequest, opts ...grpc.CallOption) (*kvrpcpb.DeleteRangeResponse, error)
	KvPrepareFlashbackToVersion(ctx context.Context, in *kvrpcpb.PrepareFlashbackToVersionRequest, opts ...grpc.CallOption) (*kvrpcpb.PrepareFlashbackToVersionResponse, error)
	KvFlashbackToVersion(ctx context.Context, in *kvrpcpb.FlashbackToVersionRequest, opts ...grpc.CallOption) (*kvrpcpb.FlashbackToVersionResponse, error)
	KvFlush(ctx context.Context, in *kvrpcpb.FlushRequest, opts ...grpc.CallOption) (*kvrpcpb.FlushResponse, error)
	KvBufferBatchGet(ctx context.Context, in *kvrpcpb.BufferBatchGetRequest, opts ...grpc.CallOption) (*kvrpcpb.BufferBatchGetResponse, error)
	// Raw commands; no transaction support.
	RawGet(ctx context.Context, in *kvrpcpb.RawGetRequest, opts ...grpc.CallOption) (*kvrpcpb.RawGetResponse, error)
	RawBatchGet(ctx context.Context, in *kvrpcpb.RawBatchGetRequest, opts ...grpc.CallOption) (*kvrpcpb.RawBatchGetResponse, error)
	RawPut(ctx context.Context, in *kvrpcpb.RawPutRequest, opts ...grpc.CallOption) (*kvrpcpb.RawPutResponse, error)
	RawBatchPut(ctx context.Context, in *kvrpcpb.RawBatchPutRequest, opts ...grpc.CallOption) (*kvrpcpb.RawBatchPutResponse, error)
	RawDelete(ctx context.Context, in *kvrpcpb.RawDeleteRequest, opts ...grpc.CallOption) (*kvrpcpb.RawDeleteResponse, error)
	RawBatchDelete(ctx context.Context, in *kvrpcpb.RawBatchDeleteRequest, opts ...grpc.CallOption) (*kvrpcpb.RawBatchDeleteResponse, error)
	RawScan(ctx context.Context, in *kvrpcpb.RawScanRequest, opts ...grpc.CallOption) (*kvrpcpb.RawScanResponse, error)
	RawDeleteRange(ctx context.Context, in *kvrpcpb.RawDeleteRangeRequest, opts ...grpc.CallOption) (*kvrpcpb.RawDeleteRangeResponse, error)
	RawBatchScan(ctx context.Context, in *kvrpcpb.RawBatchScanRequest, opts ...grpc.CallOption) (*kvrpcpb.RawBatchScanResponse, error)
	// Get TTL of the key. Returns 0 if TTL is not set for the key.
	RawGetKeyTTL(ctx context.Context, in *kvrpcpb.RawGetKeyTTLRequest, opts ...grpc.CallOption) (*kvrpcpb.RawGetKeyTTLResponse, error)
	// Compare if the value in database equals to `RawCASRequest.previous_value` before putting the new value. If not, this request will have no effect and the value in the database will be returned.
	RawCompareAndSwap(ctx context.Context, in *kvrpcpb.RawCASRequest, opts ...grpc.CallOption) (*kvrpcpb.RawCASResponse, error)
	RawChecksum(ctx context.Context, in *kvrpcpb.RawChecksumRequest, opts ...grpc.CallOption) (*kvrpcpb.RawChecksumResponse, error)
	// Store commands (sent to a each TiKV node in a cluster, rather than a certain region).
	UnsafeDestroyRange(ctx context.Context, in *kvrpcpb.UnsafeDestroyRangeRequest, opts ...grpc.CallOption) (*kvrpcpb.UnsafeDestroyRangeResponse, error)
	RegisterLockObserver(ctx context.Context, in *kvrpcpb.RegisterLockObserverRequest, opts ...grpc.CallOption) (*kvrpcpb.RegisterLockObserverResponse, error)
	CheckLockObserver(ctx context.Context, in *kvrpcpb.CheckLockObserverRequest, opts ...grpc.CallOption) (*kvrpcpb.CheckLockObserverResponse, error)
	RemoveLockObserver(ctx context.Context, in *kvrpcpb.RemoveLockObserverRequest, opts ...grpc.CallOption) (*kvrpcpb.RemoveLockObserverResponse, error)
	PhysicalScanLock(ctx context.Context, in *kvrpcpb.PhysicalScanLockRequest, opts ...grpc.CallOption) (*kvrpcpb.PhysicalScanLockResponse, error)
	// Commands for executing SQL in the TiKV coprocessor (i.e., 'pushed down' to TiKV rather than
	// executed in TiDB).
	Coprocessor(ctx context.Context, in *coprocessor.Request, opts ...grpc.CallOption) (*coprocessor.Response, error)
	CoprocessorStream(ctx context.Context, in *coprocessor.Request, opts ...grpc.CallOption) (grpc.ServerStreamingClient[coprocessor.Response], error)
	BatchCoprocessor(ctx context.Context, in *coprocessor.BatchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[coprocessor.BatchResponse], error)
	// Command send by remote coprocessor to TiKV for executing coprocessor request.
	DelegateCoprocessor(ctx context.Context, in *coprocessor.DelegateRequest, opts ...grpc.CallOption) (*coprocessor.DelegateResponse, error)
	// Command for executing custom user requests in TiKV coprocessor_v2.
	RawCoprocessor(ctx context.Context, in *kvrpcpb.RawCoprocessorRequest, opts ...grpc.CallOption) (*kvrpcpb.RawCoprocessorResponse, error)
	// Raft commands (sent between TiKV nodes).
	Raft(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[raft_serverpb.RaftMessage, raft_serverpb.Done], error)
	BatchRaft(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[BatchRaftMessage, raft_serverpb.Done], error)
	Snapshot(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[raft_serverpb.SnapshotChunk, raft_serverpb.Done], error)
	TabletSnapshot(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[raft_serverpb.TabletSnapshotRequest, raft_serverpb.TabletSnapshotResponse], error)
	// Sent from PD or TiDB to a TiKV node.
	SplitRegion(ctx context.Context, in *kvrpcpb.SplitRegionRequest, opts ...grpc.CallOption) (*kvrpcpb.SplitRegionResponse, error)
	// Sent from TiFlash or TiKV to a TiKV node.
	ReadIndex(ctx context.Context, in *kvrpcpb.ReadIndexRequest, opts ...grpc.CallOption) (*kvrpcpb.ReadIndexResponse, error)
	// Commands for debugging transactions.
	MvccGetByKey(ctx context.Context, in *kvrpcpb.MvccGetByKeyRequest, opts ...grpc.CallOption) (*kvrpcpb.MvccGetByKeyResponse, error)
	MvccGetByStartTs(ctx context.Context, in *kvrpcpb.MvccGetByStartTsRequest, opts ...grpc.CallOption) (*kvrpcpb.MvccGetByStartTsResponse, error)
	// Batched commands.
	BatchCommands(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[BatchCommandsRequest, BatchCommandsResponse], error)
	// These are for mpp execution.
	DispatchMPPTask(ctx context.Context, in *mpp.DispatchTaskRequest, opts ...grpc.CallOption) (*mpp.DispatchTaskResponse, error)
	CancelMPPTask(ctx context.Context, in *mpp.CancelTaskRequest, opts ...grpc.CallOption) (*mpp.CancelTaskResponse, error)
	EstablishMPPConnection(ctx context.Context, in *mpp.EstablishMPPConnectionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[mpp.MPPDataPacket], error)
	IsAlive(ctx context.Context, in *mpp.IsAliveRequest, opts ...grpc.CallOption) (*mpp.IsAliveResponse, error)
	ReportMPPTaskStatus(ctx context.Context, in *mpp.ReportTaskStatusRequest, opts ...grpc.CallOption) (*mpp.ReportTaskStatusResponse, error)
	// / CheckLeader sends all information (includes region term and epoch) to other stores.
	// / Once a store receives a request, it checks term and epoch for each region, and sends the regions whose
	// / term and epoch match with local information in the store.
	// / After the client collected all responses from all stores, it checks if got a quorum of responses from
	// / other stores for every region, and decides to advance resolved ts from these regions.
	CheckLeader(ctx context.Context, in *kvrpcpb.CheckLeaderRequest, opts ...grpc.CallOption) (*kvrpcpb.CheckLeaderResponse, error)
	// / Get the minimal `safe_ts` from regions at the store
	GetStoreSafeTS(ctx context.Context, in *kvrpcpb.StoreSafeTSRequest, opts ...grpc.CallOption) (*kvrpcpb.StoreSafeTSResponse, error)
	// / Get the information about lock waiting from TiKV.
	GetLockWaitInfo(ctx context.Context, in *kvrpcpb.GetLockWaitInfoRequest, opts ...grpc.CallOption) (*kvrpcpb.GetLockWaitInfoResponse, error)
	// / Compact a specified key range. This request is not restricted to raft leaders and will not be replicated.
	// / It only compacts data on this node.
	// / TODO: Currently this RPC is designed to be only compatible with TiFlash.
	// / Shall be move out in https://github.com/pingcap/kvproto/issues/912
	Compact(ctx context.Context, in *kvrpcpb.CompactRequest, opts ...grpc.CallOption) (*kvrpcpb.CompactResponse, error)
	// / Get the information about history lock waiting from TiKV.
	GetLockWaitHistory(ctx context.Context, in *kvrpcpb.GetLockWaitHistoryRequest, opts ...grpc.CallOption) (*kvrpcpb.GetLockWaitHistoryResponse, error)
	// / Get system table from TiFlash
	GetTiFlashSystemTable(ctx context.Context, in *kvrpcpb.TiFlashSystemTableRequest, opts ...grpc.CallOption) (*kvrpcpb.TiFlashSystemTableResponse, error)
	// These are for TiFlash disaggregated architecture
	// / Try to lock a S3 object, atomically
	TryAddLock(ctx context.Context, in *disaggregated.TryAddLockRequest, opts ...grpc.CallOption) (*disaggregated.TryAddLockResponse, error)
	// / Try to delete a S3 object, atomically
	TryMarkDelete(ctx context.Context, in *disaggregated.TryMarkDeleteRequest, opts ...grpc.CallOption) (*disaggregated.TryMarkDeleteResponse, error)
	// / Build the disaggregated task on TiFlash write node
	EstablishDisaggTask(ctx context.Context, in *disaggregated.EstablishDisaggTaskRequest, opts ...grpc.CallOption) (*disaggregated.EstablishDisaggTaskResponse, error)
	// / Cancel the disaggregated task on TiFlash write node
	CancelDisaggTask(ctx context.Context, in *disaggregated.CancelDisaggTaskRequest, opts ...grpc.CallOption) (*disaggregated.CancelDisaggTaskResponse, error)
	// / Exchange page data between TiFlash write node and compute node
	FetchDisaggPages(ctx context.Context, in *disaggregated.FetchDisaggPagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[disaggregated.PagesPacket], error)
	// / Compute node get configuration from Write node
	GetDisaggConfig(ctx context.Context, in *disaggregated.GetDisaggConfigRequest, opts ...grpc.CallOption) (*disaggregated.GetDisaggConfigResponse, error)
	// / Get health feedback info from the TiKV node.
	GetHealthFeedback(ctx context.Context, in *kvrpcpb.GetHealthFeedbackRequest, opts ...grpc.CallOption) (*kvrpcpb.GetHealthFeedbackResponse, error)
	// / Broadcast the transaction status to all TiKV nodes
	BroadcastTxnStatus(ctx context.Context, in *kvrpcpb.BroadcastTxnStatusRequest, opts ...grpc.CallOption) (*kvrpcpb.BroadcastTxnStatusResponse, error)
}

type tikvClient struct {
	cc grpc.ClientConnInterface
}

func NewTikvClient(cc grpc.ClientConnInterface) TikvClient {
	return &tikvClient{cc}
}

func (c *tikvClient) KvGet(ctx context.Context, in *kvrpcpb.GetRequest, opts ...grpc.CallOption) (*kvrpcpb.GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.GetResponse)
	err := c.cc.Invoke(ctx, Tikv_KvGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvScan(ctx context.Context, in *kvrpcpb.ScanRequest, opts ...grpc.CallOption) (*kvrpcpb.ScanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.ScanResponse)
	err := c.cc.Invoke(ctx, Tikv_KvScan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvPrewrite(ctx context.Context, in *kvrpcpb.PrewriteRequest, opts ...grpc.CallOption) (*kvrpcpb.PrewriteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.PrewriteResponse)
	err := c.cc.Invoke(ctx, Tikv_KvPrewrite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvPessimisticLock(ctx context.Context, in *kvrpcpb.PessimisticLockRequest, opts ...grpc.CallOption) (*kvrpcpb.PessimisticLockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.PessimisticLockResponse)
	err := c.cc.Invoke(ctx, Tikv_KvPessimisticLock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KVPessimisticRollback(ctx context.Context, in *kvrpcpb.PessimisticRollbackRequest, opts ...grpc.CallOption) (*kvrpcpb.PessimisticRollbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.PessimisticRollbackResponse)
	err := c.cc.Invoke(ctx, Tikv_KVPessimisticRollback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvTxnHeartBeat(ctx context.Context, in *kvrpcpb.TxnHeartBeatRequest, opts ...grpc.CallOption) (*kvrpcpb.TxnHeartBeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.TxnHeartBeatResponse)
	err := c.cc.Invoke(ctx, Tikv_KvTxnHeartBeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvCheckTxnStatus(ctx context.Context, in *kvrpcpb.CheckTxnStatusRequest, opts ...grpc.CallOption) (*kvrpcpb.CheckTxnStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.CheckTxnStatusResponse)
	err := c.cc.Invoke(ctx, Tikv_KvCheckTxnStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvCheckSecondaryLocks(ctx context.Context, in *kvrpcpb.CheckSecondaryLocksRequest, opts ...grpc.CallOption) (*kvrpcpb.CheckSecondaryLocksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.CheckSecondaryLocksResponse)
	err := c.cc.Invoke(ctx, Tikv_KvCheckSecondaryLocks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvCommit(ctx context.Context, in *kvrpcpb.CommitRequest, opts ...grpc.CallOption) (*kvrpcpb.CommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.CommitResponse)
	err := c.cc.Invoke(ctx, Tikv_KvCommit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvImport(ctx context.Context, in *kvrpcpb.ImportRequest, opts ...grpc.CallOption) (*kvrpcpb.ImportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.ImportResponse)
	err := c.cc.Invoke(ctx, Tikv_KvImport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvCleanup(ctx context.Context, in *kvrpcpb.CleanupRequest, opts ...grpc.CallOption) (*kvrpcpb.CleanupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.CleanupResponse)
	err := c.cc.Invoke(ctx, Tikv_KvCleanup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvBatchGet(ctx context.Context, in *kvrpcpb.BatchGetRequest, opts ...grpc.CallOption) (*kvrpcpb.BatchGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.BatchGetResponse)
	err := c.cc.Invoke(ctx, Tikv_KvBatchGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvBatchRollback(ctx context.Context, in *kvrpcpb.BatchRollbackRequest, opts ...grpc.CallOption) (*kvrpcpb.BatchRollbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.BatchRollbackResponse)
	err := c.cc.Invoke(ctx, Tikv_KvBatchRollback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvScanLock(ctx context.Context, in *kvrpcpb.ScanLockRequest, opts ...grpc.CallOption) (*kvrpcpb.ScanLockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.ScanLockResponse)
	err := c.cc.Invoke(ctx, Tikv_KvScanLock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvResolveLock(ctx context.Context, in *kvrpcpb.ResolveLockRequest, opts ...grpc.CallOption) (*kvrpcpb.ResolveLockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.ResolveLockResponse)
	err := c.cc.Invoke(ctx, Tikv_KvResolveLock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvGC(ctx context.Context, in *kvrpcpb.GCRequest, opts ...grpc.CallOption) (*kvrpcpb.GCResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.GCResponse)
	err := c.cc.Invoke(ctx, Tikv_KvGC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvDeleteRange(ctx context.Context, in *kvrpcpb.DeleteRangeRequest, opts ...grpc.CallOption) (*kvrpcpb.DeleteRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.DeleteRangeResponse)
	err := c.cc.Invoke(ctx, Tikv_KvDeleteRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvPrepareFlashbackToVersion(ctx context.Context, in *kvrpcpb.PrepareFlashbackToVersionRequest, opts ...grpc.CallOption) (*kvrpcpb.PrepareFlashbackToVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.PrepareFlashbackToVersionResponse)
	err := c.cc.Invoke(ctx, Tikv_KvPrepareFlashbackToVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvFlashbackToVersion(ctx context.Context, in *kvrpcpb.FlashbackToVersionRequest, opts ...grpc.CallOption) (*kvrpcpb.FlashbackToVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.FlashbackToVersionResponse)
	err := c.cc.Invoke(ctx, Tikv_KvFlashbackToVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvFlush(ctx context.Context, in *kvrpcpb.FlushRequest, opts ...grpc.CallOption) (*kvrpcpb.FlushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.FlushResponse)
	err := c.cc.Invoke(ctx, Tikv_KvFlush_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) KvBufferBatchGet(ctx context.Context, in *kvrpcpb.BufferBatchGetRequest, opts ...grpc.CallOption) (*kvrpcpb.BufferBatchGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.BufferBatchGetResponse)
	err := c.cc.Invoke(ctx, Tikv_KvBufferBatchGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawGet(ctx context.Context, in *kvrpcpb.RawGetRequest, opts ...grpc.CallOption) (*kvrpcpb.RawGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawGetResponse)
	err := c.cc.Invoke(ctx, Tikv_RawGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawBatchGet(ctx context.Context, in *kvrpcpb.RawBatchGetRequest, opts ...grpc.CallOption) (*kvrpcpb.RawBatchGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawBatchGetResponse)
	err := c.cc.Invoke(ctx, Tikv_RawBatchGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawPut(ctx context.Context, in *kvrpcpb.RawPutRequest, opts ...grpc.CallOption) (*kvrpcpb.RawPutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawPutResponse)
	err := c.cc.Invoke(ctx, Tikv_RawPut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawBatchPut(ctx context.Context, in *kvrpcpb.RawBatchPutRequest, opts ...grpc.CallOption) (*kvrpcpb.RawBatchPutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawBatchPutResponse)
	err := c.cc.Invoke(ctx, Tikv_RawBatchPut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawDelete(ctx context.Context, in *kvrpcpb.RawDeleteRequest, opts ...grpc.CallOption) (*kvrpcpb.RawDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawDeleteResponse)
	err := c.cc.Invoke(ctx, Tikv_RawDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawBatchDelete(ctx context.Context, in *kvrpcpb.RawBatchDeleteRequest, opts ...grpc.CallOption) (*kvrpcpb.RawBatchDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawBatchDeleteResponse)
	err := c.cc.Invoke(ctx, Tikv_RawBatchDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawScan(ctx context.Context, in *kvrpcpb.RawScanRequest, opts ...grpc.CallOption) (*kvrpcpb.RawScanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawScanResponse)
	err := c.cc.Invoke(ctx, Tikv_RawScan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawDeleteRange(ctx context.Context, in *kvrpcpb.RawDeleteRangeRequest, opts ...grpc.CallOption) (*kvrpcpb.RawDeleteRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawDeleteRangeResponse)
	err := c.cc.Invoke(ctx, Tikv_RawDeleteRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawBatchScan(ctx context.Context, in *kvrpcpb.RawBatchScanRequest, opts ...grpc.CallOption) (*kvrpcpb.RawBatchScanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawBatchScanResponse)
	err := c.cc.Invoke(ctx, Tikv_RawBatchScan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawGetKeyTTL(ctx context.Context, in *kvrpcpb.RawGetKeyTTLRequest, opts ...grpc.CallOption) (*kvrpcpb.RawGetKeyTTLResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawGetKeyTTLResponse)
	err := c.cc.Invoke(ctx, Tikv_RawGetKeyTTL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawCompareAndSwap(ctx context.Context, in *kvrpcpb.RawCASRequest, opts ...grpc.CallOption) (*kvrpcpb.RawCASResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawCASResponse)
	err := c.cc.Invoke(ctx, Tikv_RawCompareAndSwap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawChecksum(ctx context.Context, in *kvrpcpb.RawChecksumRequest, opts ...grpc.CallOption) (*kvrpcpb.RawChecksumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawChecksumResponse)
	err := c.cc.Invoke(ctx, Tikv_RawChecksum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) UnsafeDestroyRange(ctx context.Context, in *kvrpcpb.UnsafeDestroyRangeRequest, opts ...grpc.CallOption) (*kvrpcpb.UnsafeDestroyRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.UnsafeDestroyRangeResponse)
	err := c.cc.Invoke(ctx, Tikv_UnsafeDestroyRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RegisterLockObserver(ctx context.Context, in *kvrpcpb.RegisterLockObserverRequest, opts ...grpc.CallOption) (*kvrpcpb.RegisterLockObserverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RegisterLockObserverResponse)
	err := c.cc.Invoke(ctx, Tikv_RegisterLockObserver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) CheckLockObserver(ctx context.Context, in *kvrpcpb.CheckLockObserverRequest, opts ...grpc.CallOption) (*kvrpcpb.CheckLockObserverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.CheckLockObserverResponse)
	err := c.cc.Invoke(ctx, Tikv_CheckLockObserver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RemoveLockObserver(ctx context.Context, in *kvrpcpb.RemoveLockObserverRequest, opts ...grpc.CallOption) (*kvrpcpb.RemoveLockObserverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RemoveLockObserverResponse)
	err := c.cc.Invoke(ctx, Tikv_RemoveLockObserver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) PhysicalScanLock(ctx context.Context, in *kvrpcpb.PhysicalScanLockRequest, opts ...grpc.CallOption) (*kvrpcpb.PhysicalScanLockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.PhysicalScanLockResponse)
	err := c.cc.Invoke(ctx, Tikv_PhysicalScanLock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) Coprocessor(ctx context.Context, in *coprocessor.Request, opts ...grpc.CallOption) (*coprocessor.Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(coprocessor.Response)
	err := c.cc.Invoke(ctx, Tikv_Coprocessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) CoprocessorStream(ctx context.Context, in *coprocessor.Request, opts ...grpc.CallOption) (grpc.ServerStreamingClient[coprocessor.Response], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[0], Tikv_CoprocessorStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[coprocessor.Request, coprocessor.Response]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_CoprocessorStreamClient = grpc.ServerStreamingClient[coprocessor.Response]

func (c *tikvClient) BatchCoprocessor(ctx context.Context, in *coprocessor.BatchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[coprocessor.BatchResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[1], Tikv_BatchCoprocessor_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[coprocessor.BatchRequest, coprocessor.BatchResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_BatchCoprocessorClient = grpc.ServerStreamingClient[coprocessor.BatchResponse]

func (c *tikvClient) DelegateCoprocessor(ctx context.Context, in *coprocessor.DelegateRequest, opts ...grpc.CallOption) (*coprocessor.DelegateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(coprocessor.DelegateResponse)
	err := c.cc.Invoke(ctx, Tikv_DelegateCoprocessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) RawCoprocessor(ctx context.Context, in *kvrpcpb.RawCoprocessorRequest, opts ...grpc.CallOption) (*kvrpcpb.RawCoprocessorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.RawCoprocessorResponse)
	err := c.cc.Invoke(ctx, Tikv_RawCoprocessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) Raft(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[raft_serverpb.RaftMessage, raft_serverpb.Done], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[2], Tikv_Raft_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[raft_serverpb.RaftMessage, raft_serverpb.Done]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_RaftClient = grpc.ClientStreamingClient[raft_serverpb.RaftMessage, raft_serverpb.Done]

func (c *tikvClient) BatchRaft(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[BatchRaftMessage, raft_serverpb.Done], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[3], Tikv_BatchRaft_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BatchRaftMessage, raft_serverpb.Done]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_BatchRaftClient = grpc.ClientStreamingClient[BatchRaftMessage, raft_serverpb.Done]

func (c *tikvClient) Snapshot(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[raft_serverpb.SnapshotChunk, raft_serverpb.Done], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[4], Tikv_Snapshot_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[raft_serverpb.SnapshotChunk, raft_serverpb.Done]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_SnapshotClient = grpc.ClientStreamingClient[raft_serverpb.SnapshotChunk, raft_serverpb.Done]

func (c *tikvClient) TabletSnapshot(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[raft_serverpb.TabletSnapshotRequest, raft_serverpb.TabletSnapshotResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[5], Tikv_TabletSnapshot_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[raft_serverpb.TabletSnapshotRequest, raft_serverpb.TabletSnapshotResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_TabletSnapshotClient = grpc.BidiStreamingClient[raft_serverpb.TabletSnapshotRequest, raft_serverpb.TabletSnapshotResponse]

func (c *tikvClient) SplitRegion(ctx context.Context, in *kvrpcpb.SplitRegionRequest, opts ...grpc.CallOption) (*kvrpcpb.SplitRegionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.SplitRegionResponse)
	err := c.cc.Invoke(ctx, Tikv_SplitRegion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) ReadIndex(ctx context.Context, in *kvrpcpb.ReadIndexRequest, opts ...grpc.CallOption) (*kvrpcpb.ReadIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.ReadIndexResponse)
	err := c.cc.Invoke(ctx, Tikv_ReadIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) MvccGetByKey(ctx context.Context, in *kvrpcpb.MvccGetByKeyRequest, opts ...grpc.CallOption) (*kvrpcpb.MvccGetByKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.MvccGetByKeyResponse)
	err := c.cc.Invoke(ctx, Tikv_MvccGetByKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) MvccGetByStartTs(ctx context.Context, in *kvrpcpb.MvccGetByStartTsRequest, opts ...grpc.CallOption) (*kvrpcpb.MvccGetByStartTsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.MvccGetByStartTsResponse)
	err := c.cc.Invoke(ctx, Tikv_MvccGetByStartTs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) BatchCommands(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[BatchCommandsRequest, BatchCommandsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[6], Tikv_BatchCommands_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BatchCommandsRequest, BatchCommandsResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_BatchCommandsClient = grpc.BidiStreamingClient[BatchCommandsRequest, BatchCommandsResponse]

func (c *tikvClient) DispatchMPPTask(ctx context.Context, in *mpp.DispatchTaskRequest, opts ...grpc.CallOption) (*mpp.DispatchTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(mpp.DispatchTaskResponse)
	err := c.cc.Invoke(ctx, Tikv_DispatchMPPTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) CancelMPPTask(ctx context.Context, in *mpp.CancelTaskRequest, opts ...grpc.CallOption) (*mpp.CancelTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(mpp.CancelTaskResponse)
	err := c.cc.Invoke(ctx, Tikv_CancelMPPTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) EstablishMPPConnection(ctx context.Context, in *mpp.EstablishMPPConnectionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[mpp.MPPDataPacket], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[7], Tikv_EstablishMPPConnection_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[mpp.EstablishMPPConnectionRequest, mpp.MPPDataPacket]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_EstablishMPPConnectionClient = grpc.ServerStreamingClient[mpp.MPPDataPacket]

func (c *tikvClient) IsAlive(ctx context.Context, in *mpp.IsAliveRequest, opts ...grpc.CallOption) (*mpp.IsAliveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(mpp.IsAliveResponse)
	err := c.cc.Invoke(ctx, Tikv_IsAlive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) ReportMPPTaskStatus(ctx context.Context, in *mpp.ReportTaskStatusRequest, opts ...grpc.CallOption) (*mpp.ReportTaskStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(mpp.ReportTaskStatusResponse)
	err := c.cc.Invoke(ctx, Tikv_ReportMPPTaskStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) CheckLeader(ctx context.Context, in *kvrpcpb.CheckLeaderRequest, opts ...grpc.CallOption) (*kvrpcpb.CheckLeaderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.CheckLeaderResponse)
	err := c.cc.Invoke(ctx, Tikv_CheckLeader_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) GetStoreSafeTS(ctx context.Context, in *kvrpcpb.StoreSafeTSRequest, opts ...grpc.CallOption) (*kvrpcpb.StoreSafeTSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.StoreSafeTSResponse)
	err := c.cc.Invoke(ctx, Tikv_GetStoreSafeTS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) GetLockWaitInfo(ctx context.Context, in *kvrpcpb.GetLockWaitInfoRequest, opts ...grpc.CallOption) (*kvrpcpb.GetLockWaitInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.GetLockWaitInfoResponse)
	err := c.cc.Invoke(ctx, Tikv_GetLockWaitInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) Compact(ctx context.Context, in *kvrpcpb.CompactRequest, opts ...grpc.CallOption) (*kvrpcpb.CompactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.CompactResponse)
	err := c.cc.Invoke(ctx, Tikv_Compact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) GetLockWaitHistory(ctx context.Context, in *kvrpcpb.GetLockWaitHistoryRequest, opts ...grpc.CallOption) (*kvrpcpb.GetLockWaitHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.GetLockWaitHistoryResponse)
	err := c.cc.Invoke(ctx, Tikv_GetLockWaitHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) GetTiFlashSystemTable(ctx context.Context, in *kvrpcpb.TiFlashSystemTableRequest, opts ...grpc.CallOption) (*kvrpcpb.TiFlashSystemTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.TiFlashSystemTableResponse)
	err := c.cc.Invoke(ctx, Tikv_GetTiFlashSystemTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) TryAddLock(ctx context.Context, in *disaggregated.TryAddLockRequest, opts ...grpc.CallOption) (*disaggregated.TryAddLockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(disaggregated.TryAddLockResponse)
	err := c.cc.Invoke(ctx, Tikv_TryAddLock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) TryMarkDelete(ctx context.Context, in *disaggregated.TryMarkDeleteRequest, opts ...grpc.CallOption) (*disaggregated.TryMarkDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(disaggregated.TryMarkDeleteResponse)
	err := c.cc.Invoke(ctx, Tikv_TryMarkDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) EstablishDisaggTask(ctx context.Context, in *disaggregated.EstablishDisaggTaskRequest, opts ...grpc.CallOption) (*disaggregated.EstablishDisaggTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(disaggregated.EstablishDisaggTaskResponse)
	err := c.cc.Invoke(ctx, Tikv_EstablishDisaggTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) CancelDisaggTask(ctx context.Context, in *disaggregated.CancelDisaggTaskRequest, opts ...grpc.CallOption) (*disaggregated.CancelDisaggTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(disaggregated.CancelDisaggTaskResponse)
	err := c.cc.Invoke(ctx, Tikv_CancelDisaggTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) FetchDisaggPages(ctx context.Context, in *disaggregated.FetchDisaggPagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[disaggregated.PagesPacket], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tikv_ServiceDesc.Streams[8], Tikv_FetchDisaggPages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[disaggregated.FetchDisaggPagesRequest, disaggregated.PagesPacket]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_FetchDisaggPagesClient = grpc.ServerStreamingClient[disaggregated.PagesPacket]

func (c *tikvClient) GetDisaggConfig(ctx context.Context, in *disaggregated.GetDisaggConfigRequest, opts ...grpc.CallOption) (*disaggregated.GetDisaggConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(disaggregated.GetDisaggConfigResponse)
	err := c.cc.Invoke(ctx, Tikv_GetDisaggConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) GetHealthFeedback(ctx context.Context, in *kvrpcpb.GetHealthFeedbackRequest, opts ...grpc.CallOption) (*kvrpcpb.GetHealthFeedbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.GetHealthFeedbackResponse)
	err := c.cc.Invoke(ctx, Tikv_GetHealthFeedback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tikvClient) BroadcastTxnStatus(ctx context.Context, in *kvrpcpb.BroadcastTxnStatusRequest, opts ...grpc.CallOption) (*kvrpcpb.BroadcastTxnStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(kvrpcpb.BroadcastTxnStatusResponse)
	err := c.cc.Invoke(ctx, Tikv_BroadcastTxnStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TikvServer is the server API for Tikv service.
// All implementations must embed UnimplementedTikvServer
// for forward compatibility.
//
// Key/value store API for TiKV.
type TikvServer interface {
	// Commands using a transactional interface.
	KvGet(context.Context, *kvrpcpb.GetRequest) (*kvrpcpb.GetResponse, error)
	KvScan(context.Context, *kvrpcpb.ScanRequest) (*kvrpcpb.ScanResponse, error)
	KvPrewrite(context.Context, *kvrpcpb.PrewriteRequest) (*kvrpcpb.PrewriteResponse, error)
	KvPessimisticLock(context.Context, *kvrpcpb.PessimisticLockRequest) (*kvrpcpb.PessimisticLockResponse, error)
	KVPessimisticRollback(context.Context, *kvrpcpb.PessimisticRollbackRequest) (*kvrpcpb.PessimisticRollbackResponse, error)
	KvTxnHeartBeat(context.Context, *kvrpcpb.TxnHeartBeatRequest) (*kvrpcpb.TxnHeartBeatResponse, error)
	KvCheckTxnStatus(context.Context, *kvrpcpb.CheckTxnStatusRequest) (*kvrpcpb.CheckTxnStatusResponse, error)
	KvCheckSecondaryLocks(context.Context, *kvrpcpb.CheckSecondaryLocksRequest) (*kvrpcpb.CheckSecondaryLocksResponse, error)
	KvCommit(context.Context, *kvrpcpb.CommitRequest) (*kvrpcpb.CommitResponse, error)
	KvImport(context.Context, *kvrpcpb.ImportRequest) (*kvrpcpb.ImportResponse, error)
	KvCleanup(context.Context, *kvrpcpb.CleanupRequest) (*kvrpcpb.CleanupResponse, error)
	KvBatchGet(context.Context, *kvrpcpb.BatchGetRequest) (*kvrpcpb.BatchGetResponse, error)
	KvBatchRollback(context.Context, *kvrpcpb.BatchRollbackRequest) (*kvrpcpb.BatchRollbackResponse, error)
	KvScanLock(context.Context, *kvrpcpb.ScanLockRequest) (*kvrpcpb.ScanLockResponse, error)
	KvResolveLock(context.Context, *kvrpcpb.ResolveLockRequest) (*kvrpcpb.ResolveLockResponse, error)
	KvGC(context.Context, *kvrpcpb.GCRequest) (*kvrpcpb.GCResponse, error)
	KvDeleteRange(context.Context, *kvrpcpb.DeleteRangeRequest) (*kvrpcpb.DeleteRangeResponse, error)
	KvPrepareFlashbackToVersion(context.Context, *kvrpcpb.PrepareFlashbackToVersionRequest) (*kvrpcpb.PrepareFlashbackToVersionResponse, error)
	KvFlashbackToVersion(context.Context, *kvrpcpb.FlashbackToVersionRequest) (*kvrpcpb.FlashbackToVersionResponse, error)
	KvFlush(context.Context, *kvrpcpb.FlushRequest) (*kvrpcpb.FlushResponse, error)
	KvBufferBatchGet(context.Context, *kvrpcpb.BufferBatchGetRequest) (*kvrpcpb.BufferBatchGetResponse, error)
	// Raw commands; no transaction support.
	RawGet(context.Context, *kvrpcpb.RawGetRequest) (*kvrpcpb.RawGetResponse, error)
	RawBatchGet(context.Context, *kvrpcpb.RawBatchGetRequest) (*kvrpcpb.RawBatchGetResponse, error)
	RawPut(context.Context, *kvrpcpb.RawPutRequest) (*kvrpcpb.RawPutResponse, error)
	RawBatchPut(context.Context, *kvrpcpb.RawBatchPutRequest) (*kvrpcpb.RawBatchPutResponse, error)
	RawDelete(context.Context, *kvrpcpb.RawDeleteRequest) (*kvrpcpb.RawDeleteResponse, error)
	RawBatchDelete(context.Context, *kvrpcpb.RawBatchDeleteRequest) (*kvrpcpb.RawBatchDeleteResponse, error)
	RawScan(context.Context, *kvrpcpb.RawScanRequest) (*kvrpcpb.RawScanResponse, error)
	RawDeleteRange(context.Context, *kvrpcpb.RawDeleteRangeRequest) (*kvrpcpb.RawDeleteRangeResponse, error)
	RawBatchScan(context.Context, *kvrpcpb.RawBatchScanRequest) (*kvrpcpb.RawBatchScanResponse, error)
	// Get TTL of the key. Returns 0 if TTL is not set for the key.
	RawGetKeyTTL(context.Context, *kvrpcpb.RawGetKeyTTLRequest) (*kvrpcpb.RawGetKeyTTLResponse, error)
	// Compare if the value in database equals to `RawCASRequest.previous_value` before putting the new value. If not, this request will have no effect and the value in the database will be returned.
	RawCompareAndSwap(context.Context, *kvrpcpb.RawCASRequest) (*kvrpcpb.RawCASResponse, error)
	RawChecksum(context.Context, *kvrpcpb.RawChecksumRequest) (*kvrpcpb.RawChecksumResponse, error)
	// Store commands (sent to a each TiKV node in a cluster, rather than a certain region).
	UnsafeDestroyRange(context.Context, *kvrpcpb.UnsafeDestroyRangeRequest) (*kvrpcpb.UnsafeDestroyRangeResponse, error)
	RegisterLockObserver(context.Context, *kvrpcpb.RegisterLockObserverRequest) (*kvrpcpb.RegisterLockObserverResponse, error)
	CheckLockObserver(context.Context, *kvrpcpb.CheckLockObserverRequest) (*kvrpcpb.CheckLockObserverResponse, error)
	RemoveLockObserver(context.Context, *kvrpcpb.RemoveLockObserverRequest) (*kvrpcpb.RemoveLockObserverResponse, error)
	PhysicalScanLock(context.Context, *kvrpcpb.PhysicalScanLockRequest) (*kvrpcpb.PhysicalScanLockResponse, error)
	// Commands for executing SQL in the TiKV coprocessor (i.e., 'pushed down' to TiKV rather than
	// executed in TiDB).
	Coprocessor(context.Context, *coprocessor.Request) (*coprocessor.Response, error)
	CoprocessorStream(*coprocessor.Request, grpc.ServerStreamingServer[coprocessor.Response]) error
	BatchCoprocessor(*coprocessor.BatchRequest, grpc.ServerStreamingServer[coprocessor.BatchResponse]) error
	// Command send by remote coprocessor to TiKV for executing coprocessor request.
	DelegateCoprocessor(context.Context, *coprocessor.DelegateRequest) (*coprocessor.DelegateResponse, error)
	// Command for executing custom user requests in TiKV coprocessor_v2.
	RawCoprocessor(context.Context, *kvrpcpb.RawCoprocessorRequest) (*kvrpcpb.RawCoprocessorResponse, error)
	// Raft commands (sent between TiKV nodes).
	Raft(grpc.ClientStreamingServer[raft_serverpb.RaftMessage, raft_serverpb.Done]) error
	BatchRaft(grpc.ClientStreamingServer[BatchRaftMessage, raft_serverpb.Done]) error
	Snapshot(grpc.ClientStreamingServer[raft_serverpb.SnapshotChunk, raft_serverpb.Done]) error
	TabletSnapshot(grpc.BidiStreamingServer[raft_serverpb.TabletSnapshotRequest, raft_serverpb.TabletSnapshotResponse]) error
	// Sent from PD or TiDB to a TiKV node.
	SplitRegion(context.Context, *kvrpcpb.SplitRegionRequest) (*kvrpcpb.SplitRegionResponse, error)
	// Sent from TiFlash or TiKV to a TiKV node.
	ReadIndex(context.Context, *kvrpcpb.ReadIndexRequest) (*kvrpcpb.ReadIndexResponse, error)
	// Commands for debugging transactions.
	MvccGetByKey(context.Context, *kvrpcpb.MvccGetByKeyRequest) (*kvrpcpb.MvccGetByKeyResponse, error)
	MvccGetByStartTs(context.Context, *kvrpcpb.MvccGetByStartTsRequest) (*kvrpcpb.MvccGetByStartTsResponse, error)
	// Batched commands.
	BatchCommands(grpc.BidiStreamingServer[BatchCommandsRequest, BatchCommandsResponse]) error
	// These are for mpp execution.
	DispatchMPPTask(context.Context, *mpp.DispatchTaskRequest) (*mpp.DispatchTaskResponse, error)
	CancelMPPTask(context.Context, *mpp.CancelTaskRequest) (*mpp.CancelTaskResponse, error)
	EstablishMPPConnection(*mpp.EstablishMPPConnectionRequest, grpc.ServerStreamingServer[mpp.MPPDataPacket]) error
	IsAlive(context.Context, *mpp.IsAliveRequest) (*mpp.IsAliveResponse, error)
	ReportMPPTaskStatus(context.Context, *mpp.ReportTaskStatusRequest) (*mpp.ReportTaskStatusResponse, error)
	// / CheckLeader sends all information (includes region term and epoch) to other stores.
	// / Once a store receives a request, it checks term and epoch for each region, and sends the regions whose
	// / term and epoch match with local information in the store.
	// / After the client collected all responses from all stores, it checks if got a quorum of responses from
	// / other stores for every region, and decides to advance resolved ts from these regions.
	CheckLeader(context.Context, *kvrpcpb.CheckLeaderRequest) (*kvrpcpb.CheckLeaderResponse, error)
	// / Get the minimal `safe_ts` from regions at the store
	GetStoreSafeTS(context.Context, *kvrpcpb.StoreSafeTSRequest) (*kvrpcpb.StoreSafeTSResponse, error)
	// / Get the information about lock waiting from TiKV.
	GetLockWaitInfo(context.Context, *kvrpcpb.GetLockWaitInfoRequest) (*kvrpcpb.GetLockWaitInfoResponse, error)
	// / Compact a specified key range. This request is not restricted to raft leaders and will not be replicated.
	// / It only compacts data on this node.
	// / TODO: Currently this RPC is designed to be only compatible with TiFlash.
	// / Shall be move out in https://github.com/pingcap/kvproto/issues/912
	Compact(context.Context, *kvrpcpb.CompactRequest) (*kvrpcpb.CompactResponse, error)
	// / Get the information about history lock waiting from TiKV.
	GetLockWaitHistory(context.Context, *kvrpcpb.GetLockWaitHistoryRequest) (*kvrpcpb.GetLockWaitHistoryResponse, error)
	// / Get system table from TiFlash
	GetTiFlashSystemTable(context.Context, *kvrpcpb.TiFlashSystemTableRequest) (*kvrpcpb.TiFlashSystemTableResponse, error)
	// These are for TiFlash disaggregated architecture
	// / Try to lock a S3 object, atomically
	TryAddLock(context.Context, *disaggregated.TryAddLockRequest) (*disaggregated.TryAddLockResponse, error)
	// / Try to delete a S3 object, atomically
	TryMarkDelete(context.Context, *disaggregated.TryMarkDeleteRequest) (*disaggregated.TryMarkDeleteResponse, error)
	// / Build the disaggregated task on TiFlash write node
	EstablishDisaggTask(context.Context, *disaggregated.EstablishDisaggTaskRequest) (*disaggregated.EstablishDisaggTaskResponse, error)
	// / Cancel the disaggregated task on TiFlash write node
	CancelDisaggTask(context.Context, *disaggregated.CancelDisaggTaskRequest) (*disaggregated.CancelDisaggTaskResponse, error)
	// / Exchange page data between TiFlash write node and compute node
	FetchDisaggPages(*disaggregated.FetchDisaggPagesRequest, grpc.ServerStreamingServer[disaggregated.PagesPacket]) error
	// / Compute node get configuration from Write node
	GetDisaggConfig(context.Context, *disaggregated.GetDisaggConfigRequest) (*disaggregated.GetDisaggConfigResponse, error)
	// / Get health feedback info from the TiKV node.
	GetHealthFeedback(context.Context, *kvrpcpb.GetHealthFeedbackRequest) (*kvrpcpb.GetHealthFeedbackResponse, error)
	// / Broadcast the transaction status to all TiKV nodes
	BroadcastTxnStatus(context.Context, *kvrpcpb.BroadcastTxnStatusRequest) (*kvrpcpb.BroadcastTxnStatusResponse, error)
	mustEmbedUnimplementedTikvServer()
}

// UnimplementedTikvServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTikvServer struct{}

func (UnimplementedTikvServer) KvGet(context.Context, *kvrpcpb.GetRequest) (*kvrpcpb.GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvGet not implemented")
}
func (UnimplementedTikvServer) KvScan(context.Context, *kvrpcpb.ScanRequest) (*kvrpcpb.ScanResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvScan not implemented")
}
func (UnimplementedTikvServer) KvPrewrite(context.Context, *kvrpcpb.PrewriteRequest) (*kvrpcpb.PrewriteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvPrewrite not implemented")
}
func (UnimplementedTikvServer) KvPessimisticLock(context.Context, *kvrpcpb.PessimisticLockRequest) (*kvrpcpb.PessimisticLockResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvPessimisticLock not implemented")
}
func (UnimplementedTikvServer) KVPessimisticRollback(context.Context, *kvrpcpb.PessimisticRollbackRequest) (*kvrpcpb.PessimisticRollbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KVPessimisticRollback not implemented")
}
func (UnimplementedTikvServer) KvTxnHeartBeat(context.Context, *kvrpcpb.TxnHeartBeatRequest) (*kvrpcpb.TxnHeartBeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvTxnHeartBeat not implemented")
}
func (UnimplementedTikvServer) KvCheckTxnStatus(context.Context, *kvrpcpb.CheckTxnStatusRequest) (*kvrpcpb.CheckTxnStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvCheckTxnStatus not implemented")
}
func (UnimplementedTikvServer) KvCheckSecondaryLocks(context.Context, *kvrpcpb.CheckSecondaryLocksRequest) (*kvrpcpb.CheckSecondaryLocksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvCheckSecondaryLocks not implemented")
}
func (UnimplementedTikvServer) KvCommit(context.Context, *kvrpcpb.CommitRequest) (*kvrpcpb.CommitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvCommit not implemented")
}
func (UnimplementedTikvServer) KvImport(context.Context, *kvrpcpb.ImportRequest) (*kvrpcpb.ImportResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvImport not implemented")
}
func (UnimplementedTikvServer) KvCleanup(context.Context, *kvrpcpb.CleanupRequest) (*kvrpcpb.CleanupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvCleanup not implemented")
}
func (UnimplementedTikvServer) KvBatchGet(context.Context, *kvrpcpb.BatchGetRequest) (*kvrpcpb.BatchGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvBatchGet not implemented")
}
func (UnimplementedTikvServer) KvBatchRollback(context.Context, *kvrpcpb.BatchRollbackRequest) (*kvrpcpb.BatchRollbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvBatchRollback not implemented")
}
func (UnimplementedTikvServer) KvScanLock(context.Context, *kvrpcpb.ScanLockRequest) (*kvrpcpb.ScanLockResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvScanLock not implemented")
}
func (UnimplementedTikvServer) KvResolveLock(context.Context, *kvrpcpb.ResolveLockRequest) (*kvrpcpb.ResolveLockResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvResolveLock not implemented")
}
func (UnimplementedTikvServer) KvGC(context.Context, *kvrpcpb.GCRequest) (*kvrpcpb.GCResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvGC not implemented")
}
func (UnimplementedTikvServer) KvDeleteRange(context.Context, *kvrpcpb.DeleteRangeRequest) (*kvrpcpb.DeleteRangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvDeleteRange not implemented")
}
func (UnimplementedTikvServer) KvPrepareFlashbackToVersion(context.Context, *kvrpcpb.PrepareFlashbackToVersionRequest) (*kvrpcpb.PrepareFlashbackToVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvPrepareFlashbackToVersion not implemented")
}
func (UnimplementedTikvServer) KvFlashbackToVersion(context.Context, *kvrpcpb.FlashbackToVersionRequest) (*kvrpcpb.FlashbackToVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvFlashbackToVersion not implemented")
}
func (UnimplementedTikvServer) KvFlush(context.Context, *kvrpcpb.FlushRequest) (*kvrpcpb.FlushResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvFlush not implemented")
}
func (UnimplementedTikvServer) KvBufferBatchGet(context.Context, *kvrpcpb.BufferBatchGetRequest) (*kvrpcpb.BufferBatchGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KvBufferBatchGet not implemented")
}
func (UnimplementedTikvServer) RawGet(context.Context, *kvrpcpb.RawGetRequest) (*kvrpcpb.RawGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawGet not implemented")
}
func (UnimplementedTikvServer) RawBatchGet(context.Context, *kvrpcpb.RawBatchGetRequest) (*kvrpcpb.RawBatchGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawBatchGet not implemented")
}
func (UnimplementedTikvServer) RawPut(context.Context, *kvrpcpb.RawPutRequest) (*kvrpcpb.RawPutResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawPut not implemented")
}
func (UnimplementedTikvServer) RawBatchPut(context.Context, *kvrpcpb.RawBatchPutRequest) (*kvrpcpb.RawBatchPutResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawBatchPut not implemented")
}
func (UnimplementedTikvServer) RawDelete(context.Context, *kvrpcpb.RawDeleteRequest) (*kvrpcpb.RawDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawDelete not implemented")
}
func (UnimplementedTikvServer) RawBatchDelete(context.Context, *kvrpcpb.RawBatchDeleteRequest) (*kvrpcpb.RawBatchDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawBatchDelete not implemented")
}
func (UnimplementedTikvServer) RawScan(context.Context, *kvrpcpb.RawScanRequest) (*kvrpcpb.RawScanResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawScan not implemented")
}
func (UnimplementedTikvServer) RawDeleteRange(context.Context, *kvrpcpb.RawDeleteRangeRequest) (*kvrpcpb.RawDeleteRangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawDeleteRange not implemented")
}
func (UnimplementedTikvServer) RawBatchScan(context.Context, *kvrpcpb.RawBatchScanRequest) (*kvrpcpb.RawBatchScanResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawBatchScan not implemented")
}
func (UnimplementedTikvServer) RawGetKeyTTL(context.Context, *kvrpcpb.RawGetKeyTTLRequest) (*kvrpcpb.RawGetKeyTTLResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawGetKeyTTL not implemented")
}
func (UnimplementedTikvServer) RawCompareAndSwap(context.Context, *kvrpcpb.RawCASRequest) (*kvrpcpb.RawCASResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawCompareAndSwap not implemented")
}
func (UnimplementedTikvServer) RawChecksum(context.Context, *kvrpcpb.RawChecksumRequest) (*kvrpcpb.RawChecksumResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawChecksum not implemented")
}
func (UnimplementedTikvServer) UnsafeDestroyRange(context.Context, *kvrpcpb.UnsafeDestroyRangeRequest) (*kvrpcpb.UnsafeDestroyRangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnsafeDestroyRange not implemented")
}
func (UnimplementedTikvServer) RegisterLockObserver(context.Context, *kvrpcpb.RegisterLockObserverRequest) (*kvrpcpb.RegisterLockObserverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterLockObserver not implemented")
}
func (UnimplementedTikvServer) CheckLockObserver(context.Context, *kvrpcpb.CheckLockObserverRequest) (*kvrpcpb.CheckLockObserverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckLockObserver not implemented")
}
func (UnimplementedTikvServer) RemoveLockObserver(context.Context, *kvrpcpb.RemoveLockObserverRequest) (*kvrpcpb.RemoveLockObserverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveLockObserver not implemented")
}
func (UnimplementedTikvServer) PhysicalScanLock(context.Context, *kvrpcpb.PhysicalScanLockRequest) (*kvrpcpb.PhysicalScanLockResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PhysicalScanLock not implemented")
}
func (UnimplementedTikvServer) Coprocessor(context.Context, *coprocessor.Request) (*coprocessor.Response, error) {
	return nil, status.Error(codes.Unimplemented, "method Coprocessor not implemented")
}
func (UnimplementedTikvServer) CoprocessorStream(*coprocessor.Request, grpc.ServerStreamingServer[coprocessor.Response]) error {
	return status.Error(codes.Unimplemented, "method CoprocessorStream not implemented")
}
func (UnimplementedTikvServer) BatchCoprocessor(*coprocessor.BatchRequest, grpc.ServerStreamingServer[coprocessor.BatchResponse]) error {
	return status.Error(codes.Unimplemented, "method BatchCoprocessor not implemented")
}
func (UnimplementedTikvServer) DelegateCoprocessor(context.Context, *coprocessor.DelegateRequest) (*coprocessor.DelegateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DelegateCoprocessor not implemented")
}
func (UnimplementedTikvServer) RawCoprocessor(context.Context, *kvrpcpb.RawCoprocessorRequest) (*kvrpcpb.RawCoprocessorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RawCoprocessor not implemented")
}
func (UnimplementedTikvServer) Raft(grpc.ClientStreamingServer[raft_serverpb.RaftMessage, raft_serverpb.Done]) error {
	return status.Error(codes.Unimplemented, "method Raft not implemented")
}
func (UnimplementedTikvServer) BatchRaft(grpc.ClientStreamingServer[BatchRaftMessage, raft_serverpb.Done]) error {
	return status.Error(codes.Unimplemented, "method BatchRaft not implemented")
}
func (UnimplementedTikvServer) Snapshot(grpc.ClientStreamingServer[raft_serverpb.SnapshotChunk, raft_serverpb.Done]) error {
	return status.Error(codes.Unimplemented, "method Snapshot not implemented")
}
func (UnimplementedTikvServer) TabletSnapshot(grpc.BidiStreamingServer[raft_serverpb.TabletSnapshotRequest, raft_serverpb.TabletSnapshotResponse]) error {
	return status.Error(codes.Unimplemented, "method TabletSnapshot not implemented")
}
func (UnimplementedTikvServer) SplitRegion(context.Context, *kvrpcpb.SplitRegionRequest) (*kvrpcpb.SplitRegionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SplitRegion not implemented")
}
func (UnimplementedTikvServer) ReadIndex(context.Context, *kvrpcpb.ReadIndexRequest) (*kvrpcpb.ReadIndexResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadIndex not implemented")
}
func (UnimplementedTikvServer) MvccGetByKey(context.Context, *kvrpcpb.MvccGetByKeyRequest) (*kvrpcpb.MvccGetByKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MvccGetByKey not implemented")
}
func (UnimplementedTikvServer) MvccGetByStartTs(context.Context, *kvrpcpb.MvccGetByStartTsRequest) (*kvrpcpb.MvccGetByStartTsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MvccGetByStartTs not implemented")
}
func (UnimplementedTikvServer) BatchCommands(grpc.BidiStreamingServer[BatchCommandsRequest, BatchCommandsResponse]) error {
	return status.Error(codes.Unimplemented, "method BatchCommands not implemented")
}
func (UnimplementedTikvServer) DispatchMPPTask(context.Context, *mpp.DispatchTaskRequest) (*mpp.DispatchTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DispatchMPPTask not implemented")
}
func (UnimplementedTikvServer) CancelMPPTask(context.Context, *mpp.CancelTaskRequest) (*mpp.CancelTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelMPPTask not implemented")
}
func (UnimplementedTikvServer) EstablishMPPConnection(*mpp.EstablishMPPConnectionRequest, grpc.ServerStreamingServer[mpp.MPPDataPacket]) error {
	return status.Error(codes.Unimplemented, "method EstablishMPPConnection not implemented")
}
func (UnimplementedTikvServer) IsAlive(context.Context, *mpp.IsAliveRequest) (*mpp.IsAliveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsAlive not implemented")
}
func (UnimplementedTikvServer) ReportMPPTaskStatus(context.Context, *mpp.ReportTaskStatusRequest) (*mpp.ReportTaskStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportMPPTaskStatus not implemented")
}
func (UnimplementedTikvServer) CheckLeader(context.Context, *kvrpcpb.CheckLeaderRequest) (*kvrpcpb.CheckLeaderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckLeader not implemented")
}
func (UnimplementedTikvServer) GetStoreSafeTS(context.Context, *kvrpcpb.StoreSafeTSRequest) (*kvrpcpb.StoreSafeTSResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStoreSafeTS not implemented")
}
func (UnimplementedTikvServer) GetLockWaitInfo(context.Context, *kvrpcpb.GetLockWaitInfoRequest) (*kvrpcpb.GetLockWaitInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLockWaitInfo not implemented")
}
func (UnimplementedTikvServer) Compact(context.Context, *kvrpcpb.CompactRequest) (*kvrpcpb.CompactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Compact not implemented")
}
func (UnimplementedTikvServer) GetLockWaitHistory(context.Context, *kvrpcpb.GetLockWaitHistoryRequest) (*kvrpcpb.GetLockWaitHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLockWaitHistory not implemented")
}
func (UnimplementedTikvServer) GetTiFlashSystemTable(context.Context, *kvrpcpb.TiFlashSystemTableRequest) (*kvrpcpb.TiFlashSystemTableResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTiFlashSystemTable not implemented")
}
func (UnimplementedTikvServer) TryAddLock(context.Context, *disaggregated.TryAddLockRequest) (*disaggregated.TryAddLockResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TryAddLock not implemented")
}
func (UnimplementedTikvServer) TryMarkDelete(context.Context, *disaggregated.TryMarkDeleteRequest) (*disaggregated.TryMarkDeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TryMarkDelete not implemented")
}
func (UnimplementedTikvServer) EstablishDisaggTask(context.Context, *disaggregated.EstablishDisaggTaskRequest) (*disaggregated.EstablishDisaggTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EstablishDisaggTask not implemented")
}
func (UnimplementedTikvServer) CancelDisaggTask(context.Context, *disaggregated.CancelDisaggTaskRequest) (*disaggregated.CancelDisaggTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelDisaggTask not implemented")
}
func (UnimplementedTikvServer) FetchDisaggPages(*disaggregated.FetchDisaggPagesRequest, grpc.ServerStreamingServer[disaggregated.PagesPacket]) error {
	return status.Error(codes.Unimplemented, "method FetchDisaggPages not implemented")
}
func (UnimplementedTikvServer) GetDisaggConfig(context.Context, *disaggregated.GetDisaggConfigRequest) (*disaggregated.GetDisaggConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDisaggConfig not implemented")
}
func (UnimplementedTikvServer) GetHealthFeedback(context.Context, *kvrpcpb.GetHealthFeedbackRequest) (*kvrpcpb.GetHealthFeedbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHealthFeedback not implemented")
}
func (UnimplementedTikvServer) BroadcastTxnStatus(context.Context, *kvrpcpb.BroadcastTxnStatusRequest) (*kvrpcpb.BroadcastTxnStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BroadcastTxnStatus not implemented")
}
func (UnimplementedTikvServer) mustEmbedUnimplementedTikvServer() {}
func (UnimplementedTikvServer) testEmbeddedByValue()              {}

// UnsafeTikvServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TikvServer will
// result in compilation errors.
type UnsafeTikvServer interface {
	mustEmbedUnimplementedTikvServer()
}

func RegisterTikvServer(s grpc.ServiceRegistrar, srv TikvServer) {
	// If the following call panics, it indicates UnimplementedTikvServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Tikv_ServiceDesc, srv)
}

func _Tikv_KvGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvGet(ctx, req.(*kvrpcpb.GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvScan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.ScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvScan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvScan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvScan(ctx, req.(*kvrpcpb.ScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvPrewrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.PrewriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvPrewrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvPrewrite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvPrewrite(ctx, req.(*kvrpcpb.PrewriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvPessimisticLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.PessimisticLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvPessimisticLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvPessimisticLock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvPessimisticLock(ctx, req.(*kvrpcpb.PessimisticLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KVPessimisticRollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.PessimisticRollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KVPessimisticRollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KVPessimisticRollback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KVPessimisticRollback(ctx, req.(*kvrpcpb.PessimisticRollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvTxnHeartBeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.TxnHeartBeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvTxnHeartBeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvTxnHeartBeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvTxnHeartBeat(ctx, req.(*kvrpcpb.TxnHeartBeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvCheckTxnStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.CheckTxnStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvCheckTxnStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvCheckTxnStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvCheckTxnStatus(ctx, req.(*kvrpcpb.CheckTxnStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvCheckSecondaryLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.CheckSecondaryLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvCheckSecondaryLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvCheckSecondaryLocks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvCheckSecondaryLocks(ctx, req.(*kvrpcpb.CheckSecondaryLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvCommit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvCommit(ctx, req.(*kvrpcpb.CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvImport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.ImportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvImport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvImport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvImport(ctx, req.(*kvrpcpb.ImportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvCleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.CleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvCleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvCleanup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvCleanup(ctx, req.(*kvrpcpb.CleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvBatchGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.BatchGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvBatchGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvBatchGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvBatchGet(ctx, req.(*kvrpcpb.BatchGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvBatchRollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.BatchRollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvBatchRollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvBatchRollback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvBatchRollback(ctx, req.(*kvrpcpb.BatchRollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvScanLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.ScanLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvScanLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvScanLock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvScanLock(ctx, req.(*kvrpcpb.ScanLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvResolveLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.ResolveLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvResolveLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvResolveLock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvResolveLock(ctx, req.(*kvrpcpb.ResolveLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvGC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.GCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvGC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvGC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvGC(ctx, req.(*kvrpcpb.GCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvDeleteRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.DeleteRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvDeleteRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvDeleteRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvDeleteRange(ctx, req.(*kvrpcpb.DeleteRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvPrepareFlashbackToVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.PrepareFlashbackToVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvPrepareFlashbackToVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvPrepareFlashbackToVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvPrepareFlashbackToVersion(ctx, req.(*kvrpcpb.PrepareFlashbackToVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvFlashbackToVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.FlashbackToVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvFlashbackToVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvFlashbackToVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvFlashbackToVersion(ctx, req.(*kvrpcpb.FlashbackToVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvFlush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.FlushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvFlush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvFlush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvFlush(ctx, req.(*kvrpcpb.FlushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_KvBufferBatchGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.BufferBatchGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).KvBufferBatchGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_KvBufferBatchGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).KvBufferBatchGet(ctx, req.(*kvrpcpb.BufferBatchGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawGet(ctx, req.(*kvrpcpb.RawGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawBatchGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawBatchGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawBatchGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawBatchGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawBatchGet(ctx, req.(*kvrpcpb.RawBatchGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawPut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawPutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawPut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawPut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawPut(ctx, req.(*kvrpcpb.RawPutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawBatchPut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawBatchPutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawBatchPut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawBatchPut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawBatchPut(ctx, req.(*kvrpcpb.RawBatchPutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawDelete(ctx, req.(*kvrpcpb.RawDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawBatchDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawBatchDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawBatchDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawBatchDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawBatchDelete(ctx, req.(*kvrpcpb.RawBatchDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawScan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawScan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawScan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawScan(ctx, req.(*kvrpcpb.RawScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawDeleteRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawDeleteRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawDeleteRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawDeleteRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawDeleteRange(ctx, req.(*kvrpcpb.RawDeleteRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawBatchScan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawBatchScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawBatchScan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawBatchScan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawBatchScan(ctx, req.(*kvrpcpb.RawBatchScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawGetKeyTTL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawGetKeyTTLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawGetKeyTTL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawGetKeyTTL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawGetKeyTTL(ctx, req.(*kvrpcpb.RawGetKeyTTLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawCompareAndSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawCASRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawCompareAndSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawCompareAndSwap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawCompareAndSwap(ctx, req.(*kvrpcpb.RawCASRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawChecksum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawChecksumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawChecksum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawChecksum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawChecksum(ctx, req.(*kvrpcpb.RawChecksumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_UnsafeDestroyRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.UnsafeDestroyRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).UnsafeDestroyRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_UnsafeDestroyRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).UnsafeDestroyRange(ctx, req.(*kvrpcpb.UnsafeDestroyRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RegisterLockObserver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RegisterLockObserverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RegisterLockObserver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RegisterLockObserver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RegisterLockObserver(ctx, req.(*kvrpcpb.RegisterLockObserverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_CheckLockObserver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.CheckLockObserverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).CheckLockObserver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_CheckLockObserver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).CheckLockObserver(ctx, req.(*kvrpcpb.CheckLockObserverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RemoveLockObserver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RemoveLockObserverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RemoveLockObserver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RemoveLockObserver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RemoveLockObserver(ctx, req.(*kvrpcpb.RemoveLockObserverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_PhysicalScanLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.PhysicalScanLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).PhysicalScanLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_PhysicalScanLock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).PhysicalScanLock(ctx, req.(*kvrpcpb.PhysicalScanLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_Coprocessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(coprocessor.Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).Coprocessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_Coprocessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).Coprocessor(ctx, req.(*coprocessor.Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_CoprocessorStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(coprocessor.Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TikvServer).CoprocessorStream(m, &grpc.GenericServerStream[coprocessor.Request, coprocessor.Response]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_CoprocessorStreamServer = grpc.ServerStreamingServer[coprocessor.Response]

func _Tikv_BatchCoprocessor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(coprocessor.BatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TikvServer).BatchCoprocessor(m, &grpc.GenericServerStream[coprocessor.BatchRequest, coprocessor.BatchResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_BatchCoprocessorServer = grpc.ServerStreamingServer[coprocessor.BatchResponse]

func _Tikv_DelegateCoprocessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(coprocessor.DelegateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).DelegateCoprocessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_DelegateCoprocessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).DelegateCoprocessor(ctx, req.(*coprocessor.DelegateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_RawCoprocessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.RawCoprocessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).RawCoprocessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_RawCoprocessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).RawCoprocessor(ctx, req.(*kvrpcpb.RawCoprocessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_Raft_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TikvServer).Raft(&grpc.GenericServerStream[raft_serverpb.RaftMessage, raft_serverpb.Done]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_RaftServer = grpc.ClientStreamingServer[raft_serverpb.RaftMessage, raft_serverpb.Done]

func _Tikv_BatchRaft_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TikvServer).BatchRaft(&grpc.GenericServerStream[BatchRaftMessage, raft_serverpb.Done]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_BatchRaftServer = grpc.ClientStreamingServer[BatchRaftMessage, raft_serverpb.Done]

func _Tikv_Snapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TikvServer).Snapshot(&grpc.GenericServerStream[raft_serverpb.SnapshotChunk, raft_serverpb.Done]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_SnapshotServer = grpc.ClientStreamingServer[raft_serverpb.SnapshotChunk, raft_serverpb.Done]

func _Tikv_TabletSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TikvServer).TabletSnapshot(&grpc.GenericServerStream[raft_serverpb.TabletSnapshotRequest, raft_serverpb.TabletSnapshotResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_TabletSnapshotServer = grpc.BidiStreamingServer[raft_serverpb.TabletSnapshotRequest, raft_serverpb.TabletSnapshotResponse]

func _Tikv_SplitRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.SplitRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).SplitRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_SplitRegion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).SplitRegion(ctx, req.(*kvrpcpb.SplitRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_ReadIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.ReadIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).ReadIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_ReadIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).ReadIndex(ctx, req.(*kvrpcpb.ReadIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_MvccGetByKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.MvccGetByKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).MvccGetByKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_MvccGetByKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).MvccGetByKey(ctx, req.(*kvrpcpb.MvccGetByKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_MvccGetByStartTs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.MvccGetByStartTsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).MvccGetByStartTs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_MvccGetByStartTs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).MvccGetByStartTs(ctx, req.(*kvrpcpb.MvccGetByStartTsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_BatchCommands_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TikvServer).BatchCommands(&grpc.GenericServerStream[BatchCommandsRequest, BatchCommandsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_BatchCommandsServer = grpc.BidiStreamingServer[BatchCommandsRequest, BatchCommandsResponse]

func _Tikv_DispatchMPPTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mpp.DispatchTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).DispatchMPPTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_DispatchMPPTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).DispatchMPPTask(ctx, req.(*mpp.DispatchTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_CancelMPPTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mpp.CancelTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).CancelMPPTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_CancelMPPTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).CancelMPPTask(ctx, req.(*mpp.CancelTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_EstablishMPPConnection_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(mpp.EstablishMPPConnectionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TikvServer).EstablishMPPConnection(m, &grpc.GenericServerStream[mpp.EstablishMPPConnectionRequest, mpp.MPPDataPacket]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_EstablishMPPConnectionServer = grpc.ServerStreamingServer[mpp.MPPDataPacket]

func _Tikv_IsAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mpp.IsAliveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).IsAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_IsAlive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).IsAlive(ctx, req.(*mpp.IsAliveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_ReportMPPTaskStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mpp.ReportTaskStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).ReportMPPTaskStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_ReportMPPTaskStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).ReportMPPTaskStatus(ctx, req.(*mpp.ReportTaskStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_CheckLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.CheckLeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).CheckLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_CheckLeader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).CheckLeader(ctx, req.(*kvrpcpb.CheckLeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_GetStoreSafeTS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.StoreSafeTSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).GetStoreSafeTS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_GetStoreSafeTS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).GetStoreSafeTS(ctx, req.(*kvrpcpb.StoreSafeTSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_GetLockWaitInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.GetLockWaitInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).GetLockWaitInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_GetLockWaitInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).GetLockWaitInfo(ctx, req.(*kvrpcpb.GetLockWaitInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.CompactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_Compact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).Compact(ctx, req.(*kvrpcpb.CompactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_GetLockWaitHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.GetLockWaitHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).GetLockWaitHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_GetLockWaitHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).GetLockWaitHistory(ctx, req.(*kvrpcpb.GetLockWaitHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_GetTiFlashSystemTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.TiFlashSystemTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).GetTiFlashSystemTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_GetTiFlashSystemTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).GetTiFlashSystemTable(ctx, req.(*kvrpcpb.TiFlashSystemTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_TryAddLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(disaggregated.TryAddLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).TryAddLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_TryAddLock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).TryAddLock(ctx, req.(*disaggregated.TryAddLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_TryMarkDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(disaggregated.TryMarkDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).TryMarkDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_TryMarkDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).TryMarkDelete(ctx, req.(*disaggregated.TryMarkDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_EstablishDisaggTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(disaggregated.EstablishDisaggTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).EstablishDisaggTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_EstablishDisaggTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).EstablishDisaggTask(ctx, req.(*disaggregated.EstablishDisaggTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_CancelDisaggTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(disaggregated.CancelDisaggTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).CancelDisaggTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_CancelDisaggTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).CancelDisaggTask(ctx, req.(*disaggregated.CancelDisaggTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_FetchDisaggPages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(disaggregated.FetchDisaggPagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TikvServer).FetchDisaggPages(m, &grpc.GenericServerStream[disaggregated.FetchDisaggPagesRequest, disaggregated.PagesPacket]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tikv_FetchDisaggPagesServer = grpc.ServerStreamingServer[disaggregated.PagesPacket]

func _Tikv_GetDisaggConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(disaggregated.GetDisaggConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).GetDisaggConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_GetDisaggConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).GetDisaggConfig(ctx, req.(*disaggregated.GetDisaggConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_GetHealthFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.GetHealthFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).GetHealthFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_GetHealthFeedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).GetHealthFeedback(ctx, req.(*kvrpcpb.GetHealthFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tikv_BroadcastTxnStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kvrpcpb.BroadcastTxnStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TikvServer).BroadcastTxnStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tikv_BroadcastTxnStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TikvServer).BroadcastTxnStatus(ctx, req.(*kvrpcpb.BroadcastTxnStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Tikv_ServiceDesc is the grpc.ServiceDesc for Tikv service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tikv_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tikvpb.Tikv",
	HandlerType: (*TikvServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "KvGet",
			Handler:    _Tikv_KvGet_Handler,
		},
		{
			MethodName: "KvScan",
			Handler:    _Tikv_KvScan_Handler,
		},
		{
			MethodName: "KvPrewrite",
			Handler:    _Tikv_KvPrewrite_Handler,
		},
		{
			MethodName: "KvPessimisticLock",
			Handler:    _Tikv_KvPessimisticLock_Handler,
		},
		{
			MethodName: "KVPessimisticRollback",
			Handler:    _Tikv_KVPessimisticRollback_Handler,
		},
		{
			MethodName: "KvTxnHeartBeat",
			Handler:    _Tikv_KvTxnHeartBeat_Handler,
		},
		{
			MethodName: "KvCheckTxnStatus",
			Handler:    _Tikv_KvCheckTxnStatus_Handler,
		},
		{
			MethodName: "KvCheckSecondaryLocks",
			Handler:    _Tikv_KvCheckSecondaryLocks_Handler,
		},
		{
			MethodName: "KvCommit",
			Handler:    _Tikv_KvCommit_Handler,
		},
		{
			MethodName: "KvImport",
			Handler:    _Tikv_KvImport_Handler,
		},
		{
			MethodName: "KvCleanup",
			Handler:    _Tikv_KvCleanup_Handler,
		},
		{
			MethodName: "KvBatchGet",
			Handler:    _Tikv_KvBatchGet_Handler,
		},
		{
			MethodName: "KvBatchRollback",
			Handler:    _Tikv_KvBatchRollback_Handler,
		},
		{
			MethodName: "KvScanLock",
			Handler:    _Tikv_KvScanLock_Handler,
		},
		{
			MethodName: "KvResolveLock",
			Handler:    _Tikv_KvResolveLock_Handler,
		},
		{
			MethodName: "KvGC",
			Handler:    _Tikv_KvGC_Handler,
		},
		{
			MethodName: "KvDeleteRange",
			Handler:    _Tikv_KvDeleteRange_Handler,
		},
		{
			MethodName: "KvPrepareFlashbackToVersion",
			Handler:    _Tikv_KvPrepareFlashbackToVersion_Handler,
		},
		{
			MethodName: "KvFlashbackToVersion",
			Handler:    _Tikv_KvFlashbackToVersion_Handler,
		},
		{
			MethodName: "KvFlush",
			Handler:    _Tikv_KvFlush_Handler,
		},
		{
			MethodName: "KvBufferBatchGet",
			Handler:    _Tikv_KvBufferBatchGet_Handler,
		},
		{
			MethodName: "RawGet",
			Handler:    _Tikv_RawGet_Handler,
		},
		{
			MethodName: "RawBatchGet",
			Handler:    _Tikv_RawBatchGet_Handler,
		},
		{
			MethodName: "RawPut",
			Handler:    _Tikv_RawPut_Handler,
		},
		{
			MethodName: "RawBatchPut",
			Handler:    _Tikv_RawBatchPut_Handler,
		},
		{
			MethodName: "RawDelete",
			Handler:    _Tikv_RawDelete_Handler,
		},
		{
			MethodName: "RawBatchDelete",
			Handler:    _Tikv_RawBatchDelete_Handler,
		},
		{
			MethodName: "RawScan",
			Handler:    _Tikv_RawScan_Handler,
		},
		{
			MethodName: "RawDeleteRange",
			Handler:    _Tikv_RawDeleteRange_Handler,
		},
		{
			MethodName: "RawBatchScan",
			Handler:    _Tikv_RawBatchScan_Handler,
		},
		{
			MethodName: "RawGetKeyTTL",
			Handler:    _Tikv_RawGetKeyTTL_Handler,
		},
		{
			MethodName: "RawCompareAndSwap",
			Handler:    _Tikv_RawCompareAndSwap_Handler,
		},
		{
			MethodName: "RawChecksum",
			Handler:    _Tikv_RawChecksum_Handler,
		},
		{
			MethodName: "UnsafeDestroyRange",
			Handler:    _Tikv_UnsafeDestroyRange_Handler,
		},
		{
			MethodName: "RegisterLockObserver",
			Handler:    _Tikv_RegisterLockObserver_Handler,
		},
		{
			MethodName: "CheckLockObserver",
			Handler:    _Tikv_CheckLockObserver_Handler,
		},
		{
			MethodName: "RemoveLockObserver",
			Handler:    _Tikv_RemoveLockObserver_Handler,
		},
		{
			MethodName: "PhysicalScanLock",
			Handler:    _Tikv_PhysicalScanLock_Handler,
		},
		{
			MethodName: "Coprocessor",
			Handler:    _Tikv_Coprocessor_Handler,
		},
		{
			MethodName: "DelegateCoprocessor",
			Handler:    _Tikv_DelegateCoprocessor_Handler,
		},
		{
			MethodName: "RawCoprocessor",
			Handler:    _Tikv_RawCoprocessor_Handler,
		},
		{
			MethodName: "SplitRegion",
			Handler:    _Tikv_SplitRegion_Handler,
		},
		{
			MethodName: "ReadIndex",
			Handler:    _Tikv_ReadIndex_Handler,
		},
		{
			MethodName: "MvccGetByKey",
			Handler:    _Tikv_MvccGetByKey_Handler,
		},
		{
			MethodName: "MvccGetByStartTs",
			Handler:    _Tikv_MvccGetByStartTs_Handler,
		},
		{
			MethodName: "DispatchMPPTask",
			Handler:    _Tikv_DispatchMPPTask_Handler,
		},
		{
			MethodName: "CancelMPPTask",
			Handler:    _Tikv_CancelMPPTask_Handler,
		},
		{
			MethodName: "IsAlive",
			Handler:    _Tikv_IsAlive_Handler,
		},
		{
			MethodName: "ReportMPPTaskStatus",
			Handler:    _Tikv_ReportMPPTaskStatus_Handler,
		},
		{
			MethodName: "CheckLeader",
			Handler:    _Tikv_CheckLeader_Handler,
		},
		{
			MethodName: "GetStoreSafeTS",
			Handler:    _Tikv_GetStoreSafeTS_Handler,
		},
		{
			MethodName: "GetLockWaitInfo",
			Handler:    _Tikv_GetLockWaitInfo_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _Tikv_Compact_Handler,
		},
		{
			MethodName: "GetLockWaitHistory",
			Handler:    _Tikv_GetLockWaitHistory_Handler,
		},
		{
			MethodName: "GetTiFlashSystemTable",
			Handler:    _Tikv_GetTiFlashSystemTable_Handler,
		},
		{
			MethodName: "tryAddLock",
			Handler:    _Tikv_TryAddLock_Handler,
		},
		{
			MethodName: "tryMarkDelete",
			Handler:    _Tikv_TryMarkDelete_Handler,
		},
		{
			MethodName: "EstablishDisaggTask",
			Handler:    _Tikv_EstablishDisaggTask_Handler,
		},
		{
			MethodName: "CancelDisaggTask",
			Handler:    _Tikv_CancelDisaggTask_Handler,
		},
		{
			MethodName: "GetDisaggConfig",
			Handler:    _Tikv_GetDisaggConfig_Handler,
		},
		{
			MethodName: "GetHealthFeedback",
			Handler:    _Tikv_GetHealthFeedback_Handler,
		},
		{
			MethodName: "BroadcastTxnStatus",
			Handler:    _Tikv_BroadcastTxnStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CoprocessorStream",
			Handler:       _Tikv_CoprocessorStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BatchCoprocessor",
			Handler:       _Tikv_BatchCoprocessor_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Raft",
			Handler:       _Tikv_Raft_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchRaft",
			Handler:       _Tikv_BatchRaft_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Snapshot",
			Handler:       _Tikv_Snapshot_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "TabletSnapshot",
			Handler:       _Tikv_TabletSnapshot_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchCommands",
			Handler:       _Tikv_BatchCommands_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "EstablishMPPConnection",
			Handler:       _Tikv_EstablishMPPConnection_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchDisaggPages",
			Handler:       _Tikv_FetchDisaggPages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "tikvpb.proto",
}
