// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: debugpb.proto

package debugpb

import (
	"context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Debug_Get_FullMethodName                    = "/debugpb.Debug/Get"
	Debug_RaftLog_FullMethodName                = "/debugpb.Debug/RaftLog"
	Debug_RegionInfo_FullMethodName             = "/debugpb.Debug/RegionInfo"
	Debug_RegionSize_FullMethodName             = "/debugpb.Debug/RegionSize"
	Debug_ScanMvcc_FullMethodName               = "/debugpb.Debug/ScanMvcc"
	Debug_Compact_FullMethodName                = "/debugpb.Debug/Compact"
	Debug_InjectFailPoint_FullMethodName        = "/debugpb.Debug/InjectFailPoint"
	Debug_RecoverFailPoint_FullMethodName       = "/debugpb.Debug/RecoverFailPoint"
	Debug_ListFailPoints_FullMethodName         = "/debugpb.Debug/ListFailPoints"
	Debug_GetMetrics_FullMethodName             = "/debugpb.Debug/GetMetrics"
	Debug_CheckRegionConsistency_FullMethodName = "/debugpb.Debug/CheckRegionConsistency"
	Debug_ModifyTikvConfig_FullMethodName       = "/debugpb.Debug/ModifyTikvConfig"
	Debug_GetRegionProperties_FullMethodName    = "/debugpb.Debug/GetRegionProperties"
	Debug_GetStoreInfo_FullMethodName           = "/debugpb.Debug/GetStoreInfo"
	Debug_GetClusterInfo_FullMethodName         = "/debugpb.Debug/GetClusterInfo"
	Debug_GetAllRegionsInStore_FullMethodName   = "/debugpb.Debug/GetAllRegionsInStore"
	Debug_ResetToVersion_FullMethodName         = "/debugpb.Debug/ResetToVersion"
	Debug_GetRangeProperties_FullMethodName     = "/debugpb.Debug/GetRangeProperties"
	Debug_FlashbackToVersion_FullMethodName     = "/debugpb.Debug/FlashbackToVersion"
	Debug_GetRegionReadProgress_FullMethodName  = "/debugpb.Debug/GetRegionReadProgress"
)

// DebugClient is the client API for Debug service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Debug service for TiKV.
//
// Errors are defined as follow:
//   - OK: Okay, we are good!
//   - UNKNOWN: For unknown error.
//   - INVALID_ARGUMENT: Something goes wrong within requests.
//   - NOT_FOUND: It is key or region not found, it's based on context, detailed
//     reason can be found in grpc message.
//
// Note: It bypasses raft layer.
type DebugClient interface {
	// Read a value arbitrarily for a key.
	// Note: Server uses key directly w/o any encoding.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Read raft info.
	RaftLog(ctx context.Context, in *RaftLogRequest, opts ...grpc.CallOption) (*RaftLogResponse, error)
	RegionInfo(ctx context.Context, in *RegionInfoRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error)
	// Calculate size of a region.
	// Note: DO NOT CALL IT IN PRODUCTION, it's really expensive.
	RegionSize(ctx context.Context, in *RegionSizeRequest, opts ...grpc.CallOption) (*RegionSizeResponse, error)
	// Scan a specific range.
	// Note: DO NOT CALL IT IN PRODUCTION, it's really expensive.
	//
	//	Server uses keys directly w/o any encoding.
	ScanMvcc(ctx context.Context, in *ScanMvccRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ScanMvccResponse], error)
	// Compact a column family in a specified range.
	// Note: Server uses keys directly w/o any encoding.
	Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error)
	// Inject a fail point. Currently, it's only used in tests.
	// Note: DO NOT CALL IT IN PRODUCTION.
	InjectFailPoint(ctx context.Context, in *InjectFailPointRequest, opts ...grpc.CallOption) (*InjectFailPointResponse, error)
	// Recover from a fail point.
	RecoverFailPoint(ctx context.Context, in *RecoverFailPointRequest, opts ...grpc.CallOption) (*RecoverFailPointResponse, error)
	// List all fail points.
	ListFailPoints(ctx context.Context, in *ListFailPointsRequest, opts ...grpc.CallOption) (*ListFailPointsResponse, error)
	// Get Metrics
	GetMetrics(ctx context.Context, in *GetMetricsRequest, opts ...grpc.CallOption) (*GetMetricsResponse, error)
	// Do a consistent check for a region.
	CheckRegionConsistency(ctx context.Context, in *RegionConsistencyCheckRequest, opts ...grpc.CallOption) (*RegionConsistencyCheckResponse, error)
	// dynamically modify tikv's config
	ModifyTikvConfig(ctx context.Context, in *ModifyTikvConfigRequest, opts ...grpc.CallOption) (*ModifyTikvConfigResponse, error)
	// Get region properties
	GetRegionProperties(ctx context.Context, in *GetRegionPropertiesRequest, opts ...grpc.CallOption) (*GetRegionPropertiesResponse, error)
	// Get store ID
	GetStoreInfo(ctx context.Context, in *GetStoreInfoRequest, opts ...grpc.CallOption) (*GetStoreInfoResponse, error)
	// Get cluster ID
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	// Get all region IDs in the store
	GetAllRegionsInStore(ctx context.Context, in *GetAllRegionsInStoreRequest, opts ...grpc.CallOption) (*GetAllRegionsInStoreResponse, error)
	// Make this TiKV node return to the status on this node to certain ts.
	ResetToVersion(ctx context.Context, in *ResetToVersionRequest, opts ...grpc.CallOption) (*ResetToVersionResponse, error)
	// Get range properties
	GetRangeProperties(ctx context.Context, in *GetRangePropertiesRequest, opts ...grpc.CallOption) (*GetRangePropertiesResponse, error)
	// Flashback given key range to a specified version.
	FlashbackToVersion(ctx context.Context, in *FlashbackToVersionRequest, opts ...grpc.CallOption) (*FlashbackToVersionResponse, error)
	// GetRegionReadProgress returns the some useful info in RegionReadProgress
	GetRegionReadProgress(ctx context.Context, in *GetRegionReadProgressRequest, opts ...grpc.CallOption) (*GetRegionReadProgressResponse, error)
}

type debugClient struct {
	cc grpc.ClientConnInterface
}

func NewDebugClient(cc grpc.ClientConnInterface) DebugClient {
	return &debugClient{cc}
}

func (c *debugClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, Debug_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) RaftLog(ctx context.Context, in *RaftLogRequest, opts ...grpc.CallOption) (*RaftLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RaftLogResponse)
	err := c.cc.Invoke(ctx, Debug_RaftLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) RegionInfo(ctx context.Context, in *RegionInfoRequest, opts ...grpc.CallOption) (*RegionInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegionInfoResponse)
	err := c.cc.Invoke(ctx, Debug_RegionInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) RegionSize(ctx context.Context, in *RegionSizeRequest, opts ...grpc.CallOption) (*RegionSizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegionSizeResponse)
	err := c.cc.Invoke(ctx, Debug_RegionSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) ScanMvcc(ctx context.Context, in *ScanMvccRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ScanMvccResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Debug_ServiceDesc.Streams[0], Debug_ScanMvcc_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ScanMvccRequest, ScanMvccResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Debug_ScanMvccClient = grpc.ServerStreamingClient[ScanMvccResponse]

func (c *debugClient) Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompactResponse)
	err := c.cc.Invoke(ctx, Debug_Compact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) InjectFailPoint(ctx context.Context, in *InjectFailPointRequest, opts ...grpc.CallOption) (*InjectFailPointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InjectFailPointResponse)
	err := c.cc.Invoke(ctx, Debug_InjectFailPoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) RecoverFailPoint(ctx context.Context, in *RecoverFailPointRequest, opts ...grpc.CallOption) (*RecoverFailPointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecoverFailPointResponse)
	err := c.cc.Invoke(ctx, Debug_RecoverFailPoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) ListFailPoints(ctx context.Context, in *ListFailPointsRequest, opts ...grpc.CallOption) (*ListFailPointsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFailPointsResponse)
	err := c.cc.Invoke(ctx, Debug_ListFailPoints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetMetrics(ctx context.Context, in *GetMetricsRequest, opts ...grpc.CallOption) (*GetMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMetricsResponse)
	err := c.cc.Invoke(ctx, Debug_GetMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) CheckRegionConsistency(ctx context.Context, in *RegionConsistencyCheckRequest, opts ...grpc.CallOption) (*RegionConsistencyCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegionConsistencyCheckResponse)
	err := c.cc.Invoke(ctx, Debug_CheckRegionConsistency_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) ModifyTikvConfig(ctx context.Context, in *ModifyTikvConfigRequest, opts ...grpc.CallOption) (*ModifyTikvConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyTikvConfigResponse)
	err := c.cc.Invoke(ctx, Debug_ModifyTikvConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetRegionProperties(ctx context.Context, in *GetRegionPropertiesRequest, opts ...grpc.CallOption) (*GetRegionPropertiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegionPropertiesResponse)
	err := c.cc.Invoke(ctx, Debug_GetRegionProperties_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetStoreInfo(ctx context.Context, in *GetStoreInfoRequest, opts ...grpc.CallOption) (*GetStoreInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStoreInfoResponse)
	err := c.cc.Invoke(ctx, Debug_GetStoreInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, Debug_GetClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetAllRegionsInStore(ctx context.Context, in *GetAllRegionsInStoreRequest, opts ...grpc.CallOption) (*GetAllRegionsInStoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllRegionsInStoreResponse)
	err := c.cc.Invoke(ctx, Debug_GetAllRegionsInStore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) ResetToVersion(ctx context.Context, in *ResetToVersionRequest, opts ...grpc.CallOption) (*ResetToVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetToVersionResponse)
	err := c.cc.Invoke(ctx, Debug_ResetToVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetRangeProperties(ctx context.Context, in *GetRangePropertiesRequest, opts ...grpc.CallOption) (*GetRangePropertiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRangePropertiesResponse)
	err := c.cc.Invoke(ctx, Debug_GetRangeProperties_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) FlashbackToVersion(ctx context.Context, in *FlashbackToVersionRequest, opts ...grpc.CallOption) (*FlashbackToVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FlashbackToVersionResponse)
	err := c.cc.Invoke(ctx, Debug_FlashbackToVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) GetRegionReadProgress(ctx context.Context, in *GetRegionReadProgressRequest, opts ...grpc.CallOption) (*GetRegionReadProgressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegionReadProgressResponse)
	err := c.cc.Invoke(ctx, Debug_GetRegionReadProgress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DebugServer is the server API for Debug service.
// All implementations must embed UnimplementedDebugServer
// for forward compatibility.
//
// Debug service for TiKV.
//
// Errors are defined as follow:
//   - OK: Okay, we are good!
//   - UNKNOWN: For unknown error.
//   - INVALID_ARGUMENT: Something goes wrong within requests.
//   - NOT_FOUND: It is key or region not found, it's based on context, detailed
//     reason can be found in grpc message.
//
// Note: It bypasses raft layer.
type DebugServer interface {
	// Read a value arbitrarily for a key.
	// Note: Server uses key directly w/o any encoding.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// Read raft info.
	RaftLog(context.Context, *RaftLogRequest) (*RaftLogResponse, error)
	RegionInfo(context.Context, *RegionInfoRequest) (*RegionInfoResponse, error)
	// Calculate size of a region.
	// Note: DO NOT CALL IT IN PRODUCTION, it's really expensive.
	RegionSize(context.Context, *RegionSizeRequest) (*RegionSizeResponse, error)
	// Scan a specific range.
	// Note: DO NOT CALL IT IN PRODUCTION, it's really expensive.
	//
	//	Server uses keys directly w/o any encoding.
	ScanMvcc(*ScanMvccRequest, grpc.ServerStreamingServer[ScanMvccResponse]) error
	// Compact a column family in a specified range.
	// Note: Server uses keys directly w/o any encoding.
	Compact(context.Context, *CompactRequest) (*CompactResponse, error)
	// Inject a fail point. Currently, it's only used in tests.
	// Note: DO NOT CALL IT IN PRODUCTION.
	InjectFailPoint(context.Context, *InjectFailPointRequest) (*InjectFailPointResponse, error)
	// Recover from a fail point.
	RecoverFailPoint(context.Context, *RecoverFailPointRequest) (*RecoverFailPointResponse, error)
	// List all fail points.
	ListFailPoints(context.Context, *ListFailPointsRequest) (*ListFailPointsResponse, error)
	// Get Metrics
	GetMetrics(context.Context, *GetMetricsRequest) (*GetMetricsResponse, error)
	// Do a consistent check for a region.
	CheckRegionConsistency(context.Context, *RegionConsistencyCheckRequest) (*RegionConsistencyCheckResponse, error)
	// dynamically modify tikv's config
	ModifyTikvConfig(context.Context, *ModifyTikvConfigRequest) (*ModifyTikvConfigResponse, error)
	// Get region properties
	GetRegionProperties(context.Context, *GetRegionPropertiesRequest) (*GetRegionPropertiesResponse, error)
	// Get store ID
	GetStoreInfo(context.Context, *GetStoreInfoRequest) (*GetStoreInfoResponse, error)
	// Get cluster ID
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	// Get all region IDs in the store
	GetAllRegionsInStore(context.Context, *GetAllRegionsInStoreRequest) (*GetAllRegionsInStoreResponse, error)
	// Make this TiKV node return to the status on this node to certain ts.
	ResetToVersion(context.Context, *ResetToVersionRequest) (*ResetToVersionResponse, error)
	// Get range properties
	GetRangeProperties(context.Context, *GetRangePropertiesRequest) (*GetRangePropertiesResponse, error)
	// Flashback given key range to a specified version.
	FlashbackToVersion(context.Context, *FlashbackToVersionRequest) (*FlashbackToVersionResponse, error)
	// GetRegionReadProgress returns the some useful info in RegionReadProgress
	GetRegionReadProgress(context.Context, *GetRegionReadProgressRequest) (*GetRegionReadProgressResponse, error)
	mustEmbedUnimplementedDebugServer()
}

// UnimplementedDebugServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDebugServer struct{}

func (UnimplementedDebugServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDebugServer) RaftLog(context.Context, *RaftLogRequest) (*RaftLogResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RaftLog not implemented")
}
func (UnimplementedDebugServer) RegionInfo(context.Context, *RegionInfoRequest) (*RegionInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegionInfo not implemented")
}
func (UnimplementedDebugServer) RegionSize(context.Context, *RegionSizeRequest) (*RegionSizeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegionSize not implemented")
}
func (UnimplementedDebugServer) ScanMvcc(*ScanMvccRequest, grpc.ServerStreamingServer[ScanMvccResponse]) error {
	return status.Error(codes.Unimplemented, "method ScanMvcc not implemented")
}
func (UnimplementedDebugServer) Compact(context.Context, *CompactRequest) (*CompactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Compact not implemented")
}
func (UnimplementedDebugServer) InjectFailPoint(context.Context, *InjectFailPointRequest) (*InjectFailPointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InjectFailPoint not implemented")
}
func (UnimplementedDebugServer) RecoverFailPoint(context.Context, *RecoverFailPointRequest) (*RecoverFailPointResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecoverFailPoint not implemented")
}
func (UnimplementedDebugServer) ListFailPoints(context.Context, *ListFailPointsRequest) (*ListFailPointsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListFailPoints not implemented")
}
func (UnimplementedDebugServer) GetMetrics(context.Context, *GetMetricsRequest) (*GetMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedDebugServer) CheckRegionConsistency(context.Context, *RegionConsistencyCheckRequest) (*RegionConsistencyCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckRegionConsistency not implemented")
}
func (UnimplementedDebugServer) ModifyTikvConfig(context.Context, *ModifyTikvConfigRequest) (*ModifyTikvConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ModifyTikvConfig not implemented")
}
func (UnimplementedDebugServer) GetRegionProperties(context.Context, *GetRegionPropertiesRequest) (*GetRegionPropertiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRegionProperties not implemented")
}
func (UnimplementedDebugServer) GetStoreInfo(context.Context, *GetStoreInfoRequest) (*GetStoreInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStoreInfo not implemented")
}
func (UnimplementedDebugServer) GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedDebugServer) GetAllRegionsInStore(context.Context, *GetAllRegionsInStoreRequest) (*GetAllRegionsInStoreResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllRegionsInStore not implemented")
}
func (UnimplementedDebugServer) ResetToVersion(context.Context, *ResetToVersionRequest) (*ResetToVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetToVersion not implemented")
}
func (UnimplementedDebugServer) GetRangeProperties(context.Context, *GetRangePropertiesRequest) (*GetRangePropertiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRangeProperties not implemented")
}
func (UnimplementedDebugServer) FlashbackToVersion(context.Context, *FlashbackToVersionRequest) (*FlashbackToVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FlashbackToVersion not implemented")
}
func (UnimplementedDebugServer) GetRegionReadProgress(context.Context, *GetRegionReadProgressRequest) (*GetRegionReadProgressResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRegionReadProgress not implemented")
}
func (UnimplementedDebugServer) mustEmbedUnimplementedDebugServer() {}
func (UnimplementedDebugServer) testEmbeddedByValue()               {}

// UnsafeDebugServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DebugServer will
// result in compilation errors.
type UnsafeDebugServer interface {
	mustEmbedUnimplementedDebugServer()
}

func RegisterDebugServer(s grpc.ServiceRegistrar, srv DebugServer) {
	// If the following call panics, it indicates UnimplementedDebugServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Debug_ServiceDesc, srv)
}

func _Debug_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_RaftLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).RaftLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_RaftLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).RaftLog(ctx, req.(*RaftLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_RegionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).RegionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_RegionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).RegionInfo(ctx, req.(*RegionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_RegionSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).RegionSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_RegionSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).RegionSize(ctx, req.(*RegionSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_ScanMvcc_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ScanMvccRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugServer).ScanMvcc(m, &grpc.GenericServerStream[ScanMvccRequest, ScanMvccResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Debug_ScanMvccServer = grpc.ServerStreamingServer[ScanMvccResponse]

func _Debug_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_Compact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).Compact(ctx, req.(*CompactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_InjectFailPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InjectFailPointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).InjectFailPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_InjectFailPoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).InjectFailPoint(ctx, req.(*InjectFailPointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_RecoverFailPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecoverFailPointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).RecoverFailPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_RecoverFailPoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).RecoverFailPoint(ctx, req.(*RecoverFailPointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_ListFailPoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFailPointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).ListFailPoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_ListFailPoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).ListFailPoints(ctx, req.(*ListFailPointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetMetrics(ctx, req.(*GetMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_CheckRegionConsistency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionConsistencyCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).CheckRegionConsistency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_CheckRegionConsistency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).CheckRegionConsistency(ctx, req.(*RegionConsistencyCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_ModifyTikvConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyTikvConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).ModifyTikvConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_ModifyTikvConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).ModifyTikvConfig(ctx, req.(*ModifyTikvConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetRegionProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionPropertiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetRegionProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetRegionProperties_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetRegionProperties(ctx, req.(*GetRegionPropertiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetStoreInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStoreInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetStoreInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetStoreInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetStoreInfo(ctx, req.(*GetStoreInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetAllRegionsInStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllRegionsInStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetAllRegionsInStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetAllRegionsInStore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetAllRegionsInStore(ctx, req.(*GetAllRegionsInStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_ResetToVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetToVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).ResetToVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_ResetToVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).ResetToVersion(ctx, req.(*ResetToVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetRangeProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRangePropertiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetRangeProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetRangeProperties_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetRangeProperties(ctx, req.(*GetRangePropertiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_FlashbackToVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlashbackToVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).FlashbackToVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_FlashbackToVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).FlashbackToVersion(ctx, req.(*FlashbackToVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_GetRegionReadProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionReadProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).GetRegionReadProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Debug_GetRegionReadProgress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).GetRegionReadProgress(ctx, req.(*GetRegionReadProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Debug_ServiceDesc is the grpc.ServiceDesc for Debug service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Debug_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "debugpb.Debug",
	HandlerType: (*DebugServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Debug_Get_Handler,
		},
		{
			MethodName: "RaftLog",
			Handler:    _Debug_RaftLog_Handler,
		},
		{
			MethodName: "RegionInfo",
			Handler:    _Debug_RegionInfo_Handler,
		},
		{
			MethodName: "RegionSize",
			Handler:    _Debug_RegionSize_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _Debug_Compact_Handler,
		},
		{
			MethodName: "InjectFailPoint",
			Handler:    _Debug_InjectFailPoint_Handler,
		},
		{
			MethodName: "RecoverFailPoint",
			Handler:    _Debug_RecoverFailPoint_Handler,
		},
		{
			MethodName: "ListFailPoints",
			Handler:    _Debug_ListFailPoints_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _Debug_GetMetrics_Handler,
		},
		{
			MethodName: "CheckRegionConsistency",
			Handler:    _Debug_CheckRegionConsistency_Handler,
		},
		{
			MethodName: "ModifyTikvConfig",
			Handler:    _Debug_ModifyTikvConfig_Handler,
		},
		{
			MethodName: "GetRegionProperties",
			Handler:    _Debug_GetRegionProperties_Handler,
		},
		{
			MethodName: "GetStoreInfo",
			Handler:    _Debug_GetStoreInfo_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _Debug_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetAllRegionsInStore",
			Handler:    _Debug_GetAllRegionsInStore_Handler,
		},
		{
			MethodName: "ResetToVersion",
			Handler:    _Debug_ResetToVersion_Handler,
		},
		{
			MethodName: "GetRangeProperties",
			Handler:    _Debug_GetRangeProperties_Handler,
		},
		{
			MethodName: "FlashbackToVersion",
			Handler:    _Debug_FlashbackToVersion_Handler,
		},
		{
			MethodName: "GetRegionReadProgress",
			Handler:    _Debug_GetRegionReadProgress_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ScanMvcc",
			Handler:       _Debug_ScanMvcc_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "debugpb.proto",
}
