// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: raft_serverpb.proto

package raft_serverpb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	disk_usage "github.com/pingcap/kvproto/pkg/disk_usage"
	encryptionpb "github.com/pingcap/kvproto/pkg/encryptionpb"
	eraftpb "github.com/pingcap/kvproto/pkg/eraftpb"
	kvrpcpb "github.com/pingcap/kvproto/pkg/kvrpcpb"
	metapb "github.com/pingcap/kvproto/pkg/metapb"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PeerState int32

const (
	PeerState_Normal    PeerState = 0
	PeerState_Applying  PeerState = 1
	PeerState_Tombstone PeerState = 2
	PeerState_Merging   PeerState = 3
	// Currently used for witness to non-witness conversion: When a witness
	// has just become a non-witness, we need to set and persist this state,
	// so that when the service restarts before applying snapshot, we can
	// actively request snapshot when initializing this peer.
	PeerState_Unavailable PeerState = 4
)

// Enum value maps for PeerState.
var (
	PeerState_name = map[int32]string{
		0: "Normal",
		1: "Applying",
		2: "Tombstone",
		3: "Merging",
		4: "Unavailable",
	}
	PeerState_value = map[string]int32{
		"Normal":      0,
		"Applying":    1,
		"Tombstone":   2,
		"Merging":     3,
		"Unavailable": 4,
	}
)

func (x PeerState) Enum() *PeerState {
	p := new(PeerState)
	*p = x
	return p
}

func (x PeerState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PeerState) Descriptor() protoreflect.EnumDescriptor {
	return file_raft_serverpb_proto_enumTypes[0].Descriptor()
}

func (PeerState) Type() protoreflect.EnumType {
	return &file_raft_serverpb_proto_enumTypes[0]
}

func (x PeerState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PeerState.Descriptor instead.
func (PeerState) EnumDescriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{0}
}

type ExtraMessageType int32

const (
	ExtraMessageType_MsgRegionWakeUp           ExtraMessageType = 0
	ExtraMessageType_MsgWantRollbackMerge      ExtraMessageType = 1
	ExtraMessageType_MsgCheckStalePeer         ExtraMessageType = 2
	ExtraMessageType_MsgCheckStalePeerResponse ExtraMessageType = 3
	// If leader is going to sleep, it will send requests to all its followers
	// to make sure they all agree to sleep.
	ExtraMessageType_MsgHibernateRequest                 ExtraMessageType = 4
	ExtraMessageType_MsgHibernateResponse                ExtraMessageType = 5
	ExtraMessageType_MsgRejectRaftLogCausedByMemoryUsage ExtraMessageType = 6
	ExtraMessageType_MsgAvailabilityRequest              ExtraMessageType = 7
	ExtraMessageType_MsgAvailabilityResponse             ExtraMessageType = 8
	ExtraMessageType_MsgVoterReplicatedIndexRequest      ExtraMessageType = 9
	ExtraMessageType_MsgVoterReplicatedIndexResponse     ExtraMessageType = 10
	// Message means that `from` is tombstone. Leader can then update removed_records.
	ExtraMessageType_MsgGcPeerRequest  ExtraMessageType = 11
	ExtraMessageType_MsgGcPeerResponse ExtraMessageType = 12
	ExtraMessageType_MsgFlushMemtable  ExtraMessageType = 13
	ExtraMessageType_MsgRefreshBuckets ExtraMessageType = 14
	// Messages for the snapshot gen precheck process.
	ExtraMessageType_MsgSnapGenPrecheckRequest  ExtraMessageType = 15
	ExtraMessageType_MsgSnapGenPrecheckResponse ExtraMessageType = 16
	// Used in transfer leader process for leader to inform follower to load the
	// region into in-memory engine if the relevant region is cached.
	ExtraMessageType_MsgPreLoadRegionRequest ExtraMessageType = 17
	// Used in transfer leader process for follower to inform leader the completes
	// of the region cache
	ExtraMessageType_MsgPreLoadRegionResponse ExtraMessageType = 18
)

// Enum value maps for ExtraMessageType.
var (
	ExtraMessageType_name = map[int32]string{
		0:  "MsgRegionWakeUp",
		1:  "MsgWantRollbackMerge",
		2:  "MsgCheckStalePeer",
		3:  "MsgCheckStalePeerResponse",
		4:  "MsgHibernateRequest",
		5:  "MsgHibernateResponse",
		6:  "MsgRejectRaftLogCausedByMemoryUsage",
		7:  "MsgAvailabilityRequest",
		8:  "MsgAvailabilityResponse",
		9:  "MsgVoterReplicatedIndexRequest",
		10: "MsgVoterReplicatedIndexResponse",
		11: "MsgGcPeerRequest",
		12: "MsgGcPeerResponse",
		13: "MsgFlushMemtable",
		14: "MsgRefreshBuckets",
		15: "MsgSnapGenPrecheckRequest",
		16: "MsgSnapGenPrecheckResponse",
		17: "MsgPreLoadRegionRequest",
		18: "MsgPreLoadRegionResponse",
	}
	ExtraMessageType_value = map[string]int32{
		"MsgRegionWakeUp":                     0,
		"MsgWantRollbackMerge":                1,
		"MsgCheckStalePeer":                   2,
		"MsgCheckStalePeerResponse":           3,
		"MsgHibernateRequest":                 4,
		"MsgHibernateResponse":                5,
		"MsgRejectRaftLogCausedByMemoryUsage": 6,
		"MsgAvailabilityRequest":              7,
		"MsgAvailabilityResponse":             8,
		"MsgVoterReplicatedIndexRequest":      9,
		"MsgVoterReplicatedIndexResponse":     10,
		"MsgGcPeerRequest":                    11,
		"MsgGcPeerResponse":                   12,
		"MsgFlushMemtable":                    13,
		"MsgRefreshBuckets":                   14,
		"MsgSnapGenPrecheckRequest":           15,
		"MsgSnapGenPrecheckResponse":          16,
		"MsgPreLoadRegionRequest":             17,
		"MsgPreLoadRegionResponse":            18,
	}
)

func (x ExtraMessageType) Enum() *ExtraMessageType {
	p := new(ExtraMessageType)
	*p = x
	return p
}

func (x ExtraMessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExtraMessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_raft_serverpb_proto_enumTypes[1].Descriptor()
}

func (ExtraMessageType) Type() protoreflect.EnumType {
	return &file_raft_serverpb_proto_enumTypes[1]
}

func (x ExtraMessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ExtraMessageType.Descriptor instead.
func (ExtraMessageType) EnumDescriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{1}
}

type RaftMessage struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	RegionId    uint64                 `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	FromPeer    *metapb.Peer           `protobuf:"bytes,2,opt,name=from_peer,json=fromPeer,proto3" json:"from_peer,omitempty"`
	ToPeer      *metapb.Peer           `protobuf:"bytes,3,opt,name=to_peer,json=toPeer,proto3" json:"to_peer,omitempty"`
	Message     *eraftpb.Message       `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	RegionEpoch *metapb.RegionEpoch    `protobuf:"bytes,5,opt,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	// true means to_peer is a tombstone peer and it should remove itself.
	IsTombstone bool `protobuf:"varint,6,opt,name=is_tombstone,json=isTombstone,proto3" json:"is_tombstone,omitempty"`
	// Region key range [start_key, end_key).
	StartKey []byte `protobuf:"bytes,7,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,8,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// If it has value, to_peer should be removed if merge is never going to complete.
	MergeTarget   *metapb.Region       `protobuf:"bytes,9,opt,name=merge_target,json=mergeTarget,proto3" json:"merge_target,omitempty"`
	ExtraMsg      *ExtraMessage        `protobuf:"bytes,10,opt,name=extra_msg,json=extraMsg,proto3" json:"extra_msg,omitempty"`
	ExtraCtx      []byte               `protobuf:"bytes,11,opt,name=extra_ctx,json=extraCtx,proto3" json:"extra_ctx,omitempty"`
	DiskUsage     disk_usage.DiskUsage `protobuf:"varint,12,opt,name=disk_usage,json=diskUsage,proto3,enum=disk_usage.DiskUsage" json:"disk_usage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RaftMessage) Reset() {
	*x = RaftMessage{}
	mi := &file_raft_serverpb_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RaftMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RaftMessage) ProtoMessage() {}

func (x *RaftMessage) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RaftMessage.ProtoReflect.Descriptor instead.
func (*RaftMessage) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{0}
}

func (x *RaftMessage) GetRegionId() uint64 {
	if x != nil {
		return x.RegionId
	}
	return 0
}

func (x *RaftMessage) GetFromPeer() *metapb.Peer {
	if x != nil {
		return x.FromPeer
	}
	return nil
}

func (x *RaftMessage) GetToPeer() *metapb.Peer {
	if x != nil {
		return x.ToPeer
	}
	return nil
}

func (x *RaftMessage) GetMessage() *eraftpb.Message {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *RaftMessage) GetRegionEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.RegionEpoch
	}
	return nil
}

func (x *RaftMessage) GetIsTombstone() bool {
	if x != nil {
		return x.IsTombstone
	}
	return false
}

func (x *RaftMessage) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *RaftMessage) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *RaftMessage) GetMergeTarget() *metapb.Region {
	if x != nil {
		return x.MergeTarget
	}
	return nil
}

func (x *RaftMessage) GetExtraMsg() *ExtraMessage {
	if x != nil {
		return x.ExtraMsg
	}
	return nil
}

func (x *RaftMessage) GetExtraCtx() []byte {
	if x != nil {
		return x.ExtraCtx
	}
	return nil
}

func (x *RaftMessage) GetDiskUsage() disk_usage.DiskUsage {
	if x != nil {
		return x.DiskUsage
	}
	return disk_usage.DiskUsage(0)
}

type RaftTruncatedState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Index         uint64                 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Term          uint64                 `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RaftTruncatedState) Reset() {
	*x = RaftTruncatedState{}
	mi := &file_raft_serverpb_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RaftTruncatedState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RaftTruncatedState) ProtoMessage() {}

func (x *RaftTruncatedState) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RaftTruncatedState.ProtoReflect.Descriptor instead.
func (*RaftTruncatedState) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{1}
}

func (x *RaftTruncatedState) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *RaftTruncatedState) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

type SnapshotCFFile struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cf            string                 `protobuf:"bytes,1,opt,name=cf,proto3" json:"cf,omitempty"`
	Size          uint64                 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Checksum      uint32                 `protobuf:"varint,3,opt,name=checksum,proto3" json:"checksum,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SnapshotCFFile) Reset() {
	*x = SnapshotCFFile{}
	mi := &file_raft_serverpb_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SnapshotCFFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SnapshotCFFile) ProtoMessage() {}

func (x *SnapshotCFFile) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SnapshotCFFile.ProtoReflect.Descriptor instead.
func (*SnapshotCFFile) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{2}
}

func (x *SnapshotCFFile) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *SnapshotCFFile) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *SnapshotCFFile) GetChecksum() uint32 {
	if x != nil {
		return x.Checksum
	}
	return 0
}

type SnapshotMeta struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	CfFiles []*SnapshotCFFile      `protobuf:"bytes,1,rep,name=cf_files,json=cfFiles,proto3" json:"cf_files,omitempty"`
	// true means this snapshot is triggered for load balance
	ForBalance bool `protobuf:"varint,2,opt,name=for_balance,json=forBalance,proto3" json:"for_balance,omitempty"`
	// true means this is an empty snapshot for witness
	ForWitness bool `protobuf:"varint,3,opt,name=for_witness,json=forWitness,proto3" json:"for_witness,omitempty"`
	// the timestamp second to generate snapshot
	Start uint64 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	// the duration of generating snapshot
	GenerateDurationSec uint64 `protobuf:"varint,5,opt,name=generate_duration_sec,json=generateDurationSec,proto3" json:"generate_duration_sec,omitempty"`
	// the path of the tablet snapshot, it should only be used for v1 to receive
	// snapshot from v2
	TabletSnapPath string `protobuf:"bytes,6,opt,name=tablet_snap_path,json=tabletSnapPath,proto3" json:"tablet_snap_path,omitempty"`
	// A hint of the latest commit index on leader when sending snapshot.
	// It should only be used for v2 to send snapshot to v1.
	// See https://github.com/pingcap/tiflash/issues/7568
	CommitIndexHint uint64 `protobuf:"varint,7,opt,name=commit_index_hint,json=commitIndexHint,proto3" json:"commit_index_hint,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SnapshotMeta) Reset() {
	*x = SnapshotMeta{}
	mi := &file_raft_serverpb_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SnapshotMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SnapshotMeta) ProtoMessage() {}

func (x *SnapshotMeta) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SnapshotMeta.ProtoReflect.Descriptor instead.
func (*SnapshotMeta) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{3}
}

func (x *SnapshotMeta) GetCfFiles() []*SnapshotCFFile {
	if x != nil {
		return x.CfFiles
	}
	return nil
}

func (x *SnapshotMeta) GetForBalance() bool {
	if x != nil {
		return x.ForBalance
	}
	return false
}

func (x *SnapshotMeta) GetForWitness() bool {
	if x != nil {
		return x.ForWitness
	}
	return false
}

func (x *SnapshotMeta) GetStart() uint64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *SnapshotMeta) GetGenerateDurationSec() uint64 {
	if x != nil {
		return x.GenerateDurationSec
	}
	return 0
}

func (x *SnapshotMeta) GetTabletSnapPath() string {
	if x != nil {
		return x.TabletSnapPath
	}
	return ""
}

func (x *SnapshotMeta) GetCommitIndexHint() uint64 {
	if x != nil {
		return x.CommitIndexHint
	}
	return 0
}

type SnapshotChunk struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       *RaftMessage           `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Data          []byte                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SnapshotChunk) Reset() {
	*x = SnapshotChunk{}
	mi := &file_raft_serverpb_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SnapshotChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SnapshotChunk) ProtoMessage() {}

func (x *SnapshotChunk) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SnapshotChunk.ProtoReflect.Descriptor instead.
func (*SnapshotChunk) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{4}
}

func (x *SnapshotChunk) GetMessage() *RaftMessage {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *SnapshotChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type Done struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Done) Reset() {
	*x = Done{}
	mi := &file_raft_serverpb_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Done) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Done) ProtoMessage() {}

func (x *Done) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Done.ProtoReflect.Descriptor instead.
func (*Done) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{5}
}

type TabletSnapshotFileMeta struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	FileSize uint64                 `protobuf:"varint,1,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FileName string                 `protobuf:"bytes,2,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	// Some block data. Unencrypted.
	HeadChunk []byte `protobuf:"bytes,3,opt,name=head_chunk,json=headChunk,proto3" json:"head_chunk,omitempty"`
	// trailing data including checksum. Unencrypted.
	TrailingChunk []byte `protobuf:"bytes,4,opt,name=trailing_chunk,json=trailingChunk,proto3" json:"trailing_chunk,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TabletSnapshotFileMeta) Reset() {
	*x = TabletSnapshotFileMeta{}
	mi := &file_raft_serverpb_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabletSnapshotFileMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabletSnapshotFileMeta) ProtoMessage() {}

func (x *TabletSnapshotFileMeta) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabletSnapshotFileMeta.ProtoReflect.Descriptor instead.
func (*TabletSnapshotFileMeta) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{6}
}

func (x *TabletSnapshotFileMeta) GetFileSize() uint64 {
	if x != nil {
		return x.FileSize
	}
	return 0
}

func (x *TabletSnapshotFileMeta) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *TabletSnapshotFileMeta) GetHeadChunk() []byte {
	if x != nil {
		return x.HeadChunk
	}
	return nil
}

func (x *TabletSnapshotFileMeta) GetTrailingChunk() []byte {
	if x != nil {
		return x.TrailingChunk
	}
	return nil
}

// Snapshot preview for server to decide whether skip some files.
// Server should send back an `AcceptedSnapshotFile` to let client
// keep sending specified files. Only SST files can be skipped, all
// other files should always be sent.
type TabletSnapshotPreview struct {
	state protoimpl.MessageState    `protogen:"open.v1"`
	Metas []*TabletSnapshotFileMeta `protobuf:"bytes,1,rep,name=metas,proto3" json:"metas,omitempty"`
	// There may be too many metas, use a flag to indicate all metas
	// are sent.
	End           bool `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TabletSnapshotPreview) Reset() {
	*x = TabletSnapshotPreview{}
	mi := &file_raft_serverpb_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabletSnapshotPreview) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabletSnapshotPreview) ProtoMessage() {}

func (x *TabletSnapshotPreview) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabletSnapshotPreview.ProtoReflect.Descriptor instead.
func (*TabletSnapshotPreview) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{7}
}

func (x *TabletSnapshotPreview) GetMetas() []*TabletSnapshotFileMeta {
	if x != nil {
		return x.Metas
	}
	return nil
}

func (x *TabletSnapshotPreview) GetEnd() bool {
	if x != nil {
		return x.End
	}
	return false
}

type TabletSnapshotFileChunk struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	FileSize uint64                 `protobuf:"varint,1,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FileName string                 `protobuf:"bytes,2,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	// Encrypted.
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	// Initial vector if encryption is enabled.
	Iv            []byte                `protobuf:"bytes,4,opt,name=iv,proto3" json:"iv,omitempty"`
	Key           *encryptionpb.DataKey `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TabletSnapshotFileChunk) Reset() {
	*x = TabletSnapshotFileChunk{}
	mi := &file_raft_serverpb_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabletSnapshotFileChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabletSnapshotFileChunk) ProtoMessage() {}

func (x *TabletSnapshotFileChunk) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabletSnapshotFileChunk.ProtoReflect.Descriptor instead.
func (*TabletSnapshotFileChunk) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{8}
}

func (x *TabletSnapshotFileChunk) GetFileSize() uint64 {
	if x != nil {
		return x.FileSize
	}
	return 0
}

func (x *TabletSnapshotFileChunk) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *TabletSnapshotFileChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *TabletSnapshotFileChunk) GetIv() []byte {
	if x != nil {
		return x.Iv
	}
	return nil
}

func (x *TabletSnapshotFileChunk) GetKey() *encryptionpb.DataKey {
	if x != nil {
		return x.Key
	}
	return nil
}

type TabletSnapshotHead struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       *RaftMessage           `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	UseCache      bool                   `protobuf:"varint,2,opt,name=use_cache,json=useCache,proto3" json:"use_cache,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TabletSnapshotHead) Reset() {
	*x = TabletSnapshotHead{}
	mi := &file_raft_serverpb_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabletSnapshotHead) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabletSnapshotHead) ProtoMessage() {}

func (x *TabletSnapshotHead) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabletSnapshotHead.ProtoReflect.Descriptor instead.
func (*TabletSnapshotHead) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{9}
}

func (x *TabletSnapshotHead) GetMessage() *RaftMessage {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *TabletSnapshotHead) GetUseCache() bool {
	if x != nil {
		return x.UseCache
	}
	return false
}

type TabletSnapshotEnd struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Checksum of all data sent in `TabletSnapshotFileChunk.data` and
	// `TabletSnapshotFileChunk.file_name`.
	Checksum      uint64 `protobuf:"varint,1,opt,name=checksum,proto3" json:"checksum,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TabletSnapshotEnd) Reset() {
	*x = TabletSnapshotEnd{}
	mi := &file_raft_serverpb_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabletSnapshotEnd) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabletSnapshotEnd) ProtoMessage() {}

func (x *TabletSnapshotEnd) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabletSnapshotEnd.ProtoReflect.Descriptor instead.
func (*TabletSnapshotEnd) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{10}
}

func (x *TabletSnapshotEnd) GetChecksum() uint64 {
	if x != nil {
		return x.Checksum
	}
	return 0
}

type TabletSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*TabletSnapshotRequest_Head
	//	*TabletSnapshotRequest_Preview
	//	*TabletSnapshotRequest_Chunk
	//	*TabletSnapshotRequest_End
	Payload       isTabletSnapshotRequest_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TabletSnapshotRequest) Reset() {
	*x = TabletSnapshotRequest{}
	mi := &file_raft_serverpb_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabletSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabletSnapshotRequest) ProtoMessage() {}

func (x *TabletSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabletSnapshotRequest.ProtoReflect.Descriptor instead.
func (*TabletSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{11}
}

func (x *TabletSnapshotRequest) GetPayload() isTabletSnapshotRequest_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *TabletSnapshotRequest) GetHead() *TabletSnapshotHead {
	if x != nil {
		if x, ok := x.Payload.(*TabletSnapshotRequest_Head); ok {
			return x.Head
		}
	}
	return nil
}

func (x *TabletSnapshotRequest) GetPreview() *TabletSnapshotPreview {
	if x != nil {
		if x, ok := x.Payload.(*TabletSnapshotRequest_Preview); ok {
			return x.Preview
		}
	}
	return nil
}

func (x *TabletSnapshotRequest) GetChunk() *TabletSnapshotFileChunk {
	if x != nil {
		if x, ok := x.Payload.(*TabletSnapshotRequest_Chunk); ok {
			return x.Chunk
		}
	}
	return nil
}

func (x *TabletSnapshotRequest) GetEnd() *TabletSnapshotEnd {
	if x != nil {
		if x, ok := x.Payload.(*TabletSnapshotRequest_End); ok {
			return x.End
		}
	}
	return nil
}

type isTabletSnapshotRequest_Payload interface {
	isTabletSnapshotRequest_Payload()
}

type TabletSnapshotRequest_Head struct {
	Head *TabletSnapshotHead `protobuf:"bytes,1,opt,name=head,proto3,oneof"`
}

type TabletSnapshotRequest_Preview struct {
	Preview *TabletSnapshotPreview `protobuf:"bytes,2,opt,name=preview,proto3,oneof"`
}

type TabletSnapshotRequest_Chunk struct {
	Chunk *TabletSnapshotFileChunk `protobuf:"bytes,3,opt,name=chunk,proto3,oneof"`
}

type TabletSnapshotRequest_End struct {
	End *TabletSnapshotEnd `protobuf:"bytes,4,opt,name=end,proto3,oneof"`
}

func (*TabletSnapshotRequest_Head) isTabletSnapshotRequest_Payload() {}

func (*TabletSnapshotRequest_Preview) isTabletSnapshotRequest_Payload() {}

func (*TabletSnapshotRequest_Chunk) isTabletSnapshotRequest_Payload() {}

func (*TabletSnapshotRequest_End) isTabletSnapshotRequest_Payload() {}

type AcceptedSnapshotFiles struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FileName      []string               `protobuf:"bytes,1,rep,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AcceptedSnapshotFiles) Reset() {
	*x = AcceptedSnapshotFiles{}
	mi := &file_raft_serverpb_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AcceptedSnapshotFiles) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AcceptedSnapshotFiles) ProtoMessage() {}

func (x *AcceptedSnapshotFiles) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AcceptedSnapshotFiles.ProtoReflect.Descriptor instead.
func (*AcceptedSnapshotFiles) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{12}
}

func (x *AcceptedSnapshotFiles) GetFileName() []string {
	if x != nil {
		return x.FileName
	}
	return nil
}

type TabletSnapshotResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Files         *AcceptedSnapshotFiles `protobuf:"bytes,1,opt,name=files,proto3" json:"files,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TabletSnapshotResponse) Reset() {
	*x = TabletSnapshotResponse{}
	mi := &file_raft_serverpb_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabletSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabletSnapshotResponse) ProtoMessage() {}

func (x *TabletSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabletSnapshotResponse.ProtoReflect.Descriptor instead.
func (*TabletSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{13}
}

func (x *TabletSnapshotResponse) GetFiles() *AcceptedSnapshotFiles {
	if x != nil {
		return x.Files
	}
	return nil
}

type KeyValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           []byte                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyValue) Reset() {
	*x = KeyValue{}
	mi := &file_raft_serverpb_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyValue) ProtoMessage() {}

func (x *KeyValue) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyValue.ProtoReflect.Descriptor instead.
func (*KeyValue) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{14}
}

func (x *KeyValue) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *KeyValue) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

type RaftSnapshotData struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Region         *metapb.Region         `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	FileSize       uint64                 `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	Data           []*KeyValue            `protobuf:"bytes,3,rep,name=data,proto3" json:"data,omitempty"`
	Version        uint64                 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	Meta           *SnapshotMeta          `protobuf:"bytes,5,opt,name=meta,proto3" json:"meta,omitempty"`
	RemovedRecords []*metapb.Peer         `protobuf:"bytes,6,rep,name=removed_records,json=removedRecords,proto3" json:"removed_records,omitempty"`
	MergedRecords  []*MergedRecord        `protobuf:"bytes,7,rep,name=merged_records,json=mergedRecords,proto3" json:"merged_records,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RaftSnapshotData) Reset() {
	*x = RaftSnapshotData{}
	mi := &file_raft_serverpb_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RaftSnapshotData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RaftSnapshotData) ProtoMessage() {}

func (x *RaftSnapshotData) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RaftSnapshotData.ProtoReflect.Descriptor instead.
func (*RaftSnapshotData) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{15}
}

func (x *RaftSnapshotData) GetRegion() *metapb.Region {
	if x != nil {
		return x.Region
	}
	return nil
}

func (x *RaftSnapshotData) GetFileSize() uint64 {
	if x != nil {
		return x.FileSize
	}
	return 0
}

func (x *RaftSnapshotData) GetData() []*KeyValue {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *RaftSnapshotData) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *RaftSnapshotData) GetMeta() *SnapshotMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

func (x *RaftSnapshotData) GetRemovedRecords() []*metapb.Peer {
	if x != nil {
		return x.RemovedRecords
	}
	return nil
}

func (x *RaftSnapshotData) GetMergedRecords() []*MergedRecord {
	if x != nil {
		return x.MergedRecords
	}
	return nil
}

type StoreIdent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClusterId     uint64                 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	StoreId       uint64                 `protobuf:"varint,2,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	ApiVersion    kvrpcpb.APIVersion     `protobuf:"varint,3,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoreIdent) Reset() {
	*x = StoreIdent{}
	mi := &file_raft_serverpb_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoreIdent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoreIdent) ProtoMessage() {}

func (x *StoreIdent) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoreIdent.ProtoReflect.Descriptor instead.
func (*StoreIdent) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{16}
}

func (x *StoreIdent) GetClusterId() uint64 {
	if x != nil {
		return x.ClusterId
	}
	return 0
}

func (x *StoreIdent) GetStoreId() uint64 {
	if x != nil {
		return x.StoreId
	}
	return 0
}

func (x *StoreIdent) GetApiVersion() kvrpcpb.APIVersion {
	if x != nil {
		return x.ApiVersion
	}
	return kvrpcpb.APIVersion(0)
}

type StoreRecoverState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Used for TiKV start recovery when WAL of KVDB was disabled.
	// TiKV may read all relations between seqno and raft log index, and replay
	// all raft logs which corresponding seqno smaller than the seqno here.
	// After TiKV replays all raft logs and flushed KV data, the seqno here must
	// be updated.
	Seqno         uint64 `protobuf:"varint,1,opt,name=seqno,proto3" json:"seqno,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StoreRecoverState) Reset() {
	*x = StoreRecoverState{}
	mi := &file_raft_serverpb_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StoreRecoverState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StoreRecoverState) ProtoMessage() {}

func (x *StoreRecoverState) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StoreRecoverState.ProtoReflect.Descriptor instead.
func (*StoreRecoverState) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{17}
}

func (x *StoreRecoverState) GetSeqno() uint64 {
	if x != nil {
		return x.Seqno
	}
	return 0
}

type RaftLocalState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	HardState     *eraftpb.HardState     `protobuf:"bytes,1,opt,name=hard_state,json=hardState,proto3" json:"hard_state,omitempty"`
	LastIndex     uint64                 `protobuf:"varint,2,opt,name=last_index,json=lastIndex,proto3" json:"last_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RaftLocalState) Reset() {
	*x = RaftLocalState{}
	mi := &file_raft_serverpb_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RaftLocalState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RaftLocalState) ProtoMessage() {}

func (x *RaftLocalState) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RaftLocalState.ProtoReflect.Descriptor instead.
func (*RaftLocalState) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{18}
}

func (x *RaftLocalState) GetHardState() *eraftpb.HardState {
	if x != nil {
		return x.HardState
	}
	return nil
}

func (x *RaftLocalState) GetLastIndex() uint64 {
	if x != nil {
		return x.LastIndex
	}
	return 0
}

type RaftApplyState struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	AppliedIndex    uint64                 `protobuf:"varint,1,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	LastCommitIndex uint64                 `protobuf:"varint,3,opt,name=last_commit_index,json=lastCommitIndex,proto3" json:"last_commit_index,omitempty"`
	CommitIndex     uint64                 `protobuf:"varint,4,opt,name=commit_index,json=commitIndex,proto3" json:"commit_index,omitempty"`
	CommitTerm      uint64                 `protobuf:"varint,5,opt,name=commit_term,json=commitTerm,proto3" json:"commit_term,omitempty"`
	TruncatedState  *RaftTruncatedState    `protobuf:"bytes,2,opt,name=truncated_state,json=truncatedState,proto3" json:"truncated_state,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RaftApplyState) Reset() {
	*x = RaftApplyState{}
	mi := &file_raft_serverpb_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RaftApplyState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RaftApplyState) ProtoMessage() {}

func (x *RaftApplyState) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RaftApplyState.ProtoReflect.Descriptor instead.
func (*RaftApplyState) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{19}
}

func (x *RaftApplyState) GetAppliedIndex() uint64 {
	if x != nil {
		return x.AppliedIndex
	}
	return 0
}

func (x *RaftApplyState) GetLastCommitIndex() uint64 {
	if x != nil {
		return x.LastCommitIndex
	}
	return 0
}

func (x *RaftApplyState) GetCommitIndex() uint64 {
	if x != nil {
		return x.CommitIndex
	}
	return 0
}

func (x *RaftApplyState) GetCommitTerm() uint64 {
	if x != nil {
		return x.CommitTerm
	}
	return 0
}

func (x *RaftApplyState) GetTruncatedState() *RaftTruncatedState {
	if x != nil {
		return x.TruncatedState
	}
	return nil
}

type MergeState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinIndex      uint64                 `protobuf:"varint,1,opt,name=min_index,json=minIndex,proto3" json:"min_index,omitempty"`
	Target        *metapb.Region         `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	Commit        uint64                 `protobuf:"varint,3,opt,name=commit,proto3" json:"commit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MergeState) Reset() {
	*x = MergeState{}
	mi := &file_raft_serverpb_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MergeState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MergeState) ProtoMessage() {}

func (x *MergeState) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MergeState.ProtoReflect.Descriptor instead.
func (*MergeState) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{20}
}

func (x *MergeState) GetMinIndex() uint64 {
	if x != nil {
		return x.MinIndex
	}
	return 0
}

func (x *MergeState) GetTarget() *metapb.Region {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *MergeState) GetCommit() uint64 {
	if x != nil {
		return x.Commit
	}
	return 0
}

type MergedRecord struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	SourceRegionId uint64                 `protobuf:"varint,1,opt,name=source_region_id,json=sourceRegionId,proto3" json:"source_region_id,omitempty"`
	SourceEpoch    *metapb.RegionEpoch    `protobuf:"bytes,2,opt,name=source_epoch,json=sourceEpoch,proto3" json:"source_epoch,omitempty"`
	// Peers of source region when merge is committed.
	SourcePeers []*metapb.Peer `protobuf:"bytes,3,rep,name=source_peers,json=sourcePeers,proto3" json:"source_peers,omitempty"`
	// Removed peers (by confchange) of source region when merge is committed.
	SourceRemovedRecords []*metapb.Peer      `protobuf:"bytes,9,rep,name=source_removed_records,json=sourceRemovedRecords,proto3" json:"source_removed_records,omitempty"`
	TargetRegionId       uint64              `protobuf:"varint,4,opt,name=target_region_id,json=targetRegionId,proto3" json:"target_region_id,omitempty"`
	TargetEpoch          *metapb.RegionEpoch `protobuf:"bytes,5,opt,name=target_epoch,json=targetEpoch,proto3" json:"target_epoch,omitempty"`
	TargetPeers          []*metapb.Peer      `protobuf:"bytes,6,rep,name=target_peers,json=targetPeers,proto3" json:"target_peers,omitempty"`
	// Commit merge index.
	Index uint64 `protobuf:"varint,7,opt,name=index,proto3" json:"index,omitempty"`
	// Prepare merge index.
	SourceIndex   uint64 `protobuf:"varint,8,opt,name=source_index,json=sourceIndex,proto3" json:"source_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MergedRecord) Reset() {
	*x = MergedRecord{}
	mi := &file_raft_serverpb_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MergedRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MergedRecord) ProtoMessage() {}

func (x *MergedRecord) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MergedRecord.ProtoReflect.Descriptor instead.
func (*MergedRecord) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{21}
}

func (x *MergedRecord) GetSourceRegionId() uint64 {
	if x != nil {
		return x.SourceRegionId
	}
	return 0
}

func (x *MergedRecord) GetSourceEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.SourceEpoch
	}
	return nil
}

func (x *MergedRecord) GetSourcePeers() []*metapb.Peer {
	if x != nil {
		return x.SourcePeers
	}
	return nil
}

func (x *MergedRecord) GetSourceRemovedRecords() []*metapb.Peer {
	if x != nil {
		return x.SourceRemovedRecords
	}
	return nil
}

func (x *MergedRecord) GetTargetRegionId() uint64 {
	if x != nil {
		return x.TargetRegionId
	}
	return 0
}

func (x *MergedRecord) GetTargetEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.TargetEpoch
	}
	return nil
}

func (x *MergedRecord) GetTargetPeers() []*metapb.Peer {
	if x != nil {
		return x.TargetPeers
	}
	return nil
}

func (x *MergedRecord) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *MergedRecord) GetSourceIndex() uint64 {
	if x != nil {
		return x.SourceIndex
	}
	return 0
}

type RegionLocalState struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	State      PeerState              `protobuf:"varint,1,opt,name=state,proto3,enum=raft_serverpb.PeerState" json:"state,omitempty"`
	Region     *metapb.Region         `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	MergeState *MergeState            `protobuf:"bytes,3,opt,name=merge_state,json=mergeState,proto3" json:"merge_state,omitempty"`
	// The apply index corresponding to the storage when it's initialized.
	TabletIndex uint64 `protobuf:"varint,4,opt,name=tablet_index,json=tabletIndex,proto3" json:"tablet_index,omitempty"`
	// Raft doesn't guarantee peer will be removed in the end. In v1, peer finds
	// out its destiny by logs or broadcast; in v2, leader is responsible to
	// ensure removed peers are destroyed.
	// Note: only peers who has been part of this region can be in this list.
	RemovedRecords []*metapb.Peer `protobuf:"bytes,5,rep,name=removed_records,json=removedRecords,proto3" json:"removed_records,omitempty"`
	// Merged peer can't be deleted like gc peers. Instead, leader needs to
	// query target peer to decide whether source peer can be destroyed.
	MergedRecords []*MergedRecord `protobuf:"bytes,6,rep,name=merged_records,json=mergedRecords,proto3" json:"merged_records,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegionLocalState) Reset() {
	*x = RegionLocalState{}
	mi := &file_raft_serverpb_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegionLocalState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegionLocalState) ProtoMessage() {}

func (x *RegionLocalState) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegionLocalState.ProtoReflect.Descriptor instead.
func (*RegionLocalState) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{22}
}

func (x *RegionLocalState) GetState() PeerState {
	if x != nil {
		return x.State
	}
	return PeerState_Normal
}

func (x *RegionLocalState) GetRegion() *metapb.Region {
	if x != nil {
		return x.Region
	}
	return nil
}

func (x *RegionLocalState) GetMergeState() *MergeState {
	if x != nil {
		return x.MergeState
	}
	return nil
}

func (x *RegionLocalState) GetTabletIndex() uint64 {
	if x != nil {
		return x.TabletIndex
	}
	return 0
}

func (x *RegionLocalState) GetRemovedRecords() []*metapb.Peer {
	if x != nil {
		return x.RemovedRecords
	}
	return nil
}

func (x *RegionLocalState) GetMergedRecords() []*MergedRecord {
	if x != nil {
		return x.MergedRecords
	}
	return nil
}

type RegionSequenceNumberRelation struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	RegionId       uint64                 `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	SequenceNumber uint64                 `protobuf:"varint,2,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	ApplyState     *RaftApplyState        `protobuf:"bytes,3,opt,name=apply_state,json=applyState,proto3" json:"apply_state,omitempty"`
	RegionState    *RegionLocalState      `protobuf:"bytes,4,opt,name=region_state,json=regionState,proto3" json:"region_state,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RegionSequenceNumberRelation) Reset() {
	*x = RegionSequenceNumberRelation{}
	mi := &file_raft_serverpb_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegionSequenceNumberRelation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegionSequenceNumberRelation) ProtoMessage() {}

func (x *RegionSequenceNumberRelation) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegionSequenceNumberRelation.ProtoReflect.Descriptor instead.
func (*RegionSequenceNumberRelation) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{23}
}

func (x *RegionSequenceNumberRelation) GetRegionId() uint64 {
	if x != nil {
		return x.RegionId
	}
	return 0
}

func (x *RegionSequenceNumberRelation) GetSequenceNumber() uint64 {
	if x != nil {
		return x.SequenceNumber
	}
	return 0
}

func (x *RegionSequenceNumberRelation) GetApplyState() *RaftApplyState {
	if x != nil {
		return x.ApplyState
	}
	return nil
}

func (x *RegionSequenceNumberRelation) GetRegionState() *RegionLocalState {
	if x != nil {
		return x.RegionState
	}
	return nil
}

type AvailabilityContext struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	FromRegionId    uint64                 `protobuf:"varint,1,opt,name=from_region_id,json=fromRegionId,proto3" json:"from_region_id,omitempty"`
	FromRegionEpoch *metapb.RegionEpoch    `protobuf:"bytes,2,opt,name=from_region_epoch,json=fromRegionEpoch,proto3" json:"from_region_epoch,omitempty"`
	Unavailable     bool                   `protobuf:"varint,3,opt,name=unavailable,proto3" json:"unavailable,omitempty"`
	Trimmed         bool                   `protobuf:"varint,4,opt,name=trimmed,proto3" json:"trimmed,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AvailabilityContext) Reset() {
	*x = AvailabilityContext{}
	mi := &file_raft_serverpb_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AvailabilityContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AvailabilityContext) ProtoMessage() {}

func (x *AvailabilityContext) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AvailabilityContext.ProtoReflect.Descriptor instead.
func (*AvailabilityContext) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{24}
}

func (x *AvailabilityContext) GetFromRegionId() uint64 {
	if x != nil {
		return x.FromRegionId
	}
	return 0
}

func (x *AvailabilityContext) GetFromRegionEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.FromRegionEpoch
	}
	return nil
}

func (x *AvailabilityContext) GetUnavailable() bool {
	if x != nil {
		return x.Unavailable
	}
	return false
}

func (x *AvailabilityContext) GetTrimmed() bool {
	if x != nil {
		return x.Trimmed
	}
	return false
}

type FlushMemtable struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RegionId      uint64                 `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlushMemtable) Reset() {
	*x = FlushMemtable{}
	mi := &file_raft_serverpb_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlushMemtable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlushMemtable) ProtoMessage() {}

func (x *FlushMemtable) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlushMemtable.ProtoReflect.Descriptor instead.
func (*FlushMemtable) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{25}
}

func (x *FlushMemtable) GetRegionId() uint64 {
	if x != nil {
		return x.RegionId
	}
	return 0
}

type RefreshBuckets struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       uint64                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Keys          [][]byte               `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	Sizes         []uint64               `protobuf:"varint,3,rep,packed,name=sizes,proto3" json:"sizes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RefreshBuckets) Reset() {
	*x = RefreshBuckets{}
	mi := &file_raft_serverpb_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshBuckets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshBuckets) ProtoMessage() {}

func (x *RefreshBuckets) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshBuckets.ProtoReflect.Descriptor instead.
func (*RefreshBuckets) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{26}
}

func (x *RefreshBuckets) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *RefreshBuckets) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *RefreshBuckets) GetSizes() []uint64 {
	if x != nil {
		return x.Sizes
	}
	return nil
}

type CheckGcPeer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The region ID who triggers the check and wait for report. It should be
	// the ID of RaftMessage.from.
	FromRegionId uint64 `protobuf:"varint,1,opt,name=from_region_id,json=fromRegionId,proto3" json:"from_region_id,omitempty"`
	// The region ID to be checked if should be destroyed.
	CheckRegionId uint64 `protobuf:"varint,2,opt,name=check_region_id,json=checkRegionId,proto3" json:"check_region_id,omitempty"`
	// The epoch of the region to be checked.
	CheckRegionEpoch *metapb.RegionEpoch `protobuf:"bytes,3,opt,name=check_region_epoch,json=checkRegionEpoch,proto3" json:"check_region_epoch,omitempty"`
	// The peer to be checked.
	CheckPeer     *metapb.Peer `protobuf:"bytes,4,opt,name=check_peer,json=checkPeer,proto3" json:"check_peer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckGcPeer) Reset() {
	*x = CheckGcPeer{}
	mi := &file_raft_serverpb_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckGcPeer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckGcPeer) ProtoMessage() {}

func (x *CheckGcPeer) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckGcPeer.ProtoReflect.Descriptor instead.
func (*CheckGcPeer) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{27}
}

func (x *CheckGcPeer) GetFromRegionId() uint64 {
	if x != nil {
		return x.FromRegionId
	}
	return 0
}

func (x *CheckGcPeer) GetCheckRegionId() uint64 {
	if x != nil {
		return x.CheckRegionId
	}
	return 0
}

func (x *CheckGcPeer) GetCheckRegionEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.CheckRegionEpoch
	}
	return nil
}

func (x *CheckGcPeer) GetCheckPeer() *metapb.Peer {
	if x != nil {
		return x.CheckPeer
	}
	return nil
}

type ExtraMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Type  ExtraMessageType       `protobuf:"varint,1,opt,name=type,proto3,enum=raft_serverpb.ExtraMessageType" json:"type,omitempty"`
	// It's merge related index. In `WantRollbackMerge`, it's prepare merge index. In
	// `MsgGcPeerRequest`, it's the commit merge index. In `MsgVoterReplicatedIndexRequest`
	// it's the voter_replicated_index.
	Index uint64 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	// In `MsgCheckStalePeerResponse`, it's the peers that receiver can continue to query.
	CheckPeers []*metapb.Peer `protobuf:"bytes,3,rep,name=check_peers,json=checkPeers,proto3" json:"check_peers,omitempty"`
	WaitData   bool           `protobuf:"varint,4,opt,name=wait_data,json=waitData,proto3" json:"wait_data,omitempty"`
	// Flag for forcely wake up hibernate regions if true.
	ForcelyAwaken bool           `protobuf:"varint,5,opt,name=forcely_awaken,json=forcelyAwaken,proto3" json:"forcely_awaken,omitempty"`
	CheckGcPeer   *CheckGcPeer   `protobuf:"bytes,6,opt,name=check_gc_peer,json=checkGcPeer,proto3" json:"check_gc_peer,omitempty"`
	FlushMemtable *FlushMemtable `protobuf:"bytes,7,opt,name=flush_memtable,json=flushMemtable,proto3" json:"flush_memtable,omitempty"`
	// Used by `MsgAvailabilityRequest` and `MsgAvailabilityResponse` in v2.
	AvailabilityContext *AvailabilityContext `protobuf:"bytes,8,opt,name=availability_context,json=availabilityContext,proto3" json:"availability_context,omitempty"`
	// notice the peer to refresh buckets version
	RefreshBuckets *RefreshBuckets `protobuf:"bytes,9,opt,name=refresh_buckets,json=refreshBuckets,proto3" json:"refresh_buckets,omitempty"`
	// snap_gen_precheck_passed is used to indicate the precheck result when
	// a follower responds to a leader's snapshot gen precheck request.
	SnapGenPrecheckPassed bool `protobuf:"varint,10,opt,name=snap_gen_precheck_passed,json=snapGenPrecheckPassed,proto3" json:"snap_gen_precheck_passed,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ExtraMessage) Reset() {
	*x = ExtraMessage{}
	mi := &file_raft_serverpb_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtraMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtraMessage) ProtoMessage() {}

func (x *ExtraMessage) ProtoReflect() protoreflect.Message {
	mi := &file_raft_serverpb_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtraMessage.ProtoReflect.Descriptor instead.
func (*ExtraMessage) Descriptor() ([]byte, []int) {
	return file_raft_serverpb_proto_rawDescGZIP(), []int{28}
}

func (x *ExtraMessage) GetType() ExtraMessageType {
	if x != nil {
		return x.Type
	}
	return ExtraMessageType_MsgRegionWakeUp
}

func (x *ExtraMessage) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *ExtraMessage) GetCheckPeers() []*metapb.Peer {
	if x != nil {
		return x.CheckPeers
	}
	return nil
}

func (x *ExtraMessage) GetWaitData() bool {
	if x != nil {
		return x.WaitData
	}
	return false
}

func (x *ExtraMessage) GetForcelyAwaken() bool {
	if x != nil {
		return x.ForcelyAwaken
	}
	return false
}

func (x *ExtraMessage) GetCheckGcPeer() *CheckGcPeer {
	if x != nil {
		return x.CheckGcPeer
	}
	return nil
}

func (x *ExtraMessage) GetFlushMemtable() *FlushMemtable {
	if x != nil {
		return x.FlushMemtable
	}
	return nil
}

func (x *ExtraMessage) GetAvailabilityContext() *AvailabilityContext {
	if x != nil {
		return x.AvailabilityContext
	}
	return nil
}

func (x *ExtraMessage) GetRefreshBuckets() *RefreshBuckets {
	if x != nil {
		return x.RefreshBuckets
	}
	return nil
}

func (x *ExtraMessage) GetSnapGenPrecheckPassed() bool {
	if x != nil {
		return x.SnapGenPrecheckPassed
	}
	return false
}

var File_raft_serverpb_proto protoreflect.FileDescriptor

const file_raft_serverpb_proto_rawDesc = "" +
	"\n" +
	"\x13raft_serverpb.proto\x12\rraft_serverpb\x1a\reraftpb.proto\x1a\fmetapb.proto\x1a\rkvrpcpb.proto\x1a\x10disk_usage.proto\x1a\x12encryptionpb.proto\x1a\x0frustproto.proto\"\xf9\x03\n" +
	"\vRaftMessage\x12\x1b\n" +
	"\tregion_id\x18\x01 \x01(\x04R\bregionId\x12)\n" +
	"\tfrom_peer\x18\x02 \x01(\v2\f.metapb.PeerR\bfromPeer\x12%\n" +
	"\ato_peer\x18\x03 \x01(\v2\f.metapb.PeerR\x06toPeer\x12*\n" +
	"\amessage\x18\x04 \x01(\v2\x10.eraftpb.MessageR\amessage\x126\n" +
	"\fregion_epoch\x18\x05 \x01(\v2\x13.metapb.RegionEpochR\vregionEpoch\x12!\n" +
	"\fis_tombstone\x18\x06 \x01(\bR\visTombstone\x12\x1b\n" +
	"\tstart_key\x18\a \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\b \x01(\fR\x06endKey\x121\n" +
	"\fmerge_target\x18\t \x01(\v2\x0e.metapb.RegionR\vmergeTarget\x128\n" +
	"\textra_msg\x18\n" +
	" \x01(\v2\x1b.raft_serverpb.ExtraMessageR\bextraMsg\x12\x1b\n" +
	"\textra_ctx\x18\v \x01(\fR\bextraCtx\x124\n" +
	"\n" +
	"disk_usage\x18\f \x01(\x0e2\x15.disk_usage.DiskUsageR\tdiskUsage\">\n" +
	"\x12RaftTruncatedState\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x04R\x05index\x12\x12\n" +
	"\x04term\x18\x02 \x01(\x04R\x04term\"P\n" +
	"\x0eSnapshotCFFile\x12\x0e\n" +
	"\x02cf\x18\x01 \x01(\tR\x02cf\x12\x12\n" +
	"\x04size\x18\x02 \x01(\x04R\x04size\x12\x1a\n" +
	"\bchecksum\x18\x03 \x01(\rR\bchecksum\"\xaa\x02\n" +
	"\fSnapshotMeta\x128\n" +
	"\bcf_files\x18\x01 \x03(\v2\x1d.raft_serverpb.SnapshotCFFileR\acfFiles\x12\x1f\n" +
	"\vfor_balance\x18\x02 \x01(\bR\n" +
	"forBalance\x12\x1f\n" +
	"\vfor_witness\x18\x03 \x01(\bR\n" +
	"forWitness\x12\x14\n" +
	"\x05start\x18\x04 \x01(\x04R\x05start\x122\n" +
	"\x15generate_duration_sec\x18\x05 \x01(\x04R\x13generateDurationSec\x12(\n" +
	"\x10tablet_snap_path\x18\x06 \x01(\tR\x0etabletSnapPath\x12*\n" +
	"\x11commit_index_hint\x18\a \x01(\x04R\x0fcommitIndexHint\"Y\n" +
	"\rSnapshotChunk\x124\n" +
	"\amessage\x18\x01 \x01(\v2\x1a.raft_serverpb.RaftMessageR\amessage\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\"\x06\n" +
	"\x04Done\"\x98\x01\n" +
	"\x16TabletSnapshotFileMeta\x12\x1b\n" +
	"\tfile_size\x18\x01 \x01(\x04R\bfileSize\x12\x1b\n" +
	"\tfile_name\x18\x02 \x01(\tR\bfileName\x12\x1d\n" +
	"\n" +
	"head_chunk\x18\x03 \x01(\fR\theadChunk\x12%\n" +
	"\x0etrailing_chunk\x18\x04 \x01(\fR\rtrailingChunk\"f\n" +
	"\x15TabletSnapshotPreview\x12;\n" +
	"\x05metas\x18\x01 \x03(\v2%.raft_serverpb.TabletSnapshotFileMetaR\x05metas\x12\x10\n" +
	"\x03end\x18\x02 \x01(\bR\x03end\"\xa0\x01\n" +
	"\x17TabletSnapshotFileChunk\x12\x1b\n" +
	"\tfile_size\x18\x01 \x01(\x04R\bfileSize\x12\x1b\n" +
	"\tfile_name\x18\x02 \x01(\tR\bfileName\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12\x0e\n" +
	"\x02iv\x18\x04 \x01(\fR\x02iv\x12'\n" +
	"\x03key\x18\x05 \x01(\v2\x15.encryptionpb.DataKeyR\x03key\"g\n" +
	"\x12TabletSnapshotHead\x124\n" +
	"\amessage\x18\x01 \x01(\v2\x1a.raft_serverpb.RaftMessageR\amessage\x12\x1b\n" +
	"\tuse_cache\x18\x02 \x01(\bR\buseCache\"/\n" +
	"\x11TabletSnapshotEnd\x12\x1a\n" +
	"\bchecksum\x18\x01 \x01(\x04R\bchecksum\"\x93\x02\n" +
	"\x15TabletSnapshotRequest\x127\n" +
	"\x04head\x18\x01 \x01(\v2!.raft_serverpb.TabletSnapshotHeadH\x00R\x04head\x12@\n" +
	"\apreview\x18\x02 \x01(\v2$.raft_serverpb.TabletSnapshotPreviewH\x00R\apreview\x12>\n" +
	"\x05chunk\x18\x03 \x01(\v2&.raft_serverpb.TabletSnapshotFileChunkH\x00R\x05chunk\x124\n" +
	"\x03end\x18\x04 \x01(\v2 .raft_serverpb.TabletSnapshotEndH\x00R\x03endB\t\n" +
	"\apayload\"4\n" +
	"\x15AcceptedSnapshotFiles\x12\x1b\n" +
	"\tfile_name\x18\x01 \x03(\tR\bfileName\"T\n" +
	"\x16TabletSnapshotResponse\x12:\n" +
	"\x05files\x18\x01 \x01(\v2$.raft_serverpb.AcceptedSnapshotFilesR\x05files\"2\n" +
	"\bKeyValue\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\"\xca\x02\n" +
	"\x10RaftSnapshotData\x12&\n" +
	"\x06region\x18\x01 \x01(\v2\x0e.metapb.RegionR\x06region\x12\x1b\n" +
	"\tfile_size\x18\x02 \x01(\x04R\bfileSize\x12+\n" +
	"\x04data\x18\x03 \x03(\v2\x17.raft_serverpb.KeyValueR\x04data\x12\x18\n" +
	"\aversion\x18\x04 \x01(\x04R\aversion\x12/\n" +
	"\x04meta\x18\x05 \x01(\v2\x1b.raft_serverpb.SnapshotMetaR\x04meta\x125\n" +
	"\x0fremoved_records\x18\x06 \x03(\v2\f.metapb.PeerR\x0eremovedRecords\x12B\n" +
	"\x0emerged_records\x18\a \x03(\v2\x1b.raft_serverpb.MergedRecordR\rmergedRecords\"|\n" +
	"\n" +
	"StoreIdent\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\x04R\tclusterId\x12\x19\n" +
	"\bstore_id\x18\x02 \x01(\x04R\astoreId\x124\n" +
	"\vapi_version\x18\x03 \x01(\x0e2\x13.kvrpcpb.APIVersionR\n" +
	"apiVersion\")\n" +
	"\x11StoreRecoverState\x12\x14\n" +
	"\x05seqno\x18\x01 \x01(\x04R\x05seqno\"b\n" +
	"\x0eRaftLocalState\x121\n" +
	"\n" +
	"hard_state\x18\x01 \x01(\v2\x12.eraftpb.HardStateR\thardState\x12\x1d\n" +
	"\n" +
	"last_index\x18\x02 \x01(\x04R\tlastIndex\"\xf1\x01\n" +
	"\x0eRaftApplyState\x12#\n" +
	"\rapplied_index\x18\x01 \x01(\x04R\fappliedIndex\x12*\n" +
	"\x11last_commit_index\x18\x03 \x01(\x04R\x0flastCommitIndex\x12!\n" +
	"\fcommit_index\x18\x04 \x01(\x04R\vcommitIndex\x12\x1f\n" +
	"\vcommit_term\x18\x05 \x01(\x04R\n" +
	"commitTerm\x12J\n" +
	"\x0ftruncated_state\x18\x02 \x01(\v2!.raft_serverpb.RaftTruncatedStateR\x0etruncatedState\"i\n" +
	"\n" +
	"MergeState\x12\x1b\n" +
	"\tmin_index\x18\x01 \x01(\x04R\bminIndex\x12&\n" +
	"\x06target\x18\x02 \x01(\v2\x0e.metapb.RegionR\x06target\x12\x16\n" +
	"\x06commit\x18\x03 \x01(\x04R\x06commit\"\xb1\x03\n" +
	"\fMergedRecord\x12(\n" +
	"\x10source_region_id\x18\x01 \x01(\x04R\x0esourceRegionId\x126\n" +
	"\fsource_epoch\x18\x02 \x01(\v2\x13.metapb.RegionEpochR\vsourceEpoch\x12/\n" +
	"\fsource_peers\x18\x03 \x03(\v2\f.metapb.PeerR\vsourcePeers\x12B\n" +
	"\x16source_removed_records\x18\t \x03(\v2\f.metapb.PeerR\x14sourceRemovedRecords\x12(\n" +
	"\x10target_region_id\x18\x04 \x01(\x04R\x0etargetRegionId\x126\n" +
	"\ftarget_epoch\x18\x05 \x01(\v2\x13.metapb.RegionEpochR\vtargetEpoch\x12/\n" +
	"\ftarget_peers\x18\x06 \x03(\v2\f.metapb.PeerR\vtargetPeers\x12\x14\n" +
	"\x05index\x18\a \x01(\x04R\x05index\x12!\n" +
	"\fsource_index\x18\b \x01(\x04R\vsourceIndex\"\xc4\x02\n" +
	"\x10RegionLocalState\x12.\n" +
	"\x05state\x18\x01 \x01(\x0e2\x18.raft_serverpb.PeerStateR\x05state\x12&\n" +
	"\x06region\x18\x02 \x01(\v2\x0e.metapb.RegionR\x06region\x12:\n" +
	"\vmerge_state\x18\x03 \x01(\v2\x19.raft_serverpb.MergeStateR\n" +
	"mergeState\x12!\n" +
	"\ftablet_index\x18\x04 \x01(\x04R\vtabletIndex\x125\n" +
	"\x0fremoved_records\x18\x05 \x03(\v2\f.metapb.PeerR\x0eremovedRecords\x12B\n" +
	"\x0emerged_records\x18\x06 \x03(\v2\x1b.raft_serverpb.MergedRecordR\rmergedRecords\"\xe8\x01\n" +
	"\x1cRegionSequenceNumberRelation\x12\x1b\n" +
	"\tregion_id\x18\x01 \x01(\x04R\bregionId\x12'\n" +
	"\x0fsequence_number\x18\x02 \x01(\x04R\x0esequenceNumber\x12>\n" +
	"\vapply_state\x18\x03 \x01(\v2\x1d.raft_serverpb.RaftApplyStateR\n" +
	"applyState\x12B\n" +
	"\fregion_state\x18\x04 \x01(\v2\x1f.raft_serverpb.RegionLocalStateR\vregionState\"\xb8\x01\n" +
	"\x13AvailabilityContext\x12$\n" +
	"\x0efrom_region_id\x18\x01 \x01(\x04R\ffromRegionId\x12?\n" +
	"\x11from_region_epoch\x18\x02 \x01(\v2\x13.metapb.RegionEpochR\x0ffromRegionEpoch\x12 \n" +
	"\vunavailable\x18\x03 \x01(\bR\vunavailable\x12\x18\n" +
	"\atrimmed\x18\x04 \x01(\bR\atrimmed\",\n" +
	"\rFlushMemtable\x12\x1b\n" +
	"\tregion_id\x18\x01 \x01(\x04R\bregionId\"T\n" +
	"\x0eRefreshBuckets\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x04R\aversion\x12\x12\n" +
	"\x04keys\x18\x02 \x03(\fR\x04keys\x12\x14\n" +
	"\x05sizes\x18\x03 \x03(\x04R\x05sizes\"\xcb\x01\n" +
	"\vCheckGcPeer\x12$\n" +
	"\x0efrom_region_id\x18\x01 \x01(\x04R\ffromRegionId\x12&\n" +
	"\x0fcheck_region_id\x18\x02 \x01(\x04R\rcheckRegionId\x12A\n" +
	"\x12check_region_epoch\x18\x03 \x01(\v2\x13.metapb.RegionEpochR\x10checkRegionEpoch\x12+\n" +
	"\n" +
	"check_peer\x18\x04 \x01(\v2\f.metapb.PeerR\tcheckPeer\"\xa9\x04\n" +
	"\fExtraMessage\x123\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1f.raft_serverpb.ExtraMessageTypeR\x04type\x12\x14\n" +
	"\x05index\x18\x02 \x01(\x04R\x05index\x12-\n" +
	"\vcheck_peers\x18\x03 \x03(\v2\f.metapb.PeerR\n" +
	"checkPeers\x12\x1b\n" +
	"\twait_data\x18\x04 \x01(\bR\bwaitData\x12%\n" +
	"\x0eforcely_awaken\x18\x05 \x01(\bR\rforcelyAwaken\x12>\n" +
	"\rcheck_gc_peer\x18\x06 \x01(\v2\x1a.raft_serverpb.CheckGcPeerR\vcheckGcPeer\x12C\n" +
	"\x0eflush_memtable\x18\a \x01(\v2\x1c.raft_serverpb.FlushMemtableR\rflushMemtable\x12U\n" +
	"\x14availability_context\x18\b \x01(\v2\".raft_serverpb.AvailabilityContextR\x13availabilityContext\x12F\n" +
	"\x0frefresh_buckets\x18\t \x01(\v2\x1d.raft_serverpb.RefreshBucketsR\x0erefreshBuckets\x127\n" +
	"\x18snap_gen_precheck_passed\x18\n" +
	" \x01(\bR\x15snapGenPrecheckPassed*R\n" +
	"\tPeerState\x12\n" +
	"\n" +
	"\x06Normal\x10\x00\x12\f\n" +
	"\bApplying\x10\x01\x12\r\n" +
	"\tTombstone\x10\x02\x12\v\n" +
	"\aMerging\x10\x03\x12\x0f\n" +
	"\vUnavailable\x10\x04*\xa9\x04\n" +
	"\x10ExtraMessageType\x12\x13\n" +
	"\x0fMsgRegionWakeUp\x10\x00\x12\x18\n" +
	"\x14MsgWantRollbackMerge\x10\x01\x12\x15\n" +
	"\x11MsgCheckStalePeer\x10\x02\x12\x1d\n" +
	"\x19MsgCheckStalePeerResponse\x10\x03\x12\x17\n" +
	"\x13MsgHibernateRequest\x10\x04\x12\x18\n" +
	"\x14MsgHibernateResponse\x10\x05\x12'\n" +
	"#MsgRejectRaftLogCausedByMemoryUsage\x10\x06\x12\x1a\n" +
	"\x16MsgAvailabilityRequest\x10\a\x12\x1b\n" +
	"\x17MsgAvailabilityResponse\x10\b\x12\"\n" +
	"\x1eMsgVoterReplicatedIndexRequest\x10\t\x12#\n" +
	"\x1fMsgVoterReplicatedIndexResponse\x10\n" +
	"\x12\x14\n" +
	"\x10MsgGcPeerRequest\x10\v\x12\x15\n" +
	"\x11MsgGcPeerResponse\x10\f\x12\x14\n" +
	"\x10MsgFlushMemtable\x10\r\x12\x15\n" +
	"\x11MsgRefreshBuckets\x10\x0e\x12\x1d\n" +
	"\x19MsgSnapGenPrecheckRequest\x10\x0f\x12\x1e\n" +
	"\x1aMsgSnapGenPrecheckResponse\x10\x10\x12\x1b\n" +
	"\x17MsgPreLoadRegionRequest\x10\x11\x12\x1c\n" +
	"\x18MsgPreLoadRegionResponse\x10\x12B\x16\b\x01\n" +
	"\x10org.tikv.kvprotob\x06proto3"

var (
	file_raft_serverpb_proto_rawDescOnce sync.Once
	file_raft_serverpb_proto_rawDescData []byte
)

func file_raft_serverpb_proto_rawDescGZIP() []byte {
	file_raft_serverpb_proto_rawDescOnce.Do(func() {
		file_raft_serverpb_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_raft_serverpb_proto_rawDesc), len(file_raft_serverpb_proto_rawDesc)))
	})
	return file_raft_serverpb_proto_rawDescData
}

var file_raft_serverpb_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_raft_serverpb_proto_msgTypes = make([]protoimpl.MessageInfo, 29)
var file_raft_serverpb_proto_goTypes = []any{
	(PeerState)(0),                       // 0: raft_serverpb.PeerState
	(ExtraMessageType)(0),                // 1: raft_serverpb.ExtraMessageType
	(*RaftMessage)(nil),                  // 2: raft_serverpb.RaftMessage
	(*RaftTruncatedState)(nil),           // 3: raft_serverpb.RaftTruncatedState
	(*SnapshotCFFile)(nil),               // 4: raft_serverpb.SnapshotCFFile
	(*SnapshotMeta)(nil),                 // 5: raft_serverpb.SnapshotMeta
	(*SnapshotChunk)(nil),                // 6: raft_serverpb.SnapshotChunk
	(*Done)(nil),                         // 7: raft_serverpb.Done
	(*TabletSnapshotFileMeta)(nil),       // 8: raft_serverpb.TabletSnapshotFileMeta
	(*TabletSnapshotPreview)(nil),        // 9: raft_serverpb.TabletSnapshotPreview
	(*TabletSnapshotFileChunk)(nil),      // 10: raft_serverpb.TabletSnapshotFileChunk
	(*TabletSnapshotHead)(nil),           // 11: raft_serverpb.TabletSnapshotHead
	(*TabletSnapshotEnd)(nil),            // 12: raft_serverpb.TabletSnapshotEnd
	(*TabletSnapshotRequest)(nil),        // 13: raft_serverpb.TabletSnapshotRequest
	(*AcceptedSnapshotFiles)(nil),        // 14: raft_serverpb.AcceptedSnapshotFiles
	(*TabletSnapshotResponse)(nil),       // 15: raft_serverpb.TabletSnapshotResponse
	(*KeyValue)(nil),                     // 16: raft_serverpb.KeyValue
	(*RaftSnapshotData)(nil),             // 17: raft_serverpb.RaftSnapshotData
	(*StoreIdent)(nil),                   // 18: raft_serverpb.StoreIdent
	(*StoreRecoverState)(nil),            // 19: raft_serverpb.StoreRecoverState
	(*RaftLocalState)(nil),               // 20: raft_serverpb.RaftLocalState
	(*RaftApplyState)(nil),               // 21: raft_serverpb.RaftApplyState
	(*MergeState)(nil),                   // 22: raft_serverpb.MergeState
	(*MergedRecord)(nil),                 // 23: raft_serverpb.MergedRecord
	(*RegionLocalState)(nil),             // 24: raft_serverpb.RegionLocalState
	(*RegionSequenceNumberRelation)(nil), // 25: raft_serverpb.RegionSequenceNumberRelation
	(*AvailabilityContext)(nil),          // 26: raft_serverpb.AvailabilityContext
	(*FlushMemtable)(nil),                // 27: raft_serverpb.FlushMemtable
	(*RefreshBuckets)(nil),               // 28: raft_serverpb.RefreshBuckets
	(*CheckGcPeer)(nil),                  // 29: raft_serverpb.CheckGcPeer
	(*ExtraMessage)(nil),                 // 30: raft_serverpb.ExtraMessage
	(*metapb.Peer)(nil),                  // 31: metapb.Peer
	(*eraftpb.Message)(nil),              // 32: eraftpb.Message
	(*metapb.RegionEpoch)(nil),           // 33: metapb.RegionEpoch
	(*metapb.Region)(nil),                // 34: metapb.Region
	(disk_usage.DiskUsage)(0),            // 35: disk_usage.DiskUsage
	(*encryptionpb.DataKey)(nil),         // 36: encryptionpb.DataKey
	(kvrpcpb.APIVersion)(0),              // 37: kvrpcpb.APIVersion
	(*eraftpb.HardState)(nil),            // 38: eraftpb.HardState
}
var file_raft_serverpb_proto_depIdxs = []int32{
	31, // 0: raft_serverpb.RaftMessage.from_peer:type_name -> metapb.Peer
	31, // 1: raft_serverpb.RaftMessage.to_peer:type_name -> metapb.Peer
	32, // 2: raft_serverpb.RaftMessage.message:type_name -> eraftpb.Message
	33, // 3: raft_serverpb.RaftMessage.region_epoch:type_name -> metapb.RegionEpoch
	34, // 4: raft_serverpb.RaftMessage.merge_target:type_name -> metapb.Region
	30, // 5: raft_serverpb.RaftMessage.extra_msg:type_name -> raft_serverpb.ExtraMessage
	35, // 6: raft_serverpb.RaftMessage.disk_usage:type_name -> disk_usage.DiskUsage
	4,  // 7: raft_serverpb.SnapshotMeta.cf_files:type_name -> raft_serverpb.SnapshotCFFile
	2,  // 8: raft_serverpb.SnapshotChunk.message:type_name -> raft_serverpb.RaftMessage
	8,  // 9: raft_serverpb.TabletSnapshotPreview.metas:type_name -> raft_serverpb.TabletSnapshotFileMeta
	36, // 10: raft_serverpb.TabletSnapshotFileChunk.key:type_name -> encryptionpb.DataKey
	2,  // 11: raft_serverpb.TabletSnapshotHead.message:type_name -> raft_serverpb.RaftMessage
	11, // 12: raft_serverpb.TabletSnapshotRequest.head:type_name -> raft_serverpb.TabletSnapshotHead
	9,  // 13: raft_serverpb.TabletSnapshotRequest.preview:type_name -> raft_serverpb.TabletSnapshotPreview
	10, // 14: raft_serverpb.TabletSnapshotRequest.chunk:type_name -> raft_serverpb.TabletSnapshotFileChunk
	12, // 15: raft_serverpb.TabletSnapshotRequest.end:type_name -> raft_serverpb.TabletSnapshotEnd
	14, // 16: raft_serverpb.TabletSnapshotResponse.files:type_name -> raft_serverpb.AcceptedSnapshotFiles
	34, // 17: raft_serverpb.RaftSnapshotData.region:type_name -> metapb.Region
	16, // 18: raft_serverpb.RaftSnapshotData.data:type_name -> raft_serverpb.KeyValue
	5,  // 19: raft_serverpb.RaftSnapshotData.meta:type_name -> raft_serverpb.SnapshotMeta
	31, // 20: raft_serverpb.RaftSnapshotData.removed_records:type_name -> metapb.Peer
	23, // 21: raft_serverpb.RaftSnapshotData.merged_records:type_name -> raft_serverpb.MergedRecord
	37, // 22: raft_serverpb.StoreIdent.api_version:type_name -> kvrpcpb.APIVersion
	38, // 23: raft_serverpb.RaftLocalState.hard_state:type_name -> eraftpb.HardState
	3,  // 24: raft_serverpb.RaftApplyState.truncated_state:type_name -> raft_serverpb.RaftTruncatedState
	34, // 25: raft_serverpb.MergeState.target:type_name -> metapb.Region
	33, // 26: raft_serverpb.MergedRecord.source_epoch:type_name -> metapb.RegionEpoch
	31, // 27: raft_serverpb.MergedRecord.source_peers:type_name -> metapb.Peer
	31, // 28: raft_serverpb.MergedRecord.source_removed_records:type_name -> metapb.Peer
	33, // 29: raft_serverpb.MergedRecord.target_epoch:type_name -> metapb.RegionEpoch
	31, // 30: raft_serverpb.MergedRecord.target_peers:type_name -> metapb.Peer
	0,  // 31: raft_serverpb.RegionLocalState.state:type_name -> raft_serverpb.PeerState
	34, // 32: raft_serverpb.RegionLocalState.region:type_name -> metapb.Region
	22, // 33: raft_serverpb.RegionLocalState.merge_state:type_name -> raft_serverpb.MergeState
	31, // 34: raft_serverpb.RegionLocalState.removed_records:type_name -> metapb.Peer
	23, // 35: raft_serverpb.RegionLocalState.merged_records:type_name -> raft_serverpb.MergedRecord
	21, // 36: raft_serverpb.RegionSequenceNumberRelation.apply_state:type_name -> raft_serverpb.RaftApplyState
	24, // 37: raft_serverpb.RegionSequenceNumberRelation.region_state:type_name -> raft_serverpb.RegionLocalState
	33, // 38: raft_serverpb.AvailabilityContext.from_region_epoch:type_name -> metapb.RegionEpoch
	33, // 39: raft_serverpb.CheckGcPeer.check_region_epoch:type_name -> metapb.RegionEpoch
	31, // 40: raft_serverpb.CheckGcPeer.check_peer:type_name -> metapb.Peer
	1,  // 41: raft_serverpb.ExtraMessage.type:type_name -> raft_serverpb.ExtraMessageType
	31, // 42: raft_serverpb.ExtraMessage.check_peers:type_name -> metapb.Peer
	29, // 43: raft_serverpb.ExtraMessage.check_gc_peer:type_name -> raft_serverpb.CheckGcPeer
	27, // 44: raft_serverpb.ExtraMessage.flush_memtable:type_name -> raft_serverpb.FlushMemtable
	26, // 45: raft_serverpb.ExtraMessage.availability_context:type_name -> raft_serverpb.AvailabilityContext
	28, // 46: raft_serverpb.ExtraMessage.refresh_buckets:type_name -> raft_serverpb.RefreshBuckets
	47, // [47:47] is the sub-list for method output_type
	47, // [47:47] is the sub-list for method input_type
	47, // [47:47] is the sub-list for extension type_name
	47, // [47:47] is the sub-list for extension extendee
	0,  // [0:47] is the sub-list for field type_name
}

func init() { file_raft_serverpb_proto_init() }
func file_raft_serverpb_proto_init() {
	if File_raft_serverpb_proto != nil {
		return
	}
	file_raft_serverpb_proto_msgTypes[11].OneofWrappers = []any{
		(*TabletSnapshotRequest_Head)(nil),
		(*TabletSnapshotRequest_Preview)(nil),
		(*TabletSnapshotRequest_Chunk)(nil),
		(*TabletSnapshotRequest_End)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_raft_serverpb_proto_rawDesc), len(file_raft_serverpb_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   29,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_raft_serverpb_proto_goTypes,
		DependencyIndexes: file_raft_serverpb_proto_depIdxs,
		EnumInfos:         file_raft_serverpb_proto_enumTypes,
		MessageInfos:      file_raft_serverpb_proto_msgTypes,
	}.Build()
	File_raft_serverpb_proto = out.File
	file_raft_serverpb_proto_goTypes = nil
	file_raft_serverpb_proto_depIdxs = nil
}
