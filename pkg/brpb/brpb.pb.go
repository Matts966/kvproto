// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: brpb.proto

package brpb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	encryptionpb "github.com/pingcap/kvproto/pkg/encryptionpb"
	errorpb "github.com/pingcap/kvproto/pkg/errorpb"
	kvrpcpb "github.com/pingcap/kvproto/pkg/kvrpcpb"
	metapb "github.com/pingcap/kvproto/pkg/metapb"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PrepareSnapshotBackupRequestType int32

const (
	// Update the lease of suspending some commands (Which may impact the
	// disk snapshot backup) to be proposed.
	// As long as the lease is kept, those commands may not be proposed.
	// If the client has gone, the lease will be destroyed after its TTL.
	PrepareSnapshotBackupRequestType_UpdateLease PrepareSnapshotBackupRequestType = 0
	// Wait a region apply to the last index.
	PrepareSnapshotBackupRequestType_WaitApply PrepareSnapshotBackupRequestType = 1
	// Hint before closing the stream. Server will go back to normal after this.
	// This should also return a final "UpdateLeaseResult" to the client, which
	// indices whether the last lease is valid.
	PrepareSnapshotBackupRequestType_Finish PrepareSnapshotBackupRequestType = 2
)

// Enum value maps for PrepareSnapshotBackupRequestType.
var (
	PrepareSnapshotBackupRequestType_name = map[int32]string{
		0: "UpdateLease",
		1: "WaitApply",
		2: "Finish",
	}
	PrepareSnapshotBackupRequestType_value = map[string]int32{
		"UpdateLease": 0,
		"WaitApply":   1,
		"Finish":      2,
	}
)

func (x PrepareSnapshotBackupRequestType) Enum() *PrepareSnapshotBackupRequestType {
	p := new(PrepareSnapshotBackupRequestType)
	*p = x
	return p
}

func (x PrepareSnapshotBackupRequestType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PrepareSnapshotBackupRequestType) Descriptor() protoreflect.EnumDescriptor {
	return file_brpb_proto_enumTypes[0].Descriptor()
}

func (PrepareSnapshotBackupRequestType) Type() protoreflect.EnumType {
	return &file_brpb_proto_enumTypes[0]
}

func (x PrepareSnapshotBackupRequestType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PrepareSnapshotBackupRequestType.Descriptor instead.
func (PrepareSnapshotBackupRequestType) EnumDescriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{0}
}

type PrepareSnapshotBackupEventType int32

const (
	// A region has finished wait apply.
	PrepareSnapshotBackupEventType_WaitApplyDone PrepareSnapshotBackupEventType = 0
	// A lease has been updated.
	PrepareSnapshotBackupEventType_UpdateLeaseResult PrepareSnapshotBackupEventType = 1
)

// Enum value maps for PrepareSnapshotBackupEventType.
var (
	PrepareSnapshotBackupEventType_name = map[int32]string{
		0: "WaitApplyDone",
		1: "UpdateLeaseResult",
	}
	PrepareSnapshotBackupEventType_value = map[string]int32{
		"WaitApplyDone":     0,
		"UpdateLeaseResult": 1,
	}
)

func (x PrepareSnapshotBackupEventType) Enum() *PrepareSnapshotBackupEventType {
	p := new(PrepareSnapshotBackupEventType)
	*p = x
	return p
}

func (x PrepareSnapshotBackupEventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PrepareSnapshotBackupEventType) Descriptor() protoreflect.EnumDescriptor {
	return file_brpb_proto_enumTypes[1].Descriptor()
}

func (PrepareSnapshotBackupEventType) Type() protoreflect.EnumType {
	return &file_brpb_proto_enumTypes[1]
}

func (x PrepareSnapshotBackupEventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PrepareSnapshotBackupEventType.Descriptor instead.
func (PrepareSnapshotBackupEventType) EnumDescriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{1}
}

// sst files or log files compression algorithm
// for log files, unknown means not use compression algorithm
type CompressionType int32

const (
	CompressionType_UNKNOWN CompressionType = 0
	CompressionType_LZ4     CompressionType = 1
	CompressionType_SNAPPY  CompressionType = 2
	CompressionType_ZSTD    CompressionType = 3
)

// Enum value maps for CompressionType.
var (
	CompressionType_name = map[int32]string{
		0: "UNKNOWN",
		1: "LZ4",
		2: "SNAPPY",
		3: "ZSTD",
	}
	CompressionType_value = map[string]int32{
		"UNKNOWN": 0,
		"LZ4":     1,
		"SNAPPY":  2,
		"ZSTD":    3,
	}
)

func (x CompressionType) Enum() *CompressionType {
	p := new(CompressionType)
	*p = x
	return p
}

func (x CompressionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CompressionType) Descriptor() protoreflect.EnumDescriptor {
	return file_brpb_proto_enumTypes[2].Descriptor()
}

func (CompressionType) Type() protoreflect.EnumType {
	return &file_brpb_proto_enumTypes[2]
}

func (x CompressionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CompressionType.Descriptor instead.
func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{2}
}

// BackupMpde represents the mode of this whole backup request to the cluster.
// and we need to store it in `backupmeta`.
type BackupMode int32

const (
	// scan and generate precise SST file of a backup range.
	// then we don't need to do anything in future restore.
	// Note: this mode will cost the CPU resource of TiKV.
	BackupMode_SCAN BackupMode = 0
	// check and upload the coarse overlap SST files of a backup range.
	// then we need to use a merge iterator to filter unexpected kv in future restore.
	// Note: this mode will save the CPU resource of TiKV.
	BackupMode_FILE BackupMode = 1
)

// Enum value maps for BackupMode.
var (
	BackupMode_name = map[int32]string{
		0: "SCAN",
		1: "FILE",
	}
	BackupMode_value = map[string]int32{
		"SCAN": 0,
		"FILE": 1,
	}
)

func (x BackupMode) Enum() *BackupMode {
	p := new(BackupMode)
	*p = x
	return p
}

func (x BackupMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BackupMode) Descriptor() protoreflect.EnumDescriptor {
	return file_brpb_proto_enumTypes[3].Descriptor()
}

func (BackupMode) Type() protoreflect.EnumType {
	return &file_brpb_proto_enumTypes[3]
}

func (x BackupMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BackupMode.Descriptor instead.
func (BackupMode) EnumDescriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{3}
}

type MetaVersion int32

const (
	MetaVersion_V1 MetaVersion = 0
	MetaVersion_V2 MetaVersion = 1
)

// Enum value maps for MetaVersion.
var (
	MetaVersion_name = map[int32]string{
		0: "V1",
		1: "V2",
	}
	MetaVersion_value = map[string]int32{
		"V1": 0,
		"V2": 1,
	}
)

func (x MetaVersion) Enum() *MetaVersion {
	p := new(MetaVersion)
	*p = x
	return p
}

func (x MetaVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MetaVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_brpb_proto_enumTypes[4].Descriptor()
}

func (MetaVersion) Type() protoreflect.EnumType {
	return &file_brpb_proto_enumTypes[4]
}

func (x MetaVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MetaVersion.Descriptor instead.
func (MetaVersion) EnumDescriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{4}
}

type FileType int32

const (
	FileType_Delete FileType = 0
	FileType_Put    FileType = 1
)

// Enum value maps for FileType.
var (
	FileType_name = map[int32]string{
		0: "Delete",
		1: "Put",
	}
	FileType_value = map[string]int32{
		"Delete": 0,
		"Put":    1,
	}
)

func (x FileType) Enum() *FileType {
	p := new(FileType)
	*p = x
	return p
}

func (x FileType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FileType) Descriptor() protoreflect.EnumDescriptor {
	return file_brpb_proto_enumTypes[5].Descriptor()
}

func (FileType) Type() protoreflect.EnumType {
	return &file_brpb_proto_enumTypes[5]
}

func (x FileType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FileType.Descriptor instead.
func (FileType) EnumDescriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{5}
}

type MigrationVersion int32

const (
	// The initial version. Somehow "UNKNOWN".
	MigrationVersion_M0 MigrationVersion = 0
	// Added `creator` and `version`.
	MigrationVersion_M1 MigrationVersion = 1
	// Added `ingested_sst_paths`.
	MigrationVersion_M2 MigrationVersion = 2
)

// Enum value maps for MigrationVersion.
var (
	MigrationVersion_name = map[int32]string{
		0: "M0",
		1: "M1",
		2: "M2",
	}
	MigrationVersion_value = map[string]int32{
		"M0": 0,
		"M1": 1,
		"M2": 2,
	}
)

func (x MigrationVersion) Enum() *MigrationVersion {
	p := new(MigrationVersion)
	*p = x
	return p
}

func (x MigrationVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MigrationVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_brpb_proto_enumTypes[6].Descriptor()
}

func (MigrationVersion) Type() protoreflect.EnumType {
	return &file_brpb_proto_enumTypes[6]
}

func (x MigrationVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MigrationVersion.Descriptor instead.
func (MigrationVersion) EnumDescriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{6}
}

type PrepareSnapshotBackupRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the request.
	Ty PrepareSnapshotBackupRequestType `protobuf:"varint,1,opt,name=ty,proto3,enum=backup.PrepareSnapshotBackupRequestType" json:"ty,omitempty"`
	// The regions related to the request.
	// If the request is "UpdateLease" or "Finish", it should be empty.
	Regions []*metapb.Region `protobuf:"bytes,2,rep,name=regions,proto3" json:"regions,omitempty"`
	// The lease duration for "UpdateLease" request.
	LeaseInSeconds uint64 `protobuf:"varint,3,opt,name=lease_in_seconds,json=leaseInSeconds,proto3" json:"lease_in_seconds,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PrepareSnapshotBackupRequest) Reset() {
	*x = PrepareSnapshotBackupRequest{}
	mi := &file_brpb_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareSnapshotBackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareSnapshotBackupRequest) ProtoMessage() {}

func (x *PrepareSnapshotBackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareSnapshotBackupRequest.ProtoReflect.Descriptor instead.
func (*PrepareSnapshotBackupRequest) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{0}
}

func (x *PrepareSnapshotBackupRequest) GetTy() PrepareSnapshotBackupRequestType {
	if x != nil {
		return x.Ty
	}
	return PrepareSnapshotBackupRequestType_UpdateLease
}

func (x *PrepareSnapshotBackupRequest) GetRegions() []*metapb.Region {
	if x != nil {
		return x.Regions
	}
	return nil
}

func (x *PrepareSnapshotBackupRequest) GetLeaseInSeconds() uint64 {
	if x != nil {
		return x.LeaseInSeconds
	}
	return 0
}

type PrepareSnapshotBackupResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the event.
	Ty PrepareSnapshotBackupEventType `protobuf:"varint,1,opt,name=ty,proto3,enum=backup.PrepareSnapshotBackupEventType" json:"ty,omitempty"`
	// The region bind to the type.
	// For "WaitApplyDone".
	Region *metapb.Region `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	// The error of the execution.
	Error *errorpb.Error `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	// Whether the last lease is valid.
	// For "UpdateLease" and "Finish".
	LastLeaseIsValid bool `protobuf:"varint,4,opt,name=last_lease_is_valid,json=lastLeaseIsValid,proto3" json:"last_lease_is_valid,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PrepareSnapshotBackupResponse) Reset() {
	*x = PrepareSnapshotBackupResponse{}
	mi := &file_brpb_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareSnapshotBackupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareSnapshotBackupResponse) ProtoMessage() {}

func (x *PrepareSnapshotBackupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareSnapshotBackupResponse.ProtoReflect.Descriptor instead.
func (*PrepareSnapshotBackupResponse) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{1}
}

func (x *PrepareSnapshotBackupResponse) GetTy() PrepareSnapshotBackupEventType {
	if x != nil {
		return x.Ty
	}
	return PrepareSnapshotBackupEventType_WaitApplyDone
}

func (x *PrepareSnapshotBackupResponse) GetRegion() *metapb.Region {
	if x != nil {
		return x.Region
	}
	return nil
}

func (x *PrepareSnapshotBackupResponse) GetError() *errorpb.Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *PrepareSnapshotBackupResponse) GetLastLeaseIsValid() bool {
	if x != nil {
		return x.LastLeaseIsValid
	}
	return false
}

// The message save the metadata of a backup.
type BackupMeta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID and version of backuped cluster.
	ClusterId      uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	ClusterVersion string `protobuf:"bytes,2,opt,name=cluster_version,json=clusterVersion,proto3" json:"cluster_version,omitempty"`
	// Save the version of BR running backup jobs.
	BrVersion string `protobuf:"bytes,11,opt,name=br_version,json=brVersion,proto3" json:"br_version,omitempty"`
	// The backupmeta scheme version.
	Version int32 `protobuf:"varint,12,opt,name=version,proto3" json:"version,omitempty"`
	// A set of files that compose a backup.
	// Note: `files` is deprecated, as it bloats backupmeta. It is kept for
	//
	//	compatibility, so new BR can restore older backups.
	Files []*File `protobuf:"bytes,4,rep,name=files,proto3" json:"files,omitempty"`
	// An index to files contains data files.
	FileIndex *MetaFile `protobuf:"bytes,13,opt,name=file_index,json=fileIndex,proto3" json:"file_index,omitempty"`
	// A pair of timestamp specifies a time range of a backup.
	// For full backup, the start_version equals to the end_version,
	// it means point in time.
	// For incremental backup, the time range is specified as
	// (start_version, end_version].
	StartVersion uint64 `protobuf:"varint,5,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64 `protobuf:"varint,6,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	// Table metadata describes database and table info.
	// Note: `schemas` is deprecated, as it bloats backupmeta. It is kept for
	//
	//	compatibility, so new BR can restore older backups.
	Schemas []*Schema `protobuf:"bytes,7,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// An index to files contains Schemas.
	SchemaIndex *MetaFile `protobuf:"bytes,14,opt,name=schema_index,json=schemaIndex,proto3" json:"schema_index,omitempty"`
	// If in raw kv mode, `start_versions`, `end_versions` and `schemas` will be
	// ignored, and the backup data's range is represented by raw_ranges.
	IsRawKv bool `protobuf:"varint,8,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	// Note: `raw_ranges` is deprecated, as it bloats backupmeta. It is kept for
	//
	//	compatibility, so new BR can restore older backups.
	RawRanges []*RawRange `protobuf:"bytes,9,rep,name=raw_ranges,json=rawRanges,proto3" json:"raw_ranges,omitempty"`
	// An index to files contains RawRanges.
	RawRangeIndex *MetaFile `protobuf:"bytes,15,opt,name=raw_range_index,json=rawRangeIndex,proto3" json:"raw_range_index,omitempty"`
	// In incremental backup, DDLs which are completed in
	// (lastBackupTS, backupTS] will be stored here.
	// Note: `raw_ranges` is deprecated, as it bloats backupmeta. It is kept for
	//
	//	compatibility, so new BR can restore older backups.
	Ddls []byte `protobuf:"bytes,10,opt,name=ddls,proto3" json:"ddls,omitempty"`
	// An index to files contains DDLs.
	DdlIndexes *MetaFile `protobuf:"bytes,16,opt,name=ddl_indexes,json=ddlIndexes,proto3" json:"ddl_indexes,omitempty"`
	// the backup result into `backupmeta` file
	BackupResult string `protobuf:"bytes,17,opt,name=backup_result,json=backupResult,proto3" json:"backup_result,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion kvrpcpb.APIVersion `protobuf:"varint,18,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// the placement policy info in backup cluster. we assume the policy won't be too much for one cluster.
	Policies []*PlacementPolicy `protobuf:"bytes,19,rep,name=policies,proto3" json:"policies,omitempty"`
	// new_collations_enabled specifies the config `new_collations_enabled_on_first_bootstrap` in tidb.
	NewCollationsEnabled string `protobuf:"bytes,20,opt,name=new_collations_enabled,json=newCollationsEnabled,proto3" json:"new_collations_enabled,omitempty"`
	// If in txn kv mode, `schemas` will be ignored, the backup data's range is as same as normal backup.
	IsTxnKv bool `protobuf:"varint,21,opt,name=is_txn_kv,json=isTxnKv,proto3" json:"is_txn_kv,omitempty"`
	// maintain the id mapping from upstream cluster to downstream cluster.
	DbMaps []*PitrDBMap `protobuf:"bytes,22,rep,name=db_maps,json=dbMaps,proto3" json:"db_maps,omitempty"`
	Mode   BackupMode   `protobuf:"varint,23,opt,name=mode,proto3,enum=backup.BackupMode" json:"mode,omitempty"`
	// record the backup range and the correspond SST files when using file-copy backup.
	Ranges []*BackupRange `protobuf:"bytes,24,rep,name=ranges,proto3" json:"ranges,omitempty"`
	// record the size of the backup data files and meta files
	BackupSize    uint64 `protobuf:"varint,25,opt,name=backup_size,json=backupSize,proto3" json:"backup_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackupMeta) Reset() {
	*x = BackupMeta{}
	mi := &file_brpb_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackupMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupMeta) ProtoMessage() {}

func (x *BackupMeta) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupMeta.ProtoReflect.Descriptor instead.
func (*BackupMeta) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{2}
}

func (x *BackupMeta) GetClusterId() uint64 {
	if x != nil {
		return x.ClusterId
	}
	return 0
}

func (x *BackupMeta) GetClusterVersion() string {
	if x != nil {
		return x.ClusterVersion
	}
	return ""
}

func (x *BackupMeta) GetBrVersion() string {
	if x != nil {
		return x.BrVersion
	}
	return ""
}

func (x *BackupMeta) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *BackupMeta) GetFiles() []*File {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *BackupMeta) GetFileIndex() *MetaFile {
	if x != nil {
		return x.FileIndex
	}
	return nil
}

func (x *BackupMeta) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *BackupMeta) GetEndVersion() uint64 {
	if x != nil {
		return x.EndVersion
	}
	return 0
}

func (x *BackupMeta) GetSchemas() []*Schema {
	if x != nil {
		return x.Schemas
	}
	return nil
}

func (x *BackupMeta) GetSchemaIndex() *MetaFile {
	if x != nil {
		return x.SchemaIndex
	}
	return nil
}

func (x *BackupMeta) GetIsRawKv() bool {
	if x != nil {
		return x.IsRawKv
	}
	return false
}

func (x *BackupMeta) GetRawRanges() []*RawRange {
	if x != nil {
		return x.RawRanges
	}
	return nil
}

func (x *BackupMeta) GetRawRangeIndex() *MetaFile {
	if x != nil {
		return x.RawRangeIndex
	}
	return nil
}

func (x *BackupMeta) GetDdls() []byte {
	if x != nil {
		return x.Ddls
	}
	return nil
}

func (x *BackupMeta) GetDdlIndexes() *MetaFile {
	if x != nil {
		return x.DdlIndexes
	}
	return nil
}

func (x *BackupMeta) GetBackupResult() string {
	if x != nil {
		return x.BackupResult
	}
	return ""
}

func (x *BackupMeta) GetApiVersion() kvrpcpb.APIVersion {
	if x != nil {
		return x.ApiVersion
	}
	return kvrpcpb.APIVersion(0)
}

func (x *BackupMeta) GetPolicies() []*PlacementPolicy {
	if x != nil {
		return x.Policies
	}
	return nil
}

func (x *BackupMeta) GetNewCollationsEnabled() string {
	if x != nil {
		return x.NewCollationsEnabled
	}
	return ""
}

func (x *BackupMeta) GetIsTxnKv() bool {
	if x != nil {
		return x.IsTxnKv
	}
	return false
}

func (x *BackupMeta) GetDbMaps() []*PitrDBMap {
	if x != nil {
		return x.DbMaps
	}
	return nil
}

func (x *BackupMeta) GetMode() BackupMode {
	if x != nil {
		return x.Mode
	}
	return BackupMode_SCAN
}

func (x *BackupMeta) GetRanges() []*BackupRange {
	if x != nil {
		return x.Ranges
	}
	return nil
}

func (x *BackupMeta) GetBackupSize() uint64 {
	if x != nil {
		return x.BackupSize
	}
	return 0
}

type BackupRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StartKey      []byte                 `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey        []byte                 `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Files         []*File                `protobuf:"bytes,3,rep,name=files,proto3" json:"files,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackupRange) Reset() {
	*x = BackupRange{}
	mi := &file_brpb_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackupRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupRange) ProtoMessage() {}

func (x *BackupRange) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupRange.ProtoReflect.Descriptor instead.
func (*BackupRange) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{3}
}

func (x *BackupRange) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *BackupRange) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *BackupRange) GetFiles() []*File {
	if x != nil {
		return x.Files
	}
	return nil
}

// The message saves the physical table checksum
type TableMeta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// physical id is either table id or partition id
	PhysicalId    int64  `protobuf:"varint,1,opt,name=physical_id,json=physicalId,proto3" json:"physical_id,omitempty"`
	Crc64Xor      uint64 `protobuf:"varint,2,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	TotalKvs      uint64 `protobuf:"varint,3,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes    uint64 `protobuf:"varint,4,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TableMeta) Reset() {
	*x = TableMeta{}
	mi := &file_brpb_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TableMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableMeta) ProtoMessage() {}

func (x *TableMeta) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableMeta.ProtoReflect.Descriptor instead.
func (*TableMeta) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{4}
}

func (x *TableMeta) GetPhysicalId() int64 {
	if x != nil {
		return x.PhysicalId
	}
	return 0
}

func (x *TableMeta) GetCrc64Xor() uint64 {
	if x != nil {
		return x.Crc64Xor
	}
	return 0
}

func (x *TableMeta) GetTotalKvs() uint64 {
	if x != nil {
		return x.TotalKvs
	}
	return 0
}

func (x *TableMeta) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

type File struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Name         string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sha256       []byte                 `protobuf:"bytes,2,opt,name=sha256,proto3" json:"sha256,omitempty"`
	StartKey     []byte                 `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey       []byte                 `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	StartVersion uint64                 `protobuf:"varint,5,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64                 `protobuf:"varint,6,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	// recorded the total statistics across multiple tables
	Crc64Xor   uint64 `protobuf:"varint,7,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	TotalKvs   uint64 `protobuf:"varint,8,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes uint64 `protobuf:"varint,9,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// recorded when the SST kvs are from different tables
	TableMetas []*TableMeta `protobuf:"bytes,13,rep,name=table_metas,json=tableMetas,proto3" json:"table_metas,omitempty"`
	Cf         string       `protobuf:"bytes,10,opt,name=cf,proto3" json:"cf,omitempty"`
	Size       uint64       `protobuf:"varint,11,opt,name=size,proto3" json:"size,omitempty"`
	// cipher_iv is used for AES cipher
	CipherIv      []byte `protobuf:"bytes,12,opt,name=cipher_iv,json=cipherIv,proto3" json:"cipher_iv,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *File) Reset() {
	*x = File{}
	mi := &file_brpb_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *File) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*File) ProtoMessage() {}

func (x *File) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use File.ProtoReflect.Descriptor instead.
func (*File) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{5}
}

func (x *File) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *File) GetSha256() []byte {
	if x != nil {
		return x.Sha256
	}
	return nil
}

func (x *File) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *File) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *File) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *File) GetEndVersion() uint64 {
	if x != nil {
		return x.EndVersion
	}
	return 0
}

func (x *File) GetCrc64Xor() uint64 {
	if x != nil {
		return x.Crc64Xor
	}
	return 0
}

func (x *File) GetTotalKvs() uint64 {
	if x != nil {
		return x.TotalKvs
	}
	return 0
}

func (x *File) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *File) GetTableMetas() []*TableMeta {
	if x != nil {
		return x.TableMetas
	}
	return nil
}

func (x *File) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *File) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *File) GetCipherIv() []byte {
	if x != nil {
		return x.CipherIv
	}
	return nil
}

// MetaFile describes a multi-level index of data used in backup.
type MetaFile struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A set of files that contains a MetaFile.
	// It is used as a multi-level index.
	MetaFiles []*File `protobuf:"bytes,1,rep,name=meta_files,json=metaFiles,proto3" json:"meta_files,omitempty"`
	// A set of files that contains user data.
	DataFiles []*File `protobuf:"bytes,2,rep,name=data_files,json=dataFiles,proto3" json:"data_files,omitempty"`
	// A set of files that contains Schemas.
	Schemas []*Schema `protobuf:"bytes,3,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// A set of files that contains RawRanges.
	RawRanges []*RawRange `protobuf:"bytes,4,rep,name=raw_ranges,json=rawRanges,proto3" json:"raw_ranges,omitempty"`
	// A set of files that contains BackupRanges.
	BackupRanges []*BackupRange `protobuf:"bytes,6,rep,name=backup_ranges,json=backupRanges,proto3" json:"backup_ranges,omitempty"`
	// A set of files that contains DDLs.
	Ddls          [][]byte `protobuf:"bytes,5,rep,name=ddls,proto3" json:"ddls,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetaFile) Reset() {
	*x = MetaFile{}
	mi := &file_brpb_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetaFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetaFile) ProtoMessage() {}

func (x *MetaFile) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetaFile.ProtoReflect.Descriptor instead.
func (*MetaFile) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{6}
}

func (x *MetaFile) GetMetaFiles() []*File {
	if x != nil {
		return x.MetaFiles
	}
	return nil
}

func (x *MetaFile) GetDataFiles() []*File {
	if x != nil {
		return x.DataFiles
	}
	return nil
}

func (x *MetaFile) GetSchemas() []*Schema {
	if x != nil {
		return x.Schemas
	}
	return nil
}

func (x *MetaFile) GetRawRanges() []*RawRange {
	if x != nil {
		return x.RawRanges
	}
	return nil
}

func (x *MetaFile) GetBackupRanges() []*BackupRange {
	if x != nil {
		return x.BackupRanges
	}
	return nil
}

func (x *MetaFile) GetDdls() [][]byte {
	if x != nil {
		return x.Ddls
	}
	return nil
}

type PlacementPolicy struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Info          []byte                 `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlacementPolicy) Reset() {
	*x = PlacementPolicy{}
	mi := &file_brpb_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlacementPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlacementPolicy) ProtoMessage() {}

func (x *PlacementPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlacementPolicy.ProtoReflect.Descriptor instead.
func (*PlacementPolicy) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{7}
}

func (x *PlacementPolicy) GetInfo() []byte {
	if x != nil {
		return x.Info
	}
	return nil
}

type StatsBlock struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The physical id which the stats json data belongs to.
	PhysicalId int64 `protobuf:"varint,1,opt,name=physical_id,json=physicalId,proto3" json:"physical_id,omitempty"`
	// The marshal data of the part of json_table. Currently it is the partition table.
	JsonTable     []byte `protobuf:"bytes,2,opt,name=json_table,json=jsonTable,proto3" json:"json_table,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatsBlock) Reset() {
	*x = StatsBlock{}
	mi := &file_brpb_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatsBlock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatsBlock) ProtoMessage() {}

func (x *StatsBlock) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatsBlock.ProtoReflect.Descriptor instead.
func (*StatsBlock) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{8}
}

func (x *StatsBlock) GetPhysicalId() int64 {
	if x != nil {
		return x.PhysicalId
	}
	return 0
}

func (x *StatsBlock) GetJsonTable() []byte {
	if x != nil {
		return x.JsonTable
	}
	return nil
}

type StatsFile struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A set of files that contains json_tables.
	Blocks        []*StatsBlock `protobuf:"bytes,1,rep,name=blocks,proto3" json:"blocks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatsFile) Reset() {
	*x = StatsFile{}
	mi := &file_brpb_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatsFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatsFile) ProtoMessage() {}

func (x *StatsFile) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatsFile.ProtoReflect.Descriptor instead.
func (*StatsFile) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{9}
}

func (x *StatsFile) GetBlocks() []*StatsBlock {
	if x != nil {
		return x.Blocks
	}
	return nil
}

type StatsFileIndex struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Name   string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sha256 []byte                 `protobuf:"bytes,2,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// the size of the file content encrypted
	SizeEnc uint64 `protobuf:"varint,3,opt,name=size_enc,json=sizeEnc,proto3" json:"size_enc,omitempty"`
	// the size of the original file content
	SizeOri uint64 `protobuf:"varint,4,opt,name=size_ori,json=sizeOri,proto3" json:"size_ori,omitempty"`
	// cipher_iv is used for AES cipher
	CipherIv []byte `protobuf:"bytes,5,opt,name=cipher_iv,json=cipherIv,proto3" json:"cipher_iv,omitempty"`
	// If the size of the stats is very small, save the data into the metafile
	InlineData    []byte `protobuf:"bytes,6,opt,name=inline_data,json=inlineData,proto3" json:"inline_data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatsFileIndex) Reset() {
	*x = StatsFileIndex{}
	mi := &file_brpb_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatsFileIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatsFileIndex) ProtoMessage() {}

func (x *StatsFileIndex) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatsFileIndex.ProtoReflect.Descriptor instead.
func (*StatsFileIndex) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{10}
}

func (x *StatsFileIndex) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StatsFileIndex) GetSha256() []byte {
	if x != nil {
		return x.Sha256
	}
	return nil
}

func (x *StatsFileIndex) GetSizeEnc() uint64 {
	if x != nil {
		return x.SizeEnc
	}
	return 0
}

func (x *StatsFileIndex) GetSizeOri() uint64 {
	if x != nil {
		return x.SizeOri
	}
	return 0
}

func (x *StatsFileIndex) GetCipherIv() []byte {
	if x != nil {
		return x.CipherIv
	}
	return nil
}

func (x *StatsFileIndex) GetInlineData() []byte {
	if x != nil {
		return x.InlineData
	}
	return nil
}

type Schema struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Db              []byte                 `protobuf:"bytes,1,opt,name=db,proto3" json:"db,omitempty"`
	Table           []byte                 `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	Crc64Xor        uint64                 `protobuf:"varint,3,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	TotalKvs        uint64                 `protobuf:"varint,4,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes      uint64                 `protobuf:"varint,5,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	TiflashReplicas uint32                 `protobuf:"varint,6,opt,name=tiflash_replicas,json=tiflashReplicas,proto3" json:"tiflash_replicas,omitempty"`
	// stats represents the dump stats for a analyzed table, which generate by DumpStatsToJSON
	// https://github.com/pingcap/tidb/blob/e136429d8dc5d70f43cd3f94179b0b9f47595097/statistics/handle/dump.go#L116
	Stats []byte `protobuf:"bytes,7,opt,name=stats,proto3" json:"stats,omitempty"`
	// An index of files that contains stats data
	StatsIndex []*StatsFileIndex `protobuf:"bytes,8,rep,name=stats_index,json=statsIndex,proto3" json:"stats_index,omitempty"`
	// is_merge_option_allowed indicates whether merge option is allowed for this schema.
	// For backward compatibility, this field defaults to false when not present.
	IsMergeOptionAllowed bool `protobuf:"varint,9,opt,name=is_merge_option_allowed,json=isMergeOptionAllowed,proto3" json:"is_merge_option_allowed,omitempty"`
	// partition_merge_option_allowed indicates whether merge option is allowed for each partition.
	// is_merge_option_allowed is table level, and the partition_merge_option_allowed is partition level.
	PartitionMergeOptionAllowed map[string]bool `protobuf:"bytes,10,rep,name=partition_merge_option_allowed,json=partitionMergeOptionAllowed,proto3" json:"partition_merge_option_allowed,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *Schema) Reset() {
	*x = Schema{}
	mi := &file_brpb_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Schema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Schema) ProtoMessage() {}

func (x *Schema) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Schema.ProtoReflect.Descriptor instead.
func (*Schema) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{11}
}

func (x *Schema) GetDb() []byte {
	if x != nil {
		return x.Db
	}
	return nil
}

func (x *Schema) GetTable() []byte {
	if x != nil {
		return x.Table
	}
	return nil
}

func (x *Schema) GetCrc64Xor() uint64 {
	if x != nil {
		return x.Crc64Xor
	}
	return 0
}

func (x *Schema) GetTotalKvs() uint64 {
	if x != nil {
		return x.TotalKvs
	}
	return 0
}

func (x *Schema) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *Schema) GetTiflashReplicas() uint32 {
	if x != nil {
		return x.TiflashReplicas
	}
	return 0
}

func (x *Schema) GetStats() []byte {
	if x != nil {
		return x.Stats
	}
	return nil
}

func (x *Schema) GetStatsIndex() []*StatsFileIndex {
	if x != nil {
		return x.StatsIndex
	}
	return nil
}

func (x *Schema) GetIsMergeOptionAllowed() bool {
	if x != nil {
		return x.IsMergeOptionAllowed
	}
	return false
}

func (x *Schema) GetPartitionMergeOptionAllowed() map[string]bool {
	if x != nil {
		return x.PartitionMergeOptionAllowed
	}
	return nil
}

type IDMap struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UpstreamId    int64                  `protobuf:"varint,1,opt,name=upstream_id,json=upstreamId,proto3" json:"upstream_id,omitempty"`
	DownstreamId  int64                  `protobuf:"varint,2,opt,name=downstream_id,json=downstreamId,proto3" json:"downstream_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IDMap) Reset() {
	*x = IDMap{}
	mi := &file_brpb_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IDMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IDMap) ProtoMessage() {}

func (x *IDMap) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IDMap.ProtoReflect.Descriptor instead.
func (*IDMap) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{12}
}

func (x *IDMap) GetUpstreamId() int64 {
	if x != nil {
		return x.UpstreamId
	}
	return 0
}

func (x *IDMap) GetDownstreamId() int64 {
	if x != nil {
		return x.DownstreamId
	}
	return 0
}

type PitrTableMap struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Name       string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IdMap      *IDMap                 `protobuf:"bytes,2,opt,name=id_map,json=idMap,proto3" json:"id_map,omitempty"`
	Partitions []*IDMap               `protobuf:"bytes,3,rep,name=partitions,proto3" json:"partitions,omitempty"`
	// whether this table has been filtered out
	FilteredOut   bool `protobuf:"varint,4,opt,name=filtered_out,json=filteredOut,proto3" json:"filtered_out,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PitrTableMap) Reset() {
	*x = PitrTableMap{}
	mi := &file_brpb_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PitrTableMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PitrTableMap) ProtoMessage() {}

func (x *PitrTableMap) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PitrTableMap.ProtoReflect.Descriptor instead.
func (*PitrTableMap) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{13}
}

func (x *PitrTableMap) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PitrTableMap) GetIdMap() *IDMap {
	if x != nil {
		return x.IdMap
	}
	return nil
}

func (x *PitrTableMap) GetPartitions() []*IDMap {
	if x != nil {
		return x.Partitions
	}
	return nil
}

func (x *PitrTableMap) GetFilteredOut() bool {
	if x != nil {
		return x.FilteredOut
	}
	return false
}

type PitrDBMap struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Name   string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IdMap  *IDMap                 `protobuf:"bytes,2,opt,name=id_map,json=idMap,proto3" json:"id_map,omitempty"`
	Tables []*PitrTableMap        `protobuf:"bytes,3,rep,name=tables,proto3" json:"tables,omitempty"`
	// whether this db has been filtered out
	FilteredOut bool `protobuf:"varint,4,opt,name=filtered_out,json=filteredOut,proto3" json:"filtered_out,omitempty"`
	// whether this db has been reused
	// skip restoring the metakv of database in log restore if it is true
	Reused        bool `protobuf:"varint,5,opt,name=reused,proto3" json:"reused,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PitrDBMap) Reset() {
	*x = PitrDBMap{}
	mi := &file_brpb_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PitrDBMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PitrDBMap) ProtoMessage() {}

func (x *PitrDBMap) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PitrDBMap.ProtoReflect.Descriptor instead.
func (*PitrDBMap) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{14}
}

func (x *PitrDBMap) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PitrDBMap) GetIdMap() *IDMap {
	if x != nil {
		return x.IdMap
	}
	return nil
}

func (x *PitrDBMap) GetTables() []*PitrTableMap {
	if x != nil {
		return x.Tables
	}
	return nil
}

func (x *PitrDBMap) GetFilteredOut() bool {
	if x != nil {
		return x.FilteredOut
	}
	return false
}

func (x *PitrDBMap) GetReused() bool {
	if x != nil {
		return x.Reused
	}
	return false
}

type RawRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StartKey      []byte                 `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey        []byte                 `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Cf            string                 `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RawRange) Reset() {
	*x = RawRange{}
	mi := &file_brpb_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RawRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawRange) ProtoMessage() {}

func (x *RawRange) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawRange.ProtoReflect.Descriptor instead.
func (*RawRange) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{15}
}

func (x *RawRange) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *RawRange) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *RawRange) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

type ClusterIDError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Current       uint64                 `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
	Request       uint64                 `protobuf:"varint,2,opt,name=request,proto3" json:"request,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterIDError) Reset() {
	*x = ClusterIDError{}
	mi := &file_brpb_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterIDError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterIDError) ProtoMessage() {}

func (x *ClusterIDError) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterIDError.ProtoReflect.Descriptor instead.
func (*ClusterIDError) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{16}
}

func (x *ClusterIDError) GetCurrent() uint64 {
	if x != nil {
		return x.Current
	}
	return 0
}

func (x *ClusterIDError) GetRequest() uint64 {
	if x != nil {
		return x.Request
	}
	return 0
}

type Error struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Msg   string                 `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// Types that are valid to be assigned to Detail:
	//
	//	*Error_ClusterIdError
	//	*Error_KvError
	//	*Error_RegionError
	Detail        isError_Detail `protobuf_oneof:"detail"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Error) Reset() {
	*x = Error{}
	mi := &file_brpb_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Error) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Error) ProtoMessage() {}

func (x *Error) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{17}
}

func (x *Error) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

func (x *Error) GetDetail() isError_Detail {
	if x != nil {
		return x.Detail
	}
	return nil
}

func (x *Error) GetClusterIdError() *ClusterIDError {
	if x != nil {
		if x, ok := x.Detail.(*Error_ClusterIdError); ok {
			return x.ClusterIdError
		}
	}
	return nil
}

func (x *Error) GetKvError() *kvrpcpb.KeyError {
	if x != nil {
		if x, ok := x.Detail.(*Error_KvError); ok {
			return x.KvError
		}
	}
	return nil
}

func (x *Error) GetRegionError() *errorpb.Error {
	if x != nil {
		if x, ok := x.Detail.(*Error_RegionError); ok {
			return x.RegionError
		}
	}
	return nil
}

type isError_Detail interface {
	isError_Detail()
}

type Error_ClusterIdError struct {
	ClusterIdError *ClusterIDError `protobuf:"bytes,3,opt,name=cluster_id_error,json=clusterIdError,proto3,oneof"`
}

type Error_KvError struct {
	KvError *kvrpcpb.KeyError `protobuf:"bytes,4,opt,name=kv_error,json=kvError,proto3,oneof"`
}

type Error_RegionError struct {
	RegionError *errorpb.Error `protobuf:"bytes,5,opt,name=region_error,json=regionError,proto3,oneof"`
}

func (*Error_ClusterIdError) isError_Detail() {}

func (*Error_KvError) isError_Detail() {}

func (*Error_RegionError) isError_Detail() {}

type StreamBackupTaskSecurityConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Encryption:
	//
	//	*StreamBackupTaskSecurityConfig_PlaintextDataKey
	//	*StreamBackupTaskSecurityConfig_MasterKeyConfig
	Encryption    isStreamBackupTaskSecurityConfig_Encryption `protobuf_oneof:"encryption"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamBackupTaskSecurityConfig) Reset() {
	*x = StreamBackupTaskSecurityConfig{}
	mi := &file_brpb_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamBackupTaskSecurityConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamBackupTaskSecurityConfig) ProtoMessage() {}

func (x *StreamBackupTaskSecurityConfig) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamBackupTaskSecurityConfig.ProtoReflect.Descriptor instead.
func (*StreamBackupTaskSecurityConfig) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{18}
}

func (x *StreamBackupTaskSecurityConfig) GetEncryption() isStreamBackupTaskSecurityConfig_Encryption {
	if x != nil {
		return x.Encryption
	}
	return nil
}

func (x *StreamBackupTaskSecurityConfig) GetPlaintextDataKey() *CipherInfo {
	if x != nil {
		if x, ok := x.Encryption.(*StreamBackupTaskSecurityConfig_PlaintextDataKey); ok {
			return x.PlaintextDataKey
		}
	}
	return nil
}

func (x *StreamBackupTaskSecurityConfig) GetMasterKeyConfig() *MasterKeyConfig {
	if x != nil {
		if x, ok := x.Encryption.(*StreamBackupTaskSecurityConfig_MasterKeyConfig); ok {
			return x.MasterKeyConfig
		}
	}
	return nil
}

type isStreamBackupTaskSecurityConfig_Encryption interface {
	isStreamBackupTaskSecurityConfig_Encryption()
}

type StreamBackupTaskSecurityConfig_PlaintextDataKey struct {
	// not recommended in production. configure KMS based or locally managed master key instead in TiKV StreamBackupConfig
	PlaintextDataKey *CipherInfo `protobuf:"bytes,1,opt,name=plaintext_data_key,json=plaintextDataKey,proto3,oneof"`
}

type StreamBackupTaskSecurityConfig_MasterKeyConfig struct {
	MasterKeyConfig *MasterKeyConfig `protobuf:"bytes,2,opt,name=master_key_config,json=masterKeyConfig,proto3,oneof"`
}

func (*StreamBackupTaskSecurityConfig_PlaintextDataKey) isStreamBackupTaskSecurityConfig_Encryption() {
}

func (*StreamBackupTaskSecurityConfig_MasterKeyConfig) isStreamBackupTaskSecurityConfig_Encryption() {
}

type CipherInfo struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	CipherType    encryptionpb.EncryptionMethod `protobuf:"varint,1,opt,name=cipher_type,json=cipherType,proto3,enum=encryptionpb.EncryptionMethod" json:"cipher_type,omitempty"`
	CipherKey     []byte                        `protobuf:"bytes,2,opt,name=cipher_key,json=cipherKey,proto3" json:"cipher_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CipherInfo) Reset() {
	*x = CipherInfo{}
	mi := &file_brpb_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CipherInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CipherInfo) ProtoMessage() {}

func (x *CipherInfo) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CipherInfo.ProtoReflect.Descriptor instead.
func (*CipherInfo) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{19}
}

func (x *CipherInfo) GetCipherType() encryptionpb.EncryptionMethod {
	if x != nil {
		return x.CipherType
	}
	return encryptionpb.EncryptionMethod(0)
}

func (x *CipherInfo) GetCipherKey() []byte {
	if x != nil {
		return x.CipherKey
	}
	return nil
}

type MasterKeyConfig struct {
	state          protoimpl.MessageState        `protogen:"open.v1"`
	EncryptionType encryptionpb.EncryptionMethod `protobuf:"varint,1,opt,name=encryption_type,json=encryptionType,proto3,enum=encryptionpb.EncryptionMethod" json:"encryption_type,omitempty"`
	MasterKeys     []*encryptionpb.MasterKey     `protobuf:"bytes,2,rep,name=master_keys,json=masterKeys,proto3" json:"master_keys,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *MasterKeyConfig) Reset() {
	*x = MasterKeyConfig{}
	mi := &file_brpb_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MasterKeyConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MasterKeyConfig) ProtoMessage() {}

func (x *MasterKeyConfig) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MasterKeyConfig.ProtoReflect.Descriptor instead.
func (*MasterKeyConfig) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{20}
}

func (x *MasterKeyConfig) GetEncryptionType() encryptionpb.EncryptionMethod {
	if x != nil {
		return x.EncryptionType
	}
	return encryptionpb.EncryptionMethod(0)
}

func (x *MasterKeyConfig) GetMasterKeys() []*encryptionpb.MasterKey {
	if x != nil {
		return x.MasterKeys
	}
	return nil
}

type SortedSubRanges struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SubRanges     []*kvrpcpb.KeyRange    `protobuf:"bytes,1,rep,name=sub_ranges,json=subRanges,proto3" json:"sub_ranges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SortedSubRanges) Reset() {
	*x = SortedSubRanges{}
	mi := &file_brpb_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SortedSubRanges) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SortedSubRanges) ProtoMessage() {}

func (x *SortedSubRanges) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SortedSubRanges.ProtoReflect.Descriptor instead.
func (*SortedSubRanges) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{21}
}

func (x *SortedSubRanges) GetSubRanges() []*kvrpcpb.KeyRange {
	if x != nil {
		return x.SubRanges
	}
	return nil
}

type BackupRequest struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	ClusterId    uint64                 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	StartKey     []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey       []byte                 `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	StartVersion uint64                 `protobuf:"varint,4,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64                 `protobuf:"varint,5,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	// The I/O rate limit for backup request.
	RateLimit uint64 `protobuf:"varint,7,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	// The concurrency for executing the backup request in every tikv node.
	Concurrency    uint32          `protobuf:"varint,8,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	StorageBackend *StorageBackend `protobuf:"bytes,9,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	// If raw kv mode is enabled, `start_version` and `end_version` will be ignored, and `cf`
	// specifies which cf to backup.
	IsRawKv bool   `protobuf:"varint,10,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	Cf      string `protobuf:"bytes,11,opt,name=cf,proto3" json:"cf,omitempty"`
	// algorithm used for compress sst files
	CompressionType CompressionType `protobuf:"varint,12,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// sst compression level, some algorithms support negative compression levels
	CompressionLevel int32 `protobuf:"varint,13,opt,name=compression_level,json=compressionLevel,proto3" json:"compression_level,omitempty"`
	// The cipher_info is Used to encrypt sst
	CipherInfo *CipherInfo `protobuf:"bytes,14,opt,name=cipher_info,json=cipherInfo,proto3" json:"cipher_info,omitempty"`
	// dst_api_version indicates the key-value encoding version used by the
	// generated SST file. Accepted values:
	//  1. "v1": the generated SST files are encoded with api-v1, can be restored
	//     to TiKV clusters whose api version is set to v1.
	//  2. "v2": the generated SST files are encoded with api-v2, can be restored
	//     to TiKV clusters whose api version is set to v2.
	DstApiVersion kvrpcpb.APIVersion `protobuf:"varint,15,opt,name=dst_api_version,json=dstApiVersion,proto3,enum=kvrpcpb.APIVersion" json:"dst_api_version,omitempty"`
	// with checkpoint, some subintervals of the range have been backed up and recorded.
	// only the remaining sub ranges of the range need to be backed up this time.
	SubRanges []*kvrpcpb.KeyRange `protobuf:"bytes,16,rep,name=sub_ranges,json=subRanges,proto3" json:"sub_ranges,omitempty"`
	// only ranges in the same groups can be merged into one SST file.
	// the ranges in each groups are sorted.
	SortedSubRangesGroups []*SortedSubRanges `protobuf:"bytes,21,rep,name=sorted_sub_ranges_groups,json=sortedSubRangesGroups,proto3" json:"sorted_sub_ranges_groups,omitempty"`
	// replica_read indicates whether to use replica read for backup.
	// If it is false, the backup will only read data from leader.
	// If it is true, the backup will read data from both leader and follower.
	ReplicaRead bool       `protobuf:"varint,17,opt,name=replica_read,json=replicaRead,proto3" json:"replica_read,omitempty"`
	Mode        BackupMode `protobuf:"varint,18,opt,name=mode,proto3,enum=backup.BackupMode" json:"mode,omitempty"`
	// unique_id represents the handle of this backup. after we implement file-copy backup.
	// we need generate some internal states during the whole backup precedure.
	// this unique id is help to find the state effictively.
	UniqueId      string           `protobuf:"bytes,19,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	Context       *kvrpcpb.Context `protobuf:"bytes,20,opt,name=context,proto3" json:"context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackupRequest) Reset() {
	*x = BackupRequest{}
	mi := &file_brpb_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupRequest) ProtoMessage() {}

func (x *BackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupRequest.ProtoReflect.Descriptor instead.
func (*BackupRequest) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{22}
}

func (x *BackupRequest) GetClusterId() uint64 {
	if x != nil {
		return x.ClusterId
	}
	return 0
}

func (x *BackupRequest) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *BackupRequest) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *BackupRequest) GetStartVersion() uint64 {
	if x != nil {
		return x.StartVersion
	}
	return 0
}

func (x *BackupRequest) GetEndVersion() uint64 {
	if x != nil {
		return x.EndVersion
	}
	return 0
}

func (x *BackupRequest) GetRateLimit() uint64 {
	if x != nil {
		return x.RateLimit
	}
	return 0
}

func (x *BackupRequest) GetConcurrency() uint32 {
	if x != nil {
		return x.Concurrency
	}
	return 0
}

func (x *BackupRequest) GetStorageBackend() *StorageBackend {
	if x != nil {
		return x.StorageBackend
	}
	return nil
}

func (x *BackupRequest) GetIsRawKv() bool {
	if x != nil {
		return x.IsRawKv
	}
	return false
}

func (x *BackupRequest) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *BackupRequest) GetCompressionType() CompressionType {
	if x != nil {
		return x.CompressionType
	}
	return CompressionType_UNKNOWN
}

func (x *BackupRequest) GetCompressionLevel() int32 {
	if x != nil {
		return x.CompressionLevel
	}
	return 0
}

func (x *BackupRequest) GetCipherInfo() *CipherInfo {
	if x != nil {
		return x.CipherInfo
	}
	return nil
}

func (x *BackupRequest) GetDstApiVersion() kvrpcpb.APIVersion {
	if x != nil {
		return x.DstApiVersion
	}
	return kvrpcpb.APIVersion(0)
}

func (x *BackupRequest) GetSubRanges() []*kvrpcpb.KeyRange {
	if x != nil {
		return x.SubRanges
	}
	return nil
}

func (x *BackupRequest) GetSortedSubRangesGroups() []*SortedSubRanges {
	if x != nil {
		return x.SortedSubRangesGroups
	}
	return nil
}

func (x *BackupRequest) GetReplicaRead() bool {
	if x != nil {
		return x.ReplicaRead
	}
	return false
}

func (x *BackupRequest) GetMode() BackupMode {
	if x != nil {
		return x.Mode
	}
	return BackupMode_SCAN
}

func (x *BackupRequest) GetUniqueId() string {
	if x != nil {
		return x.UniqueId
	}
	return ""
}

func (x *BackupRequest) GetContext() *kvrpcpb.Context {
	if x != nil {
		return x.Context
	}
	return nil
}

type StreamBackupTaskInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The storage for backup, parsed by BR.
	Storage *StorageBackend `protobuf:"bytes,1,opt,name=storage,proto3" json:"storage,omitempty"`
	// The time range for backing up.
	StartTs uint64 `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	EndTs   uint64 `protobuf:"varint,3,opt,name=end_ts,json=endTs,proto3" json:"end_ts,omitempty"`
	// Misc meta data.
	// The name of the task, also the ID of the task.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// The table filter of the task.
	// Only for displaying the task info.
	TableFilter []string `protobuf:"bytes,5,rep,name=table_filter,json=tableFilter,proto3" json:"table_filter,omitempty"`
	// compression type
	CompressionType CompressionType `protobuf:"varint,6,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// security config for backup files
	SecurityConfig *StreamBackupTaskSecurityConfig `protobuf:"bytes,7,opt,name=security_config,json=securityConfig,proto3" json:"security_config,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StreamBackupTaskInfo) Reset() {
	*x = StreamBackupTaskInfo{}
	mi := &file_brpb_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamBackupTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamBackupTaskInfo) ProtoMessage() {}

func (x *StreamBackupTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamBackupTaskInfo.ProtoReflect.Descriptor instead.
func (*StreamBackupTaskInfo) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{23}
}

func (x *StreamBackupTaskInfo) GetStorage() *StorageBackend {
	if x != nil {
		return x.Storage
	}
	return nil
}

func (x *StreamBackupTaskInfo) GetStartTs() uint64 {
	if x != nil {
		return x.StartTs
	}
	return 0
}

func (x *StreamBackupTaskInfo) GetEndTs() uint64 {
	if x != nil {
		return x.EndTs
	}
	return 0
}

func (x *StreamBackupTaskInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StreamBackupTaskInfo) GetTableFilter() []string {
	if x != nil {
		return x.TableFilter
	}
	return nil
}

func (x *StreamBackupTaskInfo) GetCompressionType() CompressionType {
	if x != nil {
		return x.CompressionType
	}
	return CompressionType_UNKNOWN
}

func (x *StreamBackupTaskInfo) GetSecurityConfig() *StreamBackupTaskSecurityConfig {
	if x != nil {
		return x.SecurityConfig
	}
	return nil
}

type StorageBackend struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Backend:
	//
	//	*StorageBackend_Noop
	//	*StorageBackend_Local
	//	*StorageBackend_S3
	//	*StorageBackend_Gcs
	//	*StorageBackend_CloudDynamic
	//	*StorageBackend_Hdfs
	//	*StorageBackend_AzureBlobStorage
	Backend       isStorageBackend_Backend `protobuf_oneof:"backend"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageBackend) Reset() {
	*x = StorageBackend{}
	mi := &file_brpb_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageBackend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageBackend) ProtoMessage() {}

func (x *StorageBackend) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageBackend.ProtoReflect.Descriptor instead.
func (*StorageBackend) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{24}
}

func (x *StorageBackend) GetBackend() isStorageBackend_Backend {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *StorageBackend) GetNoop() *Noop {
	if x != nil {
		if x, ok := x.Backend.(*StorageBackend_Noop); ok {
			return x.Noop
		}
	}
	return nil
}

func (x *StorageBackend) GetLocal() *Local {
	if x != nil {
		if x, ok := x.Backend.(*StorageBackend_Local); ok {
			return x.Local
		}
	}
	return nil
}

func (x *StorageBackend) GetS3() *S3 {
	if x != nil {
		if x, ok := x.Backend.(*StorageBackend_S3); ok {
			return x.S3
		}
	}
	return nil
}

func (x *StorageBackend) GetGcs() *GCS {
	if x != nil {
		if x, ok := x.Backend.(*StorageBackend_Gcs); ok {
			return x.Gcs
		}
	}
	return nil
}

func (x *StorageBackend) GetCloudDynamic() *CloudDynamic {
	if x != nil {
		if x, ok := x.Backend.(*StorageBackend_CloudDynamic); ok {
			return x.CloudDynamic
		}
	}
	return nil
}

func (x *StorageBackend) GetHdfs() *HDFS {
	if x != nil {
		if x, ok := x.Backend.(*StorageBackend_Hdfs); ok {
			return x.Hdfs
		}
	}
	return nil
}

func (x *StorageBackend) GetAzureBlobStorage() *AzureBlobStorage {
	if x != nil {
		if x, ok := x.Backend.(*StorageBackend_AzureBlobStorage); ok {
			return x.AzureBlobStorage
		}
	}
	return nil
}

type isStorageBackend_Backend interface {
	isStorageBackend_Backend()
}

type StorageBackend_Noop struct {
	Noop *Noop `protobuf:"bytes,1,opt,name=noop,proto3,oneof"`
}

type StorageBackend_Local struct {
	Local *Local `protobuf:"bytes,2,opt,name=local,proto3,oneof"`
}

type StorageBackend_S3 struct {
	S3 *S3 `protobuf:"bytes,3,opt,name=s3,proto3,oneof"`
}

type StorageBackend_Gcs struct {
	Gcs *GCS `protobuf:"bytes,4,opt,name=gcs,proto3,oneof"`
}

type StorageBackend_CloudDynamic struct {
	CloudDynamic *CloudDynamic `protobuf:"bytes,5,opt,name=cloud_dynamic,json=cloudDynamic,proto3,oneof"`
}

type StorageBackend_Hdfs struct {
	Hdfs *HDFS `protobuf:"bytes,6,opt,name=hdfs,proto3,oneof"`
}

type StorageBackend_AzureBlobStorage struct {
	AzureBlobStorage *AzureBlobStorage `protobuf:"bytes,7,opt,name=azure_blob_storage,json=azureBlobStorage,proto3,oneof"`
}

func (*StorageBackend_Noop) isStorageBackend_Backend() {}

func (*StorageBackend_Local) isStorageBackend_Backend() {}

func (*StorageBackend_S3) isStorageBackend_Backend() {}

func (*StorageBackend_Gcs) isStorageBackend_Backend() {}

func (*StorageBackend_CloudDynamic) isStorageBackend_Backend() {}

func (*StorageBackend_Hdfs) isStorageBackend_Backend() {}

func (*StorageBackend_AzureBlobStorage) isStorageBackend_Backend() {}

// Noop storage backend saves files into void.
type Noop struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Noop) Reset() {
	*x = Noop{}
	mi := &file_brpb_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Noop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Noop) ProtoMessage() {}

func (x *Noop) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Noop.ProtoReflect.Descriptor instead.
func (*Noop) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{25}
}

// Local storage backend saves files into local disk
type Local struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Local) Reset() {
	*x = Local{}
	mi := &file_brpb_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Local) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Local) ProtoMessage() {}

func (x *Local) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Local.ProtoReflect.Descriptor instead.
func (*Local) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{26}
}

func (x *Local) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

// S3 storage backend saves files into S3 compatible storages
// For non-aws providers, endpoint must be provided
type S3 struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Endpoint     string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Region       string                 `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	Bucket       string                 `protobuf:"bytes,3,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix       string                 `protobuf:"bytes,4,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass string                 `protobuf:"bytes,5,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// server side encryption
	Sse               string `protobuf:"bytes,6,opt,name=sse,proto3" json:"sse,omitempty"`
	Acl               string `protobuf:"bytes,7,opt,name=acl,proto3" json:"acl,omitempty"`
	AccessKey         string `protobuf:"bytes,8,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretAccessKey   string `protobuf:"bytes,9,opt,name=secret_access_key,json=secretAccessKey,proto3" json:"secret_access_key,omitempty"`
	ForcePathStyle    bool   `protobuf:"varint,10,opt,name=force_path_style,json=forcePathStyle,proto3" json:"force_path_style,omitempty"`
	SseKmsKeyId       string `protobuf:"bytes,11,opt,name=sse_kms_key_id,json=sseKmsKeyId,proto3" json:"sse_kms_key_id,omitempty"`
	RoleArn           string `protobuf:"bytes,12,opt,name=role_arn,json=roleArn,proto3" json:"role_arn,omitempty"`
	ExternalId        string `protobuf:"bytes,13,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
	ObjectLockEnabled bool   `protobuf:"varint,14,opt,name=object_lock_enabled,json=objectLockEnabled,proto3" json:"object_lock_enabled,omitempty"`
	SessionToken      string `protobuf:"bytes,15,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	Provider          string `protobuf:"bytes,16,opt,name=provider,proto3" json:"provider,omitempty"`
	Profile           string `protobuf:"bytes,17,opt,name=profile,proto3" json:"profile,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *S3) Reset() {
	*x = S3{}
	mi := &file_brpb_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *S3) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*S3) ProtoMessage() {}

func (x *S3) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use S3.ProtoReflect.Descriptor instead.
func (*S3) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{27}
}

func (x *S3) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *S3) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *S3) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *S3) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *S3) GetStorageClass() string {
	if x != nil {
		return x.StorageClass
	}
	return ""
}

func (x *S3) GetSse() string {
	if x != nil {
		return x.Sse
	}
	return ""
}

func (x *S3) GetAcl() string {
	if x != nil {
		return x.Acl
	}
	return ""
}

func (x *S3) GetAccessKey() string {
	if x != nil {
		return x.AccessKey
	}
	return ""
}

func (x *S3) GetSecretAccessKey() string {
	if x != nil {
		return x.SecretAccessKey
	}
	return ""
}

func (x *S3) GetForcePathStyle() bool {
	if x != nil {
		return x.ForcePathStyle
	}
	return false
}

func (x *S3) GetSseKmsKeyId() string {
	if x != nil {
		return x.SseKmsKeyId
	}
	return ""
}

func (x *S3) GetRoleArn() string {
	if x != nil {
		return x.RoleArn
	}
	return ""
}

func (x *S3) GetExternalId() string {
	if x != nil {
		return x.ExternalId
	}
	return ""
}

func (x *S3) GetObjectLockEnabled() bool {
	if x != nil {
		return x.ObjectLockEnabled
	}
	return false
}

func (x *S3) GetSessionToken() string {
	if x != nil {
		return x.SessionToken
	}
	return ""
}

func (x *S3) GetProvider() string {
	if x != nil {
		return x.Provider
	}
	return ""
}

func (x *S3) GetProfile() string {
	if x != nil {
		return x.Profile
	}
	return ""
}

// GCS storage backend saves files into google cloud storage.
type GCS struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Endpoint     string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Bucket       string                 `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix       string                 `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass string                 `protobuf:"bytes,4,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// If not empty, applies a predefined set of access controls.
	// See https://cloud.google.com/storage/docs/access-control/lists#predefined-acl
	// for valid values.
	PredefinedAcl string `protobuf:"bytes,5,opt,name=predefined_acl,json=predefinedAcl,proto3" json:"predefined_acl,omitempty"`
	// Service Account Credentials JSON blob
	// You can get one from https://console.cloud.google.com/apis/credentials, and
	// copy the content, set it as string here.
	CredentialsBlob string `protobuf:"bytes,6,opt,name=credentials_blob,json=credentialsBlob,proto3" json:"credentials_blob,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GCS) Reset() {
	*x = GCS{}
	mi := &file_brpb_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GCS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GCS) ProtoMessage() {}

func (x *GCS) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GCS.ProtoReflect.Descriptor instead.
func (*GCS) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{28}
}

func (x *GCS) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *GCS) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *GCS) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *GCS) GetStorageClass() string {
	if x != nil {
		return x.StorageClass
	}
	return ""
}

func (x *GCS) GetPredefinedAcl() string {
	if x != nil {
		return x.PredefinedAcl
	}
	return ""
}

func (x *GCS) GetCredentialsBlob() string {
	if x != nil {
		return x.CredentialsBlob
	}
	return ""
}

// The encryption algorithm must be AES256.
type AzureCustomerKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A Base64-encoded AES-256 encryption key value.
	EncryptionKey string `protobuf:"bytes,1,opt,name=encryption_key,json=encryptionKey,proto3" json:"encryption_key,omitempty"`
	// The Base64-encoded SHA256 of the encryption key.
	EncryptionKeySha256 string `protobuf:"bytes,2,opt,name=encryption_key_sha256,json=encryptionKeySha256,proto3" json:"encryption_key_sha256,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *AzureCustomerKey) Reset() {
	*x = AzureCustomerKey{}
	mi := &file_brpb_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureCustomerKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureCustomerKey) ProtoMessage() {}

func (x *AzureCustomerKey) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureCustomerKey.ProtoReflect.Descriptor instead.
func (*AzureCustomerKey) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{29}
}

func (x *AzureCustomerKey) GetEncryptionKey() string {
	if x != nil {
		return x.EncryptionKey
	}
	return ""
}

func (x *AzureCustomerKey) GetEncryptionKeySha256() string {
	if x != nil {
		return x.EncryptionKeySha256
	}
	return ""
}

// AzureBlobStorage storage backend saves files into azure blob storage.
type AzureBlobStorage struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Alias: container
	Bucket string `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// Notice: prefix starts without `/`, otherwise the first directory's name is empty.
	Prefix string `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Alias: access_tier.
	// See https://docs.microsoft.com/en-us/azure/storage/blobs/access-tiers-overview
	StorageClass string `protobuf:"bytes,4,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// if empty, try to read account_name from the node's environment variable $AZURE_STORAGE_ACCOUNT.
	AccountName string `protobuf:"bytes,5,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	// There are 3 kinds of credentials, and the priority order is
	//
	//	`SAS > Shared key > Azure AD (env) > Shared key (env)`.
	//
	// 1. Use shared key to access the azure blob
	// If the node's environment variables($AZURE_CLIENT_ID, $AZURE_TENANT_ID, $AZURE_CLIENT_SECRET) exist,
	// prefer to use token to access the azure blob.
	//
	//	See https://learn.microsoft.com/en-us/rest/api/storageservices/authorize-with-shared-key
	//
	// Otherwise, if empty, try to read shared key from the node's environment variable $AZURE_STORAGE_KEY.
	SharedKey string `protobuf:"bytes,6,opt,name=shared_key,json=sharedKey,proto3" json:"shared_key,omitempty"`
	// 2. Use Azure AD (Azure Active Directory) to access the azure blob
	//
	//	See https://learn.microsoft.com/en-us/rest/api/storageservices/authorize-with-azure-active-directory
	//
	// The Azure AD would generate the token, which tasks some time.
	// So it is not recommanded to generate the token in each request.
	// // AzureActiveDirectory azure_ad = #;
	//
	// 3. Use SAS (shared access signature)
	//
	//	See https://learn.microsoft.com/en-us/rest/api/storageservices/delegate-access-with-shared-access-signature
	AccessSig string `protobuf:"bytes,8,opt,name=access_sig,json=accessSig,proto3" json:"access_sig,omitempty"`
	// Server Side Encryption, 2 types in total:
	//
	// 1. Specify an encryption scope for uploaded blobs.
	//
	//	See https://learn.microsoft.com/en-us/azure/storage/blobs/encryption-scope-manage?tabs=powershell#upload-a-blob-with-an-encryption-scope
	EncryptionScope string `protobuf:"bytes,9,opt,name=encryption_scope,json=encryptionScope,proto3" json:"encryption_scope,omitempty"`
	// 2. Provide an encryption key on a request to blob storage.
	//
	//	See https://learn.microsoft.com/en-us/azure/storage/blobs/encryption-customer-provided-keys
	EncryptionKey *AzureCustomerKey `protobuf:"bytes,10,opt,name=encryption_key,json=encryptionKey,proto3" json:"encryption_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AzureBlobStorage) Reset() {
	*x = AzureBlobStorage{}
	mi := &file_brpb_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureBlobStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureBlobStorage) ProtoMessage() {}

func (x *AzureBlobStorage) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureBlobStorage.ProtoReflect.Descriptor instead.
func (*AzureBlobStorage) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{30}
}

func (x *AzureBlobStorage) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *AzureBlobStorage) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *AzureBlobStorage) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *AzureBlobStorage) GetStorageClass() string {
	if x != nil {
		return x.StorageClass
	}
	return ""
}

func (x *AzureBlobStorage) GetAccountName() string {
	if x != nil {
		return x.AccountName
	}
	return ""
}

func (x *AzureBlobStorage) GetSharedKey() string {
	if x != nil {
		return x.SharedKey
	}
	return ""
}

func (x *AzureBlobStorage) GetAccessSig() string {
	if x != nil {
		return x.AccessSig
	}
	return ""
}

func (x *AzureBlobStorage) GetEncryptionScope() string {
	if x != nil {
		return x.EncryptionScope
	}
	return ""
}

func (x *AzureBlobStorage) GetEncryptionKey() *AzureCustomerKey {
	if x != nil {
		return x.EncryptionKey
	}
	return nil
}

type Bucket struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Endpoint      string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Region        string                 `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
	Bucket        string                 `protobuf:"bytes,4,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix        string                 `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass  string                 `protobuf:"bytes,6,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Bucket) Reset() {
	*x = Bucket{}
	mi := &file_brpb_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Bucket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Bucket) ProtoMessage() {}

func (x *Bucket) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Bucket.ProtoReflect.Descriptor instead.
func (*Bucket) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{31}
}

func (x *Bucket) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Bucket) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *Bucket) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *Bucket) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *Bucket) GetStorageClass() string {
	if x != nil {
		return x.StorageClass
	}
	return ""
}

// CloudDynamic allows testing new cloud providers and new fields without changing protobuf definitions
type CloudDynamic struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Bucket        *Bucket                `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	ProviderName  string                 `protobuf:"bytes,2,opt,name=provider_name,json=providerName,proto3" json:"provider_name,omitempty"` // s3, gcs and azureBlobStorage are supported
	Attrs         map[string]string      `protobuf:"bytes,3,rep,name=attrs,proto3" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloudDynamic) Reset() {
	*x = CloudDynamic{}
	mi := &file_brpb_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloudDynamic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloudDynamic) ProtoMessage() {}

func (x *CloudDynamic) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloudDynamic.ProtoReflect.Descriptor instead.
func (*CloudDynamic) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{32}
}

func (x *CloudDynamic) GetBucket() *Bucket {
	if x != nil {
		return x.Bucket
	}
	return nil
}

func (x *CloudDynamic) GetProviderName() string {
	if x != nil {
		return x.ProviderName
	}
	return ""
}

func (x *CloudDynamic) GetAttrs() map[string]string {
	if x != nil {
		return x.Attrs
	}
	return nil
}

// HDFS storage backend saves file into HDFS compatible storages
type HDFS struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// a URL: hdfs:///some/path or hdfs://host:port/some/path
	Remote        string `protobuf:"bytes,1,opt,name=remote,proto3" json:"remote,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HDFS) Reset() {
	*x = HDFS{}
	mi := &file_brpb_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HDFS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HDFS) ProtoMessage() {}

func (x *HDFS) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HDFS.ProtoReflect.Descriptor instead.
func (*HDFS) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{33}
}

func (x *HDFS) GetRemote() string {
	if x != nil {
		return x.Remote
	}
	return ""
}

type BackupResponse struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Error    *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	StartKey []byte                 `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte                 `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Files    []*File                `protobuf:"bytes,4,rep,name=files,proto3" json:"files,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion    kvrpcpb.APIVersion `protobuf:"varint,5,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackupResponse) Reset() {
	*x = BackupResponse{}
	mi := &file_brpb_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupResponse) ProtoMessage() {}

func (x *BackupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupResponse.ProtoReflect.Descriptor instead.
func (*BackupResponse) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{34}
}

func (x *BackupResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *BackupResponse) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *BackupResponse) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *BackupResponse) GetFiles() []*File {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *BackupResponse) GetApiVersion() kvrpcpb.APIVersion {
	if x != nil {
		return x.ApiVersion
	}
	return kvrpcpb.APIVersion(0)
}

type CleanupRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// unique_id represents the unique handle of the whole backup predecure.
	// it generated in prepare request and corrosponed to one specific backup.
	UniqueId      string `protobuf:"bytes,1,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupRequest) Reset() {
	*x = CleanupRequest{}
	mi := &file_brpb_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupRequest) ProtoMessage() {}

func (x *CleanupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupRequest.ProtoReflect.Descriptor instead.
func (*CleanupRequest) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{35}
}

func (x *CleanupRequest) GetUniqueId() string {
	if x != nil {
		return x.UniqueId
	}
	return ""
}

type CleanupResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupResponse) Reset() {
	*x = CleanupResponse{}
	mi := &file_brpb_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupResponse) ProtoMessage() {}

func (x *CleanupResponse) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupResponse.ProtoReflect.Descriptor instead.
func (*CleanupResponse) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{36}
}

func (x *CleanupResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CleanupResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

type PrepareRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// whether save state to the storage.
	SaveToStorage bool `protobuf:"varint,1,opt,name=save_to_storage,json=saveToStorage,proto3" json:"save_to_storage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrepareRequest) Reset() {
	*x = PrepareRequest{}
	mi := &file_brpb_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareRequest) ProtoMessage() {}

func (x *PrepareRequest) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareRequest.ProtoReflect.Descriptor instead.
func (*PrepareRequest) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{37}
}

func (x *PrepareRequest) GetSaveToStorage() bool {
	if x != nil {
		return x.SaveToStorage
	}
	return false
}

type PrepareResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Error *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// unique_id represents the unique handle of the whole backup predecure.
	// if unique_id = 0 means prepare failed.
	// if unique_id > 0 means prepare success and all states saved with this unique info.
	UniqueId         string `protobuf:"bytes,2,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	CollectFileCount uint64 `protobuf:"varint,3,opt,name=collect_file_count,json=collectFileCount,proto3" json:"collect_file_count,omitempty"`
	CollectFileSize  uint64 `protobuf:"varint,4,opt,name=collect_file_size,json=collectFileSize,proto3" json:"collect_file_size,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PrepareResponse) Reset() {
	*x = PrepareResponse{}
	mi := &file_brpb_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareResponse) ProtoMessage() {}

func (x *PrepareResponse) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareResponse.ProtoReflect.Descriptor instead.
func (*PrepareResponse) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{38}
}

func (x *PrepareResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *PrepareResponse) GetUniqueId() string {
	if x != nil {
		return x.UniqueId
	}
	return ""
}

func (x *PrepareResponse) GetCollectFileCount() uint64 {
	if x != nil {
		return x.CollectFileCount
	}
	return 0
}

func (x *PrepareResponse) GetCollectFileSize() uint64 {
	if x != nil {
		return x.CollectFileSize
	}
	return 0
}

type CheckAdminRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckAdminRequest) Reset() {
	*x = CheckAdminRequest{}
	mi := &file_brpb_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckAdminRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckAdminRequest) ProtoMessage() {}

func (x *CheckAdminRequest) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckAdminRequest.ProtoReflect.Descriptor instead.
func (*CheckAdminRequest) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{39}
}

type CheckAdminResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Error           *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Region          *metapb.Region         `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	HasPendingAdmin bool                   `protobuf:"varint,3,opt,name=has_pending_admin,json=hasPendingAdmin,proto3" json:"has_pending_admin,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CheckAdminResponse) Reset() {
	*x = CheckAdminResponse{}
	mi := &file_brpb_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckAdminResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckAdminResponse) ProtoMessage() {}

func (x *CheckAdminResponse) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckAdminResponse.ProtoReflect.Descriptor instead.
func (*CheckAdminResponse) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{40}
}

func (x *CheckAdminResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CheckAdminResponse) GetRegion() *metapb.Region {
	if x != nil {
		return x.Region
	}
	return nil
}

func (x *CheckAdminResponse) GetHasPendingAdmin() bool {
	if x != nil {
		return x.HasPendingAdmin
	}
	return false
}

type ExternalStorageRestoreRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	StorageBackend *StorageBackend        `protobuf:"bytes,1,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	ObjectName     string                 `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	RestoreName    string                 `protobuf:"bytes,3,opt,name=restore_name,json=restoreName,proto3" json:"restore_name,omitempty"`
	ContentLength  uint64                 `protobuf:"varint,4,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExternalStorageRestoreRequest) Reset() {
	*x = ExternalStorageRestoreRequest{}
	mi := &file_brpb_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExternalStorageRestoreRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExternalStorageRestoreRequest) ProtoMessage() {}

func (x *ExternalStorageRestoreRequest) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExternalStorageRestoreRequest.ProtoReflect.Descriptor instead.
func (*ExternalStorageRestoreRequest) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{41}
}

func (x *ExternalStorageRestoreRequest) GetStorageBackend() *StorageBackend {
	if x != nil {
		return x.StorageBackend
	}
	return nil
}

func (x *ExternalStorageRestoreRequest) GetObjectName() string {
	if x != nil {
		return x.ObjectName
	}
	return ""
}

func (x *ExternalStorageRestoreRequest) GetRestoreName() string {
	if x != nil {
		return x.RestoreName
	}
	return ""
}

func (x *ExternalStorageRestoreRequest) GetContentLength() uint64 {
	if x != nil {
		return x.ContentLength
	}
	return 0
}

type ExternalStorageRestoreResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExternalStorageRestoreResponse) Reset() {
	*x = ExternalStorageRestoreResponse{}
	mi := &file_brpb_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExternalStorageRestoreResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExternalStorageRestoreResponse) ProtoMessage() {}

func (x *ExternalStorageRestoreResponse) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExternalStorageRestoreResponse.ProtoReflect.Descriptor instead.
func (*ExternalStorageRestoreResponse) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{42}
}

type ExternalStorageSaveRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	StorageBackend *StorageBackend        `protobuf:"bytes,1,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	ObjectName     string                 `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	ContentLength  uint64                 `protobuf:"varint,3,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExternalStorageSaveRequest) Reset() {
	*x = ExternalStorageSaveRequest{}
	mi := &file_brpb_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExternalStorageSaveRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExternalStorageSaveRequest) ProtoMessage() {}

func (x *ExternalStorageSaveRequest) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExternalStorageSaveRequest.ProtoReflect.Descriptor instead.
func (*ExternalStorageSaveRequest) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{43}
}

func (x *ExternalStorageSaveRequest) GetStorageBackend() *StorageBackend {
	if x != nil {
		return x.StorageBackend
	}
	return nil
}

func (x *ExternalStorageSaveRequest) GetObjectName() string {
	if x != nil {
		return x.ObjectName
	}
	return ""
}

func (x *ExternalStorageSaveRequest) GetContentLength() uint64 {
	if x != nil {
		return x.ContentLength
	}
	return 0
}

type ExternalStorageSaveResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExternalStorageSaveResponse) Reset() {
	*x = ExternalStorageSaveResponse{}
	mi := &file_brpb_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExternalStorageSaveResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExternalStorageSaveResponse) ProtoMessage() {}

func (x *ExternalStorageSaveResponse) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExternalStorageSaveResponse.ProtoReflect.Descriptor instead.
func (*ExternalStorageSaveResponse) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{44}
}

type Metadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// deprecated after(in) v6.3.0 TiKV cluster
	Files         []*DataFileInfo  `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
	FileGroups    []*DataFileGroup `protobuf:"bytes,6,rep,name=file_groups,json=fileGroups,proto3" json:"file_groups,omitempty"`
	StoreId       int64            `protobuf:"varint,2,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	ResolvedTs    uint64           `protobuf:"varint,3,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts,omitempty"`
	MaxTs         uint64           `protobuf:"varint,4,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	MinTs         uint64           `protobuf:"varint,5,opt,name=min_ts,json=minTs,proto3" json:"min_ts,omitempty"`
	MetaVersion   MetaVersion      `protobuf:"varint,7,opt,name=meta_version,json=metaVersion,proto3,enum=backup.MetaVersion" json:"meta_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Metadata) Reset() {
	*x = Metadata{}
	mi := &file_brpb_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Metadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata) ProtoMessage() {}

func (x *Metadata) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata.ProtoReflect.Descriptor instead.
func (*Metadata) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{45}
}

func (x *Metadata) GetFiles() []*DataFileInfo {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *Metadata) GetFileGroups() []*DataFileGroup {
	if x != nil {
		return x.FileGroups
	}
	return nil
}

func (x *Metadata) GetStoreId() int64 {
	if x != nil {
		return x.StoreId
	}
	return 0
}

func (x *Metadata) GetResolvedTs() uint64 {
	if x != nil {
		return x.ResolvedTs
	}
	return 0
}

func (x *Metadata) GetMaxTs() uint64 {
	if x != nil {
		return x.MaxTs
	}
	return 0
}

func (x *Metadata) GetMinTs() uint64 {
	if x != nil {
		return x.MinTs
	}
	return 0
}

func (x *Metadata) GetMetaVersion() MetaVersion {
	if x != nil {
		return x.MetaVersion
	}
	return MetaVersion_V1
}

// DataFileGroup is the merged file info in log-backup
type DataFileGroup struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Path of the file.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Partitions of the file.
	DataFilesInfo []*DataFileInfo `protobuf:"bytes,2,rep,name=data_files_info,json=dataFilesInfo,proto3" json:"data_files_info,omitempty"`
	// / Below are extra information of the file, for better filtering files.
	// The min ts of the keys in the file.
	MinTs uint64 `protobuf:"varint,3,opt,name=min_ts,json=minTs,proto3" json:"min_ts,omitempty"`
	// The max ts of the keys in the file.
	MaxTs uint64 `protobuf:"varint,4,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	// The resolved ts of the region when saving the file.
	MinResolvedTs uint64 `protobuf:"varint,5,opt,name=min_resolved_ts,json=minResolvedTs,proto3" json:"min_resolved_ts,omitempty"`
	// The file length after compressed.
	Length        uint64 `protobuf:"varint,6,opt,name=length,proto3" json:"length,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataFileGroup) Reset() {
	*x = DataFileGroup{}
	mi := &file_brpb_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataFileGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataFileGroup) ProtoMessage() {}

func (x *DataFileGroup) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataFileGroup.ProtoReflect.Descriptor instead.
func (*DataFileGroup) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{46}
}

func (x *DataFileGroup) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *DataFileGroup) GetDataFilesInfo() []*DataFileInfo {
	if x != nil {
		return x.DataFilesInfo
	}
	return nil
}

func (x *DataFileGroup) GetMinTs() uint64 {
	if x != nil {
		return x.MinTs
	}
	return 0
}

func (x *DataFileGroup) GetMaxTs() uint64 {
	if x != nil {
		return x.MaxTs
	}
	return 0
}

func (x *DataFileGroup) GetMinResolvedTs() uint64 {
	if x != nil {
		return x.MinResolvedTs
	}
	return 0
}

func (x *DataFileGroup) GetLength() uint64 {
	if x != nil {
		return x.Length
	}
	return 0
}

type DataFileInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Checksum of the plaintext file, i.e., pre-compression, pre-encryption.
	Sha256 []byte `protobuf:"bytes,1,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// Path of the file.
	Path            string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	NumberOfEntries int64  `protobuf:"varint,3,opt,name=number_of_entries,json=numberOfEntries,proto3" json:"number_of_entries,omitempty"`
	// / Below are extra information of the file, for better filtering files.
	// The min ts of the keys in the file.
	MinTs uint64 `protobuf:"varint,4,opt,name=min_ts,json=minTs,proto3" json:"min_ts,omitempty"`
	// The max ts of the keys in the file.
	MaxTs uint64 `protobuf:"varint,5,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	// The resolved ts of the region when saving the file.
	ResolvedTs uint64 `protobuf:"varint,6,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts,omitempty"`
	// The region of the file.
	RegionId int64 `protobuf:"varint,7,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// The key range of the file.
	// Encoded and starts with 'z'(internal key).
	StartKey []byte `protobuf:"bytes,8,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,9,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The column family of the file.
	Cf string `protobuf:"bytes,10,opt,name=cf,proto3" json:"cf,omitempty"`
	// The operation type of the file.
	Type FileType `protobuf:"varint,11,opt,name=type,proto3,enum=backup.FileType" json:"type,omitempty"`
	// Whether the data file contains meta keys(m prefixed keys) only.
	IsMeta bool `protobuf:"varint,12,opt,name=is_meta,json=isMeta,proto3" json:"is_meta,omitempty"`
	// The table ID of the file contains, when `is_meta` is true, would be ignored.
	TableId int64 `protobuf:"varint,13,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// The file length.
	Length uint64 `protobuf:"varint,14,opt,name=length,proto3" json:"length,omitempty"`
	// The minimal begin ts in default cf if this file is write cf.
	MinBeginTsInDefaultCf uint64 `protobuf:"varint,15,opt,name=min_begin_ts_in_default_cf,json=minBeginTsInDefaultCf,proto3" json:"min_begin_ts_in_default_cf,omitempty"`
	// Offset of the partition. compatible with V1 and V2.
	RangeOffset uint64 `protobuf:"varint,16,opt,name=range_offset,json=rangeOffset,proto3" json:"range_offset,omitempty"`
	// The range length of the merged file, if it exists.
	RangeLength uint64 `protobuf:"varint,17,opt,name=range_length,json=rangeLength,proto3" json:"range_length,omitempty"`
	// The compression type for the file.
	CompressionType CompressionType `protobuf:"varint,18,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// The CRC64XOR of all contents of the file.
	// In older versions, this might be empty.
	Crc64Xor uint64 `protobuf:"varint,19,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	// The original region range the log file belongs to.
	// In older versions, this might be empty.
	// This may not be accurative: file may contain keys less than this.
	RegionStartKey []byte `protobuf:"bytes,20,opt,name=region_start_key,json=regionStartKey,proto3" json:"region_start_key,omitempty"`
	// The original region range the log file belongs to.
	// In older versions, this might be empty.
	// This may not be accurative: file may contain keys greater than this.
	RegionEndKey []byte `protobuf:"bytes,21,opt,name=region_end_key,json=regionEndKey,proto3" json:"region_end_key,omitempty"`
	// The region epoch that the log file belongs to.
	// In older versions, this might be empty.
	// If a region get split or merged during observing, the file may contain multi epoches.
	// This may not be complete: file may contain records from other versions.
	//
	// If there is exactly one epoch,
	// `region_start_key` and `region_end_key` must match this epoch.
	RegionEpoch []*metapb.RegionEpoch `protobuf:"bytes,22,rep,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	// Encryption information of this data file, not set if plaintext.
	FileEncryptionInfo *encryptionpb.FileEncryptionInfo `protobuf:"bytes,23,opt,name=file_encryption_info,json=fileEncryptionInfo,proto3" json:"file_encryption_info,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *DataFileInfo) Reset() {
	*x = DataFileInfo{}
	mi := &file_brpb_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataFileInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataFileInfo) ProtoMessage() {}

func (x *DataFileInfo) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataFileInfo.ProtoReflect.Descriptor instead.
func (*DataFileInfo) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{47}
}

func (x *DataFileInfo) GetSha256() []byte {
	if x != nil {
		return x.Sha256
	}
	return nil
}

func (x *DataFileInfo) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *DataFileInfo) GetNumberOfEntries() int64 {
	if x != nil {
		return x.NumberOfEntries
	}
	return 0
}

func (x *DataFileInfo) GetMinTs() uint64 {
	if x != nil {
		return x.MinTs
	}
	return 0
}

func (x *DataFileInfo) GetMaxTs() uint64 {
	if x != nil {
		return x.MaxTs
	}
	return 0
}

func (x *DataFileInfo) GetResolvedTs() uint64 {
	if x != nil {
		return x.ResolvedTs
	}
	return 0
}

func (x *DataFileInfo) GetRegionId() int64 {
	if x != nil {
		return x.RegionId
	}
	return 0
}

func (x *DataFileInfo) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *DataFileInfo) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *DataFileInfo) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *DataFileInfo) GetType() FileType {
	if x != nil {
		return x.Type
	}
	return FileType_Delete
}

func (x *DataFileInfo) GetIsMeta() bool {
	if x != nil {
		return x.IsMeta
	}
	return false
}

func (x *DataFileInfo) GetTableId() int64 {
	if x != nil {
		return x.TableId
	}
	return 0
}

func (x *DataFileInfo) GetLength() uint64 {
	if x != nil {
		return x.Length
	}
	return 0
}

func (x *DataFileInfo) GetMinBeginTsInDefaultCf() uint64 {
	if x != nil {
		return x.MinBeginTsInDefaultCf
	}
	return 0
}

func (x *DataFileInfo) GetRangeOffset() uint64 {
	if x != nil {
		return x.RangeOffset
	}
	return 0
}

func (x *DataFileInfo) GetRangeLength() uint64 {
	if x != nil {
		return x.RangeLength
	}
	return 0
}

func (x *DataFileInfo) GetCompressionType() CompressionType {
	if x != nil {
		return x.CompressionType
	}
	return CompressionType_UNKNOWN
}

func (x *DataFileInfo) GetCrc64Xor() uint64 {
	if x != nil {
		return x.Crc64Xor
	}
	return 0
}

func (x *DataFileInfo) GetRegionStartKey() []byte {
	if x != nil {
		return x.RegionStartKey
	}
	return nil
}

func (x *DataFileInfo) GetRegionEndKey() []byte {
	if x != nil {
		return x.RegionEndKey
	}
	return nil
}

func (x *DataFileInfo) GetRegionEpoch() []*metapb.RegionEpoch {
	if x != nil {
		return x.RegionEpoch
	}
	return nil
}

func (x *DataFileInfo) GetFileEncryptionInfo() *encryptionpb.FileEncryptionInfo {
	if x != nil {
		return x.FileEncryptionInfo
	}
	return nil
}

type StreamBackupError struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the unix epoch time (in millisecs) of the time the error reported.
	HappenAt uint64 `protobuf:"varint,1,opt,name=happen_at,json=happenAt,proto3" json:"happen_at,omitempty"`
	// the unified error code of the error.
	ErrorCode string `protobuf:"bytes,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// the user-friendly error message.
	ErrorMessage string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// the store id of who issues the error.
	StoreId       uint64 `protobuf:"varint,4,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamBackupError) Reset() {
	*x = StreamBackupError{}
	mi := &file_brpb_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamBackupError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamBackupError) ProtoMessage() {}

func (x *StreamBackupError) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamBackupError.ProtoReflect.Descriptor instead.
func (*StreamBackupError) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{48}
}

func (x *StreamBackupError) GetHappenAt() uint64 {
	if x != nil {
		return x.HappenAt
	}
	return 0
}

func (x *StreamBackupError) GetErrorCode() string {
	if x != nil {
		return x.ErrorCode
	}
	return ""
}

func (x *StreamBackupError) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *StreamBackupError) GetStoreId() uint64 {
	if x != nil {
		return x.StoreId
	}
	return 0
}

type Span struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Offset        uint64                 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Length        uint64                 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Span) Reset() {
	*x = Span{}
	mi := &file_brpb_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Span) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Span) ProtoMessage() {}

func (x *Span) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Span.ProtoReflect.Descriptor instead.
func (*Span) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{49}
}

func (x *Span) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *Span) GetLength() uint64 {
	if x != nil {
		return x.Length
	}
	return 0
}

type SpansOfFile struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Spans         []*Span                `protobuf:"bytes,2,rep,name=spans,proto3" json:"spans,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpansOfFile) Reset() {
	*x = SpansOfFile{}
	mi := &file_brpb_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpansOfFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpansOfFile) ProtoMessage() {}

func (x *SpansOfFile) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpansOfFile.ProtoReflect.Descriptor instead.
func (*SpansOfFile) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{50}
}

func (x *SpansOfFile) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *SpansOfFile) GetSpans() []*Span {
	if x != nil {
		return x.Spans
	}
	return nil
}

type LogFileSubcompactionMeta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The whole size of this subcompaction.
	// It should be the physical size of all input logs.
	Size uint64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// The region that we perform the subcompaction.
	RegionId   uint64 `protobuf:"varint,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	Cf         string `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	InputMaxTs uint64 `protobuf:"varint,4,opt,name=input_max_ts,json=inputMaxTs,proto3" json:"input_max_ts,omitempty"`
	InputMinTs uint64 `protobuf:"varint,5,opt,name=input_min_ts,json=inputMinTs,proto3" json:"input_min_ts,omitempty"`
	// The whole compaction's configure.
	CompactFromTs  uint64 `protobuf:"varint,6,opt,name=compact_from_ts,json=compactFromTs,proto3" json:"compact_from_ts,omitempty"`
	CompactUntilTs uint64 `protobuf:"varint,7,opt,name=compact_until_ts,json=compactUntilTs,proto3" json:"compact_until_ts,omitempty"`
	// The key range of the input logs.
	// They are encoded user key. (i.e. mem-comparable, no 'z' prefix)
	MinKey []byte `protobuf:"bytes,8,opt,name=min_key,json=minKey,proto3" json:"min_key,omitempty"`
	// The largest key from the input.
	MaxKey []byte `protobuf:"bytes,9,opt,name=max_key,json=maxKey,proto3" json:"max_key,omitempty"`
	// The type of operations in the file. (Write or Delete)
	Ty      FileType `protobuf:"varint,10,opt,name=ty,proto3,enum=backup.FileType" json:"ty,omitempty"`
	TableId int64    `protobuf:"varint,11,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// The input log files of this.
	Sources       []*SpansOfFile `protobuf:"bytes,12,rep,name=sources,proto3" json:"sources,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogFileSubcompactionMeta) Reset() {
	*x = LogFileSubcompactionMeta{}
	mi := &file_brpb_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogFileSubcompactionMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogFileSubcompactionMeta) ProtoMessage() {}

func (x *LogFileSubcompactionMeta) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogFileSubcompactionMeta.ProtoReflect.Descriptor instead.
func (*LogFileSubcompactionMeta) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{51}
}

func (x *LogFileSubcompactionMeta) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *LogFileSubcompactionMeta) GetRegionId() uint64 {
	if x != nil {
		return x.RegionId
	}
	return 0
}

func (x *LogFileSubcompactionMeta) GetCf() string {
	if x != nil {
		return x.Cf
	}
	return ""
}

func (x *LogFileSubcompactionMeta) GetInputMaxTs() uint64 {
	if x != nil {
		return x.InputMaxTs
	}
	return 0
}

func (x *LogFileSubcompactionMeta) GetInputMinTs() uint64 {
	if x != nil {
		return x.InputMinTs
	}
	return 0
}

func (x *LogFileSubcompactionMeta) GetCompactFromTs() uint64 {
	if x != nil {
		return x.CompactFromTs
	}
	return 0
}

func (x *LogFileSubcompactionMeta) GetCompactUntilTs() uint64 {
	if x != nil {
		return x.CompactUntilTs
	}
	return 0
}

func (x *LogFileSubcompactionMeta) GetMinKey() []byte {
	if x != nil {
		return x.MinKey
	}
	return nil
}

func (x *LogFileSubcompactionMeta) GetMaxKey() []byte {
	if x != nil {
		return x.MaxKey
	}
	return nil
}

func (x *LogFileSubcompactionMeta) GetTy() FileType {
	if x != nil {
		return x.Ty
	}
	return FileType_Delete
}

func (x *LogFileSubcompactionMeta) GetTableId() int64 {
	if x != nil {
		return x.TableId
	}
	return 0
}

func (x *LogFileSubcompactionMeta) GetSources() []*SpansOfFile {
	if x != nil {
		return x.Sources
	}
	return nil
}

// A subcompaction from a compaction.
// Subcompactions are actions that collect then sort key values from one region.
type LogFileSubcompaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The metadata of the subcompaction.
	Meta *LogFileSubcompactionMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// The generated SSTs.
	SstOutputs []*File `protobuf:"bytes,2,rep,name=sst_outputs,json=sstOutputs,proto3" json:"sst_outputs,omitempty"`
	// The hint for the history of the region that contains the keys being compacted.
	// This may be helpful for splitting, but it does not guarantee completeness and accuracy.
	RegionMetaHints []*RegionMetaHint `protobuf:"bytes,3,rep,name=region_meta_hints,json=regionMetaHints,proto3" json:"region_meta_hints,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *LogFileSubcompaction) Reset() {
	*x = LogFileSubcompaction{}
	mi := &file_brpb_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogFileSubcompaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogFileSubcompaction) ProtoMessage() {}

func (x *LogFileSubcompaction) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogFileSubcompaction.ProtoReflect.Descriptor instead.
func (*LogFileSubcompaction) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{52}
}

func (x *LogFileSubcompaction) GetMeta() *LogFileSubcompactionMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

func (x *LogFileSubcompaction) GetSstOutputs() []*File {
	if x != nil {
		return x.SstOutputs
	}
	return nil
}

func (x *LogFileSubcompaction) GetRegionMetaHints() []*RegionMetaHint {
	if x != nil {
		return x.RegionMetaHints
	}
	return nil
}

type RegionMetaHint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The left boundary of the region of this epoch.
	// It is an byte-comparable encoded key without TS.
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// The right boundary of the region of the epoch.
	EndKey []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The region epoch.
	RegionEpoch   *metapb.RegionEpoch `protobuf:"bytes,3,opt,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegionMetaHint) Reset() {
	*x = RegionMetaHint{}
	mi := &file_brpb_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegionMetaHint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegionMetaHint) ProtoMessage() {}

func (x *RegionMetaHint) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegionMetaHint.ProtoReflect.Descriptor instead.
func (*RegionMetaHint) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{53}
}

func (x *RegionMetaHint) GetStartKey() []byte {
	if x != nil {
		return x.StartKey
	}
	return nil
}

func (x *RegionMetaHint) GetEndKey() []byte {
	if x != nil {
		return x.EndKey
	}
	return nil
}

func (x *RegionMetaHint) GetRegionEpoch() *metapb.RegionEpoch {
	if x != nil {
		return x.RegionEpoch
	}
	return nil
}

// Batched version of `LogFileSubcompaction`.
// So we can store many subcompactions to one file, to reduce the number of file.
type LogFileSubcompactions struct {
	state          protoimpl.MessageState  `protogen:"open.v1"`
	Subcompactions []*LogFileSubcompaction `protobuf:"bytes,1,rep,name=subcompactions,proto3" json:"subcompactions,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *LogFileSubcompactions) Reset() {
	*x = LogFileSubcompactions{}
	mi := &file_brpb_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogFileSubcompactions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogFileSubcompactions) ProtoMessage() {}

func (x *LogFileSubcompactions) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogFileSubcompactions.ProtoReflect.Descriptor instead.
func (*LogFileSubcompactions) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{54}
}

func (x *LogFileSubcompactions) GetSubcompactions() []*LogFileSubcompaction {
	if x != nil {
		return x.Subcompactions
	}
	return nil
}

type LogFileCompaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The selector of compaction source.
	// Files contains ANY record greater than this (and less than `until_ts`) will be selected.
	// The source and artificats may contain records out of the `from_ts` and `until_ts` range.
	// When restoring, please use `input_min_ts` to filter out not needed compactions instead.
	CompactionFromTs uint64 `protobuf:"varint,1,opt,name=compaction_from_ts,json=compactionFromTs,proto3" json:"compaction_from_ts,omitempty"`
	// The selector of compaction source.
	// Files contains ANY record less than this (and not less than `from_ts`) will be selected.
	// The source and artificats may contain records out of the `from_ts` and `until_ts` range.
	// When restoring, please use `input_max_ts` to filter out not needed compactions instead.
	CompactionUntilTs uint64 `protobuf:"varint,2,opt,name=compaction_until_ts,json=compactionUntilTs,proto3" json:"compaction_until_ts,omitempty"`
	// The user provided name for the compaction.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The statistics or other useful information for human.
	Comments string `protobuf:"bytes,4,opt,name=comments,proto3" json:"comments,omitempty"`
	// relative path to the generated subcompaction metas. ("artificates")
	Artifacts string `protobuf:"bytes,5,opt,name=artifacts,proto3" json:"artifacts,omitempty"`
	// the XOR of all artificate's hash.
	ArtifactsHash uint64 `protobuf:"varint,6,opt,name=artifacts_hash,json=artifactsHash,proto3" json:"artifacts_hash,omitempty"`
	// relative path to the subcompaction generated SST files.
	// this is a hint for garbage-collecting, so we don't need to read the metas one by one.
	// Those SSTs cannot be directly used, what you need is probably in `artificates`.
	GeneratedFiles string `protobuf:"bytes,7,opt,name=generated_files,json=generatedFiles,proto3" json:"generated_files,omitempty"`
	// The smallest TS of record contained among all selected files of this compaction.
	InputMinTs uint64 `protobuf:"varint,8,opt,name=input_min_ts,json=inputMinTs,proto3" json:"input_min_ts,omitempty"`
	// The largest TS of record contained among all selected files of this compaction.
	InputMaxTs    uint64 `protobuf:"varint,9,opt,name=input_max_ts,json=inputMaxTs,proto3" json:"input_max_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogFileCompaction) Reset() {
	*x = LogFileCompaction{}
	mi := &file_brpb_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogFileCompaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogFileCompaction) ProtoMessage() {}

func (x *LogFileCompaction) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogFileCompaction.ProtoReflect.Descriptor instead.
func (*LogFileCompaction) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{55}
}

func (x *LogFileCompaction) GetCompactionFromTs() uint64 {
	if x != nil {
		return x.CompactionFromTs
	}
	return 0
}

func (x *LogFileCompaction) GetCompactionUntilTs() uint64 {
	if x != nil {
		return x.CompactionUntilTs
	}
	return 0
}

func (x *LogFileCompaction) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *LogFileCompaction) GetComments() string {
	if x != nil {
		return x.Comments
	}
	return ""
}

func (x *LogFileCompaction) GetArtifacts() string {
	if x != nil {
		return x.Artifacts
	}
	return ""
}

func (x *LogFileCompaction) GetArtifactsHash() uint64 {
	if x != nil {
		return x.ArtifactsHash
	}
	return 0
}

func (x *LogFileCompaction) GetGeneratedFiles() string {
	if x != nil {
		return x.GeneratedFiles
	}
	return ""
}

func (x *LogFileCompaction) GetInputMinTs() uint64 {
	if x != nil {
		return x.InputMinTs
	}
	return 0
}

func (x *LogFileCompaction) GetInputMaxTs() uint64 {
	if x != nil {
		return x.InputMaxTs
	}
	return 0
}

type MetaEdit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Path to the meta file.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Delete the physical files (MetaFileGroup) in the meta file.
	DeletePhysicalFiles []string `protobuf:"bytes,2,rep,name=delete_physical_files,json=deletePhysicalFiles,proto3" json:"delete_physical_files,omitempty"`
	// Delete the logical files (MetaFileInfo) in the meta file.
	// Note: Even the operation have been performed in the meta,
	// this modification should be kept as long as the corresponding physical
	// file not deleted. Or we may cannot know when to delete the physical file.
	// Then the file will be leak until truncated.
	DeleteLogicalFiles []*DeleteSpansOfFile `protobuf:"bytes,3,rep,name=delete_logical_files,json=deleteLogicalFiles,proto3" json:"delete_logical_files,omitempty"`
	// Whether to delete the metadata itself.
	DestructSelf bool `protobuf:"varint,4,opt,name=destruct_self,json=destructSelf,proto3" json:"destruct_self,omitempty"`
	// Whether all data kv files have been compacted but meta kv file still remains.
	// this field used to determine whether we can ignore the physical data kv log files in a compaction.
	AllDataFilesCompacted bool `protobuf:"varint,5,opt,name=all_data_files_compacted,json=allDataFilesCompacted,proto3" json:"all_data_files_compacted,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *MetaEdit) Reset() {
	*x = MetaEdit{}
	mi := &file_brpb_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetaEdit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetaEdit) ProtoMessage() {}

func (x *MetaEdit) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetaEdit.ProtoReflect.Descriptor instead.
func (*MetaEdit) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{56}
}

func (x *MetaEdit) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *MetaEdit) GetDeletePhysicalFiles() []string {
	if x != nil {
		return x.DeletePhysicalFiles
	}
	return nil
}

func (x *MetaEdit) GetDeleteLogicalFiles() []*DeleteSpansOfFile {
	if x != nil {
		return x.DeleteLogicalFiles
	}
	return nil
}

func (x *MetaEdit) GetDestructSelf() bool {
	if x != nil {
		return x.DestructSelf
	}
	return false
}

func (x *MetaEdit) GetAllDataFilesCompacted() bool {
	if x != nil {
		return x.AllDataFilesCompacted
	}
	return false
}

// RewrittenTableID records a sort of modification over the SSTs during restoring.
//
// When "backing up" this "restored" SST, we want to backup the original SST before any rewrite.
// But in some cases, SSTs are not restored "as is", TiKV may rewrite or truncate its
// content by the client's request.
type RewrittenTableID struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The table ID in the backup data.
	AncestorUpstream int64 `protobuf:"varint,1,opt,name=ancestor_upstream,json=ancestorUpstream,proto3" json:"ancestor_upstream,omitempty"`
	// The rewritten table ID during restoring.
	Upstream      int64 `protobuf:"varint,2,opt,name=upstream,proto3" json:"upstream,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RewrittenTableID) Reset() {
	*x = RewrittenTableID{}
	mi := &file_brpb_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RewrittenTableID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RewrittenTableID) ProtoMessage() {}

func (x *RewrittenTableID) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RewrittenTableID.ProtoReflect.Descriptor instead.
func (*RewrittenTableID) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{57}
}

func (x *RewrittenTableID) GetAncestorUpstream() int64 {
	if x != nil {
		return x.AncestorUpstream
	}
	return 0
}

func (x *RewrittenTableID) GetUpstream() int64 {
	if x != nil {
		return x.Upstream
	}
	return 0
}

// IngestedSSTs is created by a client that wants to put data to the cluster by `Ingest` APIs,
// these write cannot be directly recorded by log backup. The client should put a migration
// that contains the SSTs it uploaded.
type IngestedSSTs struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The table IDs rewritten during restoring.
	RewrittenTables []*RewrittenTableID `protobuf:"bytes,1,rep,name=rewritten_tables,json=rewrittenTables,proto3" json:"rewritten_tables,omitempty"`
	// The SST files restored.
	Files []*File `protobuf:"bytes,2,rep,name=files,proto3" json:"files,omitempty"`
	// Treating the whole batch of SSTs as an huge atomic
	// write as this timestamp.
	// That is, when user wants to PiTR to sometime after this,
	// everything restored will present after the PiTR.
	// Otherwise nothing will present.
	AsIfTs uint64 `protobuf:"varint,3,opt,name=as_if_ts,json=asIfTs,proto3" json:"as_if_ts,omitempty"`
	// The hint of the common prefix of the files.
	// Used for speed up garbage collecting.
	FilesPrefixHint string `protobuf:"bytes,4,opt,name=files_prefix_hint,json=filesPrefixHint,proto3" json:"files_prefix_hint,omitempty"`
	// Whether this batch have finished.
	// If not, `as_if_ts` should be ignored and this should only
	// be restored when there is a finished backup with the same
	// `backup_uuid`.
	Finished bool `protobuf:"varint,5,opt,name=finished,proto3" json:"finished,omitempty"`
	// When checkpoint enabled, one restoration may be separated to many
	// of `IngestedSST`s.
	// `IngestedSST`s sharing the same UUID should be treated as one.
	// That is:
	// - The `as_if_ts` should be the largest one among all finished ingested SST batches.
	// - When restoring, all batches sharing the same uuid should be restored or not.
	BackupUuid    []byte `protobuf:"bytes,6,opt,name=backup_uuid,json=backupUuid,proto3" json:"backup_uuid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IngestedSSTs) Reset() {
	*x = IngestedSSTs{}
	mi := &file_brpb_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IngestedSSTs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IngestedSSTs) ProtoMessage() {}

func (x *IngestedSSTs) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IngestedSSTs.ProtoReflect.Descriptor instead.
func (*IngestedSSTs) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{58}
}

func (x *IngestedSSTs) GetRewrittenTables() []*RewrittenTableID {
	if x != nil {
		return x.RewrittenTables
	}
	return nil
}

func (x *IngestedSSTs) GetFiles() []*File {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *IngestedSSTs) GetAsIfTs() uint64 {
	if x != nil {
		return x.AsIfTs
	}
	return 0
}

func (x *IngestedSSTs) GetFilesPrefixHint() string {
	if x != nil {
		return x.FilesPrefixHint
	}
	return ""
}

func (x *IngestedSSTs) GetFinished() bool {
	if x != nil {
		return x.Finished
	}
	return false
}

func (x *IngestedSSTs) GetBackupUuid() []byte {
	if x != nil {
		return x.BackupUuid
	}
	return nil
}

// An extended version of `SpansOfFile`, added more metadata for the
// execution of delayed deletion.
type DeleteSpansOfFile struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Path  string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Spans []*Span                `protobuf:"bytes,2,rep,name=spans,proto3" json:"spans,omitempty"`
	// This is a hint for garbage collecting.
	// So we can easily check whether a set of spans consists the whole file.
	WholeFileLength uint64 `protobuf:"varint,3,opt,name=whole_file_length,json=wholeFileLength,proto3" json:"whole_file_length,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DeleteSpansOfFile) Reset() {
	*x = DeleteSpansOfFile{}
	mi := &file_brpb_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteSpansOfFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteSpansOfFile) ProtoMessage() {}

func (x *DeleteSpansOfFile) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteSpansOfFile.ProtoReflect.Descriptor instead.
func (*DeleteSpansOfFile) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{59}
}

func (x *DeleteSpansOfFile) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *DeleteSpansOfFile) GetSpans() []*Span {
	if x != nil {
		return x.Spans
	}
	return nil
}

func (x *DeleteSpansOfFile) GetWholeFileLength() uint64 {
	if x != nil {
		return x.WholeFileLength
	}
	return 0
}

type Migration struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Creator     string                 `protobuf:"bytes,5,opt,name=creator,proto3" json:"creator,omitempty"`
	Version     MigrationVersion       `protobuf:"varint,6,opt,name=version,proto3,enum=backup.MigrationVersion" json:"version,omitempty"`
	EditMeta    []*MetaEdit            `protobuf:"bytes,1,rep,name=edit_meta,json=editMeta,proto3" json:"edit_meta,omitempty"`
	TruncatedTo uint64                 `protobuf:"varint,2,opt,name=truncated_to,json=truncatedTo,proto3" json:"truncated_to,omitempty"`
	Compactions []*LogFileCompaction   `protobuf:"bytes,3,rep,name=compactions,proto3" json:"compactions,omitempty"`
	// Delete all files matches this prefix.
	DestructPrefix []string `protobuf:"bytes,4,rep,name=destruct_prefix,json=destructPrefix,proto3" json:"destruct_prefix,omitempty"`
	// The ingested SSTs.
	// It is mutable during restoring, hence a reference.
	IngestedSstPaths []string `protobuf:"bytes,7,rep,name=ingested_sst_paths,json=ingestedSstPaths,proto3" json:"ingested_sst_paths,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Migration) Reset() {
	*x = Migration{}
	mi := &file_brpb_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Migration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Migration) ProtoMessage() {}

func (x *Migration) ProtoReflect() protoreflect.Message {
	mi := &file_brpb_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Migration.ProtoReflect.Descriptor instead.
func (*Migration) Descriptor() ([]byte, []int) {
	return file_brpb_proto_rawDescGZIP(), []int{60}
}

func (x *Migration) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *Migration) GetVersion() MigrationVersion {
	if x != nil {
		return x.Version
	}
	return MigrationVersion_M0
}

func (x *Migration) GetEditMeta() []*MetaEdit {
	if x != nil {
		return x.EditMeta
	}
	return nil
}

func (x *Migration) GetTruncatedTo() uint64 {
	if x != nil {
		return x.TruncatedTo
	}
	return 0
}

func (x *Migration) GetCompactions() []*LogFileCompaction {
	if x != nil {
		return x.Compactions
	}
	return nil
}

func (x *Migration) GetDestructPrefix() []string {
	if x != nil {
		return x.DestructPrefix
	}
	return nil
}

func (x *Migration) GetIngestedSstPaths() []string {
	if x != nil {
		return x.IngestedSstPaths
	}
	return nil
}

var File_brpb_proto protoreflect.FileDescriptor

const file_brpb_proto_rawDesc = "" +
	"\n" +
	"\n" +
	"brpb.proto\x12\x06backup\x1a\rkvrpcpb.proto\x1a\rerrorpb.proto\x1a\fmetapb.proto\x1a\x12encryptionpb.proto\x1a\x0frustproto.proto\"\xac\x01\n" +
	"\x1cPrepareSnapshotBackupRequest\x128\n" +
	"\x02ty\x18\x01 \x01(\x0e2(.backup.PrepareSnapshotBackupRequestTypeR\x02ty\x12(\n" +
	"\aregions\x18\x02 \x03(\v2\x0e.metapb.RegionR\aregions\x12(\n" +
	"\x10lease_in_seconds\x18\x03 \x01(\x04R\x0eleaseInSeconds\"\xd4\x01\n" +
	"\x1dPrepareSnapshotBackupResponse\x126\n" +
	"\x02ty\x18\x01 \x01(\x0e2&.backup.PrepareSnapshotBackupEventTypeR\x02ty\x12&\n" +
	"\x06region\x18\x02 \x01(\v2\x0e.metapb.RegionR\x06region\x12$\n" +
	"\x05error\x18\x03 \x01(\v2\x0e.errorpb.ErrorR\x05error\x12-\n" +
	"\x13last_lease_is_valid\x18\x04 \x01(\bR\x10lastLeaseIsValid\"\xe5\a\n" +
	"\n" +
	"BackupMeta\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\x04R\tclusterId\x12'\n" +
	"\x0fcluster_version\x18\x02 \x01(\tR\x0eclusterVersion\x12\x1d\n" +
	"\n" +
	"br_version\x18\v \x01(\tR\tbrVersion\x12\x18\n" +
	"\aversion\x18\f \x01(\x05R\aversion\x12\"\n" +
	"\x05files\x18\x04 \x03(\v2\f.backup.FileR\x05files\x12/\n" +
	"\n" +
	"file_index\x18\r \x01(\v2\x10.backup.MetaFileR\tfileIndex\x12#\n" +
	"\rstart_version\x18\x05 \x01(\x04R\fstartVersion\x12\x1f\n" +
	"\vend_version\x18\x06 \x01(\x04R\n" +
	"endVersion\x12(\n" +
	"\aschemas\x18\a \x03(\v2\x0e.backup.SchemaR\aschemas\x123\n" +
	"\fschema_index\x18\x0e \x01(\v2\x10.backup.MetaFileR\vschemaIndex\x12\x1a\n" +
	"\tis_raw_kv\x18\b \x01(\bR\aisRawKv\x12/\n" +
	"\n" +
	"raw_ranges\x18\t \x03(\v2\x10.backup.RawRangeR\trawRanges\x128\n" +
	"\x0fraw_range_index\x18\x0f \x01(\v2\x10.backup.MetaFileR\rrawRangeIndex\x12\x12\n" +
	"\x04ddls\x18\n" +
	" \x01(\fR\x04ddls\x121\n" +
	"\vddl_indexes\x18\x10 \x01(\v2\x10.backup.MetaFileR\n" +
	"ddlIndexes\x12#\n" +
	"\rbackup_result\x18\x11 \x01(\tR\fbackupResult\x124\n" +
	"\vapi_version\x18\x12 \x01(\x0e2\x13.kvrpcpb.APIVersionR\n" +
	"apiVersion\x123\n" +
	"\bpolicies\x18\x13 \x03(\v2\x17.backup.PlacementPolicyR\bpolicies\x124\n" +
	"\x16new_collations_enabled\x18\x14 \x01(\tR\x14newCollationsEnabled\x12\x1a\n" +
	"\tis_txn_kv\x18\x15 \x01(\bR\aisTxnKv\x12*\n" +
	"\adb_maps\x18\x16 \x03(\v2\x11.backup.PitrDBMapR\x06dbMaps\x12&\n" +
	"\x04mode\x18\x17 \x01(\x0e2\x12.backup.BackupModeR\x04mode\x12+\n" +
	"\x06ranges\x18\x18 \x03(\v2\x13.backup.BackupRangeR\x06ranges\x12\x1f\n" +
	"\vbackup_size\x18\x19 \x01(\x04R\n" +
	"backupSizeJ\x04\b\x03\x10\x04R\x04path\"g\n" +
	"\vBackupRange\x12\x1b\n" +
	"\tstart_key\x18\x01 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x02 \x01(\fR\x06endKey\x12\"\n" +
	"\x05files\x18\x03 \x03(\v2\f.backup.FileR\x05files\"\x86\x01\n" +
	"\tTableMeta\x12\x1f\n" +
	"\vphysical_id\x18\x01 \x01(\x03R\n" +
	"physicalId\x12\x1a\n" +
	"\bcrc64xor\x18\x02 \x01(\x04R\bcrc64xor\x12\x1b\n" +
	"\ttotal_kvs\x18\x03 \x01(\x04R\btotalKvs\x12\x1f\n" +
	"\vtotal_bytes\x18\x04 \x01(\x04R\n" +
	"totalBytes\"\xfd\x02\n" +
	"\x04File\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06sha256\x18\x02 \x01(\fR\x06sha256\x12\x1b\n" +
	"\tstart_key\x18\x03 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x04 \x01(\fR\x06endKey\x12#\n" +
	"\rstart_version\x18\x05 \x01(\x04R\fstartVersion\x12\x1f\n" +
	"\vend_version\x18\x06 \x01(\x04R\n" +
	"endVersion\x12\x1a\n" +
	"\bcrc64xor\x18\a \x01(\x04R\bcrc64xor\x12\x1b\n" +
	"\ttotal_kvs\x18\b \x01(\x04R\btotalKvs\x12\x1f\n" +
	"\vtotal_bytes\x18\t \x01(\x04R\n" +
	"totalBytes\x122\n" +
	"\vtable_metas\x18\r \x03(\v2\x11.backup.TableMetaR\n" +
	"tableMetas\x12\x0e\n" +
	"\x02cf\x18\n" +
	" \x01(\tR\x02cf\x12\x12\n" +
	"\x04size\x18\v \x01(\x04R\x04size\x12\x1b\n" +
	"\tcipher_iv\x18\f \x01(\fR\bcipherIv\"\x8d\x02\n" +
	"\bMetaFile\x12+\n" +
	"\n" +
	"meta_files\x18\x01 \x03(\v2\f.backup.FileR\tmetaFiles\x12+\n" +
	"\n" +
	"data_files\x18\x02 \x03(\v2\f.backup.FileR\tdataFiles\x12(\n" +
	"\aschemas\x18\x03 \x03(\v2\x0e.backup.SchemaR\aschemas\x12/\n" +
	"\n" +
	"raw_ranges\x18\x04 \x03(\v2\x10.backup.RawRangeR\trawRanges\x128\n" +
	"\rbackup_ranges\x18\x06 \x03(\v2\x13.backup.BackupRangeR\fbackupRanges\x12\x12\n" +
	"\x04ddls\x18\x05 \x03(\fR\x04ddls\"%\n" +
	"\x0fPlacementPolicy\x12\x12\n" +
	"\x04info\x18\x01 \x01(\fR\x04info\"L\n" +
	"\n" +
	"StatsBlock\x12\x1f\n" +
	"\vphysical_id\x18\x01 \x01(\x03R\n" +
	"physicalId\x12\x1d\n" +
	"\n" +
	"json_table\x18\x02 \x01(\fR\tjsonTable\"7\n" +
	"\tStatsFile\x12*\n" +
	"\x06blocks\x18\x01 \x03(\v2\x12.backup.StatsBlockR\x06blocks\"\xb0\x01\n" +
	"\x0eStatsFileIndex\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06sha256\x18\x02 \x01(\fR\x06sha256\x12\x19\n" +
	"\bsize_enc\x18\x03 \x01(\x04R\asizeEnc\x12\x19\n" +
	"\bsize_ori\x18\x04 \x01(\x04R\asizeOri\x12\x1b\n" +
	"\tcipher_iv\x18\x05 \x01(\fR\bcipherIv\x12\x1f\n" +
	"\vinline_data\x18\x06 \x01(\fR\n" +
	"inlineData\"\xff\x03\n" +
	"\x06Schema\x12\x0e\n" +
	"\x02db\x18\x01 \x01(\fR\x02db\x12\x14\n" +
	"\x05table\x18\x02 \x01(\fR\x05table\x12\x1a\n" +
	"\bcrc64xor\x18\x03 \x01(\x04R\bcrc64xor\x12\x1b\n" +
	"\ttotal_kvs\x18\x04 \x01(\x04R\btotalKvs\x12\x1f\n" +
	"\vtotal_bytes\x18\x05 \x01(\x04R\n" +
	"totalBytes\x12)\n" +
	"\x10tiflash_replicas\x18\x06 \x01(\rR\x0ftiflashReplicas\x12\x14\n" +
	"\x05stats\x18\a \x01(\fR\x05stats\x127\n" +
	"\vstats_index\x18\b \x03(\v2\x16.backup.StatsFileIndexR\n" +
	"statsIndex\x125\n" +
	"\x17is_merge_option_allowed\x18\t \x01(\bR\x14isMergeOptionAllowed\x12t\n" +
	"\x1epartition_merge_option_allowed\x18\n" +
	" \x03(\v2/.backup.Schema.PartitionMergeOptionAllowedEntryR\x1bpartitionMergeOptionAllowed\x1aN\n" +
	" PartitionMergeOptionAllowedEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\bR\x05value:\x028\x01\"M\n" +
	"\x05IDMap\x12\x1f\n" +
	"\vupstream_id\x18\x01 \x01(\x03R\n" +
	"upstreamId\x12#\n" +
	"\rdownstream_id\x18\x02 \x01(\x03R\fdownstreamId\"\x9a\x01\n" +
	"\fPitrTableMap\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12$\n" +
	"\x06id_map\x18\x02 \x01(\v2\r.backup.IDMapR\x05idMap\x12-\n" +
	"\n" +
	"partitions\x18\x03 \x03(\v2\r.backup.IDMapR\n" +
	"partitions\x12!\n" +
	"\ffiltered_out\x18\x04 \x01(\bR\vfilteredOut\"\xae\x01\n" +
	"\tPitrDBMap\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12$\n" +
	"\x06id_map\x18\x02 \x01(\v2\r.backup.IDMapR\x05idMap\x12,\n" +
	"\x06tables\x18\x03 \x03(\v2\x14.backup.PitrTableMapR\x06tables\x12!\n" +
	"\ffiltered_out\x18\x04 \x01(\bR\vfilteredOut\x12\x16\n" +
	"\x06reused\x18\x05 \x01(\bR\x06reused\"P\n" +
	"\bRawRange\x12\x1b\n" +
	"\tstart_key\x18\x01 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x02 \x01(\fR\x06endKey\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\"D\n" +
	"\x0eClusterIDError\x12\x18\n" +
	"\acurrent\x18\x01 \x01(\x04R\acurrent\x12\x18\n" +
	"\arequest\x18\x02 \x01(\x04R\arequest\"\xcc\x01\n" +
	"\x05Error\x12\x10\n" +
	"\x03msg\x18\x01 \x01(\tR\x03msg\x12B\n" +
	"\x10cluster_id_error\x18\x03 \x01(\v2\x16.backup.ClusterIDErrorH\x00R\x0eclusterIdError\x12.\n" +
	"\bkv_error\x18\x04 \x01(\v2\x11.kvrpcpb.KeyErrorH\x00R\akvError\x123\n" +
	"\fregion_error\x18\x05 \x01(\v2\x0e.errorpb.ErrorH\x00R\vregionErrorB\b\n" +
	"\x06detail\"\xb9\x01\n" +
	"\x1eStreamBackupTaskSecurityConfig\x12B\n" +
	"\x12plaintext_data_key\x18\x01 \x01(\v2\x12.backup.CipherInfoH\x00R\x10plaintextDataKey\x12E\n" +
	"\x11master_key_config\x18\x02 \x01(\v2\x17.backup.MasterKeyConfigH\x00R\x0fmasterKeyConfigB\f\n" +
	"\n" +
	"encryption\"l\n" +
	"\n" +
	"CipherInfo\x12?\n" +
	"\vcipher_type\x18\x01 \x01(\x0e2\x1e.encryptionpb.EncryptionMethodR\n" +
	"cipherType\x12\x1d\n" +
	"\n" +
	"cipher_key\x18\x02 \x01(\fR\tcipherKey\"\x94\x01\n" +
	"\x0fMasterKeyConfig\x12G\n" +
	"\x0fencryption_type\x18\x01 \x01(\x0e2\x1e.encryptionpb.EncryptionMethodR\x0eencryptionType\x128\n" +
	"\vmaster_keys\x18\x02 \x03(\v2\x17.encryptionpb.MasterKeyR\n" +
	"masterKeys\"C\n" +
	"\x0fSortedSubRanges\x120\n" +
	"\n" +
	"sub_ranges\x18\x01 \x03(\v2\x11.kvrpcpb.KeyRangeR\tsubRanges\"\xdf\x06\n" +
	"\rBackupRequest\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\x04R\tclusterId\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x03 \x01(\fR\x06endKey\x12#\n" +
	"\rstart_version\x18\x04 \x01(\x04R\fstartVersion\x12\x1f\n" +
	"\vend_version\x18\x05 \x01(\x04R\n" +
	"endVersion\x12\x1d\n" +
	"\n" +
	"rate_limit\x18\a \x01(\x04R\trateLimit\x12 \n" +
	"\vconcurrency\x18\b \x01(\rR\vconcurrency\x12?\n" +
	"\x0fstorage_backend\x18\t \x01(\v2\x16.backup.StorageBackendR\x0estorageBackend\x12\x1a\n" +
	"\tis_raw_kv\x18\n" +
	" \x01(\bR\aisRawKv\x12\x0e\n" +
	"\x02cf\x18\v \x01(\tR\x02cf\x12B\n" +
	"\x10compression_type\x18\f \x01(\x0e2\x17.backup.CompressionTypeR\x0fcompressionType\x12+\n" +
	"\x11compression_level\x18\r \x01(\x05R\x10compressionLevel\x123\n" +
	"\vcipher_info\x18\x0e \x01(\v2\x12.backup.CipherInfoR\n" +
	"cipherInfo\x12;\n" +
	"\x0fdst_api_version\x18\x0f \x01(\x0e2\x13.kvrpcpb.APIVersionR\rdstApiVersion\x120\n" +
	"\n" +
	"sub_ranges\x18\x10 \x03(\v2\x11.kvrpcpb.KeyRangeR\tsubRanges\x12P\n" +
	"\x18sorted_sub_ranges_groups\x18\x15 \x03(\v2\x17.backup.SortedSubRangesR\x15sortedSubRangesGroups\x12!\n" +
	"\freplica_read\x18\x11 \x01(\bR\vreplicaRead\x12&\n" +
	"\x04mode\x18\x12 \x01(\x0e2\x12.backup.BackupModeR\x04mode\x12\x1b\n" +
	"\tunique_id\x18\x13 \x01(\tR\buniqueId\x12*\n" +
	"\acontext\x18\x14 \x01(\v2\x10.kvrpcpb.ContextR\acontextJ\x04\b\x06\x10\aR\x04path\"\xe6\x02\n" +
	"\x14StreamBackupTaskInfo\x120\n" +
	"\astorage\x18\x01 \x01(\v2\x16.backup.StorageBackendR\astorage\x12\x19\n" +
	"\bstart_ts\x18\x02 \x01(\x04R\astartTs\x12\x15\n" +
	"\x06end_ts\x18\x03 \x01(\x04R\x05endTs\x12\x12\n" +
	"\x04name\x18\x04 \x01(\tR\x04name\x12!\n" +
	"\ftable_filter\x18\x05 \x03(\tR\vtableFilter\x12B\n" +
	"\x10compression_type\x18\x06 \x01(\x0e2\x17.backup.CompressionTypeR\x0fcompressionType\x12O\n" +
	"\x0fsecurity_config\x18\a \x01(\v2&.backup.StreamBackupTaskSecurityConfigR\x0esecurityConfigR\x0elast_update_tsR\x06rangesR\x06status\"\xd0\x02\n" +
	"\x0eStorageBackend\x12\"\n" +
	"\x04noop\x18\x01 \x01(\v2\f.backup.NoopH\x00R\x04noop\x12%\n" +
	"\x05local\x18\x02 \x01(\v2\r.backup.LocalH\x00R\x05local\x12\x1c\n" +
	"\x02s3\x18\x03 \x01(\v2\n" +
	".backup.S3H\x00R\x02s3\x12\x1f\n" +
	"\x03gcs\x18\x04 \x01(\v2\v.backup.GCSH\x00R\x03gcs\x12;\n" +
	"\rcloud_dynamic\x18\x05 \x01(\v2\x14.backup.CloudDynamicH\x00R\fcloudDynamic\x12\"\n" +
	"\x04hdfs\x18\x06 \x01(\v2\f.backup.HDFSH\x00R\x04hdfs\x12H\n" +
	"\x12azure_blob_storage\x18\a \x01(\v2\x18.backup.AzureBlobStorageH\x00R\x10azureBlobStorageB\t\n" +
	"\abackend\"\x06\n" +
	"\x04Noop\"\x1b\n" +
	"\x05Local\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\"\x92\x04\n" +
	"\x02S3\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x16\n" +
	"\x06region\x18\x02 \x01(\tR\x06region\x12\x16\n" +
	"\x06bucket\x18\x03 \x01(\tR\x06bucket\x12\x16\n" +
	"\x06prefix\x18\x04 \x01(\tR\x06prefix\x12#\n" +
	"\rstorage_class\x18\x05 \x01(\tR\fstorageClass\x12\x10\n" +
	"\x03sse\x18\x06 \x01(\tR\x03sse\x12\x10\n" +
	"\x03acl\x18\a \x01(\tR\x03acl\x12\x1d\n" +
	"\n" +
	"access_key\x18\b \x01(\tR\taccessKey\x12*\n" +
	"\x11secret_access_key\x18\t \x01(\tR\x0fsecretAccessKey\x12(\n" +
	"\x10force_path_style\x18\n" +
	" \x01(\bR\x0eforcePathStyle\x12#\n" +
	"\x0esse_kms_key_id\x18\v \x01(\tR\vsseKmsKeyId\x12\x19\n" +
	"\brole_arn\x18\f \x01(\tR\aroleArn\x12\x1f\n" +
	"\vexternal_id\x18\r \x01(\tR\n" +
	"externalId\x12.\n" +
	"\x13object_lock_enabled\x18\x0e \x01(\bR\x11objectLockEnabled\x12#\n" +
	"\rsession_token\x18\x0f \x01(\tR\fsessionToken\x12\x1a\n" +
	"\bprovider\x18\x10 \x01(\tR\bprovider\x12\x18\n" +
	"\aprofile\x18\x11 \x01(\tR\aprofile\"\xc8\x01\n" +
	"\x03GCS\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x16\n" +
	"\x06bucket\x18\x02 \x01(\tR\x06bucket\x12\x16\n" +
	"\x06prefix\x18\x03 \x01(\tR\x06prefix\x12#\n" +
	"\rstorage_class\x18\x04 \x01(\tR\fstorageClass\x12%\n" +
	"\x0epredefined_acl\x18\x05 \x01(\tR\rpredefinedAcl\x12)\n" +
	"\x10credentials_blob\x18\x06 \x01(\tR\x0fcredentialsBlob\"m\n" +
	"\x10AzureCustomerKey\x12%\n" +
	"\x0eencryption_key\x18\x01 \x01(\tR\rencryptionKey\x122\n" +
	"\x15encryption_key_sha256\x18\x02 \x01(\tR\x13encryptionKeySha256\"\xd0\x02\n" +
	"\x10AzureBlobStorage\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x16\n" +
	"\x06bucket\x18\x02 \x01(\tR\x06bucket\x12\x16\n" +
	"\x06prefix\x18\x03 \x01(\tR\x06prefix\x12#\n" +
	"\rstorage_class\x18\x04 \x01(\tR\fstorageClass\x12!\n" +
	"\faccount_name\x18\x05 \x01(\tR\vaccountName\x12\x1d\n" +
	"\n" +
	"shared_key\x18\x06 \x01(\tR\tsharedKey\x12\x1d\n" +
	"\n" +
	"access_sig\x18\b \x01(\tR\taccessSig\x12)\n" +
	"\x10encryption_scope\x18\t \x01(\tR\x0fencryptionScope\x12?\n" +
	"\x0eencryption_key\x18\n" +
	" \x01(\v2\x18.backup.AzureCustomerKeyR\rencryptionKey\"\x91\x01\n" +
	"\x06Bucket\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x16\n" +
	"\x06region\x18\x03 \x01(\tR\x06region\x12\x16\n" +
	"\x06bucket\x18\x04 \x01(\tR\x06bucket\x12\x16\n" +
	"\x06prefix\x18\x05 \x01(\tR\x06prefix\x12#\n" +
	"\rstorage_class\x18\x06 \x01(\tR\fstorageClass\"\xcc\x01\n" +
	"\fCloudDynamic\x12&\n" +
	"\x06bucket\x18\x01 \x01(\v2\x0e.backup.BucketR\x06bucket\x12#\n" +
	"\rprovider_name\x18\x02 \x01(\tR\fproviderName\x125\n" +
	"\x05attrs\x18\x03 \x03(\v2\x1f.backup.CloudDynamic.AttrsEntryR\x05attrs\x1a8\n" +
	"\n" +
	"AttrsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x1e\n" +
	"\x04HDFS\x12\x16\n" +
	"\x06remote\x18\x01 \x01(\tR\x06remote\"\xc5\x01\n" +
	"\x0eBackupResponse\x12#\n" +
	"\x05error\x18\x01 \x01(\v2\r.backup.ErrorR\x05error\x12\x1b\n" +
	"\tstart_key\x18\x02 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x03 \x01(\fR\x06endKey\x12\"\n" +
	"\x05files\x18\x04 \x03(\v2\f.backup.FileR\x05files\x124\n" +
	"\vapi_version\x18\x05 \x01(\x0e2\x13.kvrpcpb.APIVersionR\n" +
	"apiVersion\"-\n" +
	"\x0eCleanupRequest\x12\x1b\n" +
	"\tunique_id\x18\x01 \x01(\tR\buniqueId\"P\n" +
	"\x0fCleanupResponse\x12#\n" +
	"\x05error\x18\x01 \x01(\v2\r.backup.ErrorR\x05error\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\"8\n" +
	"\x0ePrepareRequest\x12&\n" +
	"\x0fsave_to_storage\x18\x01 \x01(\bR\rsaveToStorage\"\xad\x01\n" +
	"\x0fPrepareResponse\x12#\n" +
	"\x05error\x18\x01 \x01(\v2\r.backup.ErrorR\x05error\x12\x1b\n" +
	"\tunique_id\x18\x02 \x01(\tR\buniqueId\x12,\n" +
	"\x12collect_file_count\x18\x03 \x01(\x04R\x10collectFileCount\x12*\n" +
	"\x11collect_file_size\x18\x04 \x01(\x04R\x0fcollectFileSize\"\x13\n" +
	"\x11CheckAdminRequest\"\x8d\x01\n" +
	"\x12CheckAdminResponse\x12#\n" +
	"\x05error\x18\x01 \x01(\v2\r.backup.ErrorR\x05error\x12&\n" +
	"\x06region\x18\x02 \x01(\v2\x0e.metapb.RegionR\x06region\x12*\n" +
	"\x11has_pending_admin\x18\x03 \x01(\bR\x0fhasPendingAdmin\"\xcb\x01\n" +
	"\x1dExternalStorageRestoreRequest\x12?\n" +
	"\x0fstorage_backend\x18\x01 \x01(\v2\x16.backup.StorageBackendR\x0estorageBackend\x12\x1f\n" +
	"\vobject_name\x18\x02 \x01(\tR\n" +
	"objectName\x12!\n" +
	"\frestore_name\x18\x03 \x01(\tR\vrestoreName\x12%\n" +
	"\x0econtent_length\x18\x04 \x01(\x04R\rcontentLength\" \n" +
	"\x1eExternalStorageRestoreResponse\"\xa5\x01\n" +
	"\x1aExternalStorageSaveRequest\x12?\n" +
	"\x0fstorage_backend\x18\x01 \x01(\v2\x16.backup.StorageBackendR\x0estorageBackend\x12\x1f\n" +
	"\vobject_name\x18\x02 \x01(\tR\n" +
	"objectName\x12%\n" +
	"\x0econtent_length\x18\x03 \x01(\x04R\rcontentLength\"\x1d\n" +
	"\x1bExternalStorageSaveResponse\"\x90\x02\n" +
	"\bMetadata\x12*\n" +
	"\x05files\x18\x01 \x03(\v2\x14.backup.DataFileInfoR\x05files\x126\n" +
	"\vfile_groups\x18\x06 \x03(\v2\x15.backup.DataFileGroupR\n" +
	"fileGroups\x12\x19\n" +
	"\bstore_id\x18\x02 \x01(\x03R\astoreId\x12\x1f\n" +
	"\vresolved_ts\x18\x03 \x01(\x04R\n" +
	"resolvedTs\x12\x15\n" +
	"\x06max_ts\x18\x04 \x01(\x04R\x05maxTs\x12\x15\n" +
	"\x06min_ts\x18\x05 \x01(\x04R\x05minTs\x126\n" +
	"\fmeta_version\x18\a \x01(\x0e2\x13.backup.MetaVersionR\vmetaVersion\"\xd9\x01\n" +
	"\rDataFileGroup\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12<\n" +
	"\x0fdata_files_info\x18\x02 \x03(\v2\x14.backup.DataFileInfoR\rdataFilesInfo\x12\x15\n" +
	"\x06min_ts\x18\x03 \x01(\x04R\x05minTs\x12\x15\n" +
	"\x06max_ts\x18\x04 \x01(\x04R\x05maxTs\x12&\n" +
	"\x0fmin_resolved_ts\x18\x05 \x01(\x04R\rminResolvedTs\x12\x16\n" +
	"\x06length\x18\x06 \x01(\x04R\x06length:\b\x98\xa7\b\x01\xa0\xa7\b\x01\"\xd1\x06\n" +
	"\fDataFileInfo\x12\x16\n" +
	"\x06sha256\x18\x01 \x01(\fR\x06sha256\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12*\n" +
	"\x11number_of_entries\x18\x03 \x01(\x03R\x0fnumberOfEntries\x12\x15\n" +
	"\x06min_ts\x18\x04 \x01(\x04R\x05minTs\x12\x15\n" +
	"\x06max_ts\x18\x05 \x01(\x04R\x05maxTs\x12\x1f\n" +
	"\vresolved_ts\x18\x06 \x01(\x04R\n" +
	"resolvedTs\x12\x1b\n" +
	"\tregion_id\x18\a \x01(\x03R\bregionId\x12\x1b\n" +
	"\tstart_key\x18\b \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\t \x01(\fR\x06endKey\x12\x0e\n" +
	"\x02cf\x18\n" +
	" \x01(\tR\x02cf\x12$\n" +
	"\x04type\x18\v \x01(\x0e2\x10.backup.FileTypeR\x04type\x12\x17\n" +
	"\ais_meta\x18\f \x01(\bR\x06isMeta\x12\x19\n" +
	"\btable_id\x18\r \x01(\x03R\atableId\x12\x16\n" +
	"\x06length\x18\x0e \x01(\x04R\x06length\x129\n" +
	"\x1amin_begin_ts_in_default_cf\x18\x0f \x01(\x04R\x15minBeginTsInDefaultCf\x12!\n" +
	"\frange_offset\x18\x10 \x01(\x04R\vrangeOffset\x12!\n" +
	"\frange_length\x18\x11 \x01(\x04R\vrangeLength\x12B\n" +
	"\x10compression_type\x18\x12 \x01(\x0e2\x17.backup.CompressionTypeR\x0fcompressionType\x12\x1a\n" +
	"\bcrc64xor\x18\x13 \x01(\x04R\bcrc64xor\x12(\n" +
	"\x10region_start_key\x18\x14 \x01(\fR\x0eregionStartKey\x12$\n" +
	"\x0eregion_end_key\x18\x15 \x01(\fR\fregionEndKey\x126\n" +
	"\fregion_epoch\x18\x16 \x03(\v2\x13.metapb.RegionEpochR\vregionEpoch\x12R\n" +
	"\x14file_encryption_info\x18\x17 \x01(\v2 .encryptionpb.FileEncryptionInfoR\x12fileEncryptionInfo:\b\x98\xa7\b\x01\xa0\xa7\b\x01\"\x8f\x01\n" +
	"\x11StreamBackupError\x12\x1b\n" +
	"\thappen_at\x18\x01 \x01(\x04R\bhappenAt\x12\x1d\n" +
	"\n" +
	"error_code\x18\x02 \x01(\tR\terrorCode\x12#\n" +
	"\rerror_message\x18\x03 \x01(\tR\ferrorMessage\x12\x19\n" +
	"\bstore_id\x18\x04 \x01(\x04R\astoreId\"6\n" +
	"\x04Span\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x04R\x06offset\x12\x16\n" +
	"\x06length\x18\x02 \x01(\x04R\x06length\"E\n" +
	"\vSpansOfFile\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\"\n" +
	"\x05spans\x18\x02 \x03(\v2\f.backup.SpanR\x05spans\"\x8f\x03\n" +
	"\x18LogFileSubcompactionMeta\x12\x12\n" +
	"\x04size\x18\x01 \x01(\x04R\x04size\x12\x1b\n" +
	"\tregion_id\x18\x02 \x01(\x04R\bregionId\x12\x0e\n" +
	"\x02cf\x18\x03 \x01(\tR\x02cf\x12 \n" +
	"\finput_max_ts\x18\x04 \x01(\x04R\n" +
	"inputMaxTs\x12 \n" +
	"\finput_min_ts\x18\x05 \x01(\x04R\n" +
	"inputMinTs\x12&\n" +
	"\x0fcompact_from_ts\x18\x06 \x01(\x04R\rcompactFromTs\x12(\n" +
	"\x10compact_until_ts\x18\a \x01(\x04R\x0ecompactUntilTs\x12\x17\n" +
	"\amin_key\x18\b \x01(\fR\x06minKey\x12\x17\n" +
	"\amax_key\x18\t \x01(\fR\x06maxKey\x12 \n" +
	"\x02ty\x18\n" +
	" \x01(\x0e2\x10.backup.FileTypeR\x02ty\x12\x19\n" +
	"\btable_id\x18\v \x01(\x03R\atableId\x12-\n" +
	"\asources\x18\f \x03(\v2\x13.backup.SpansOfFileR\asources\"\xbf\x01\n" +
	"\x14LogFileSubcompaction\x124\n" +
	"\x04meta\x18\x01 \x01(\v2 .backup.LogFileSubcompactionMetaR\x04meta\x12-\n" +
	"\vsst_outputs\x18\x02 \x03(\v2\f.backup.FileR\n" +
	"sstOutputs\x12B\n" +
	"\x11region_meta_hints\x18\x03 \x03(\v2\x16.backup.RegionMetaHintR\x0fregionMetaHints\"~\n" +
	"\x0eRegionMetaHint\x12\x1b\n" +
	"\tstart_key\x18\x01 \x01(\fR\bstartKey\x12\x17\n" +
	"\aend_key\x18\x02 \x01(\fR\x06endKey\x126\n" +
	"\fregion_epoch\x18\x03 \x01(\v2\x13.metapb.RegionEpochR\vregionEpoch\"]\n" +
	"\x15LogFileSubcompactions\x12D\n" +
	"\x0esubcompactions\x18\x01 \x03(\v2\x1c.backup.LogFileSubcompactionR\x0esubcompactions\"\xd3\x02\n" +
	"\x11LogFileCompaction\x12,\n" +
	"\x12compaction_from_ts\x18\x01 \x01(\x04R\x10compactionFromTs\x12.\n" +
	"\x13compaction_until_ts\x18\x02 \x01(\x04R\x11compactionUntilTs\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x1a\n" +
	"\bcomments\x18\x04 \x01(\tR\bcomments\x12\x1c\n" +
	"\tartifacts\x18\x05 \x01(\tR\tartifacts\x12%\n" +
	"\x0eartifacts_hash\x18\x06 \x01(\x04R\rartifactsHash\x12'\n" +
	"\x0fgenerated_files\x18\a \x01(\tR\x0egeneratedFiles\x12 \n" +
	"\finput_min_ts\x18\b \x01(\x04R\n" +
	"inputMinTs\x12 \n" +
	"\finput_max_ts\x18\t \x01(\x04R\n" +
	"inputMaxTs\"\xfd\x01\n" +
	"\bMetaEdit\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x122\n" +
	"\x15delete_physical_files\x18\x02 \x03(\tR\x13deletePhysicalFiles\x12K\n" +
	"\x14delete_logical_files\x18\x03 \x03(\v2\x19.backup.DeleteSpansOfFileR\x12deleteLogicalFiles\x12#\n" +
	"\rdestruct_self\x18\x04 \x01(\bR\fdestructSelf\x127\n" +
	"\x18all_data_files_compacted\x18\x05 \x01(\bR\x15allDataFilesCompacted\"[\n" +
	"\x10RewrittenTableID\x12+\n" +
	"\x11ancestor_upstream\x18\x01 \x01(\x03R\x10ancestorUpstream\x12\x1a\n" +
	"\bupstream\x18\x02 \x01(\x03R\bupstream\"\xfa\x01\n" +
	"\fIngestedSSTs\x12C\n" +
	"\x10rewritten_tables\x18\x01 \x03(\v2\x18.backup.RewrittenTableIDR\x0frewrittenTables\x12\"\n" +
	"\x05files\x18\x02 \x03(\v2\f.backup.FileR\x05files\x12\x18\n" +
	"\bas_if_ts\x18\x03 \x01(\x04R\x06asIfTs\x12*\n" +
	"\x11files_prefix_hint\x18\x04 \x01(\tR\x0ffilesPrefixHint\x12\x1a\n" +
	"\bfinished\x18\x05 \x01(\bR\bfinished\x12\x1f\n" +
	"\vbackup_uuid\x18\x06 \x01(\fR\n" +
	"backupUuid\"w\n" +
	"\x11DeleteSpansOfFile\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\"\n" +
	"\x05spans\x18\x02 \x03(\v2\f.backup.SpanR\x05spans\x12*\n" +
	"\x11whole_file_length\x18\x03 \x01(\x04R\x0fwholeFileLength\"\xbf\x02\n" +
	"\tMigration\x12\x18\n" +
	"\acreator\x18\x05 \x01(\tR\acreator\x122\n" +
	"\aversion\x18\x06 \x01(\x0e2\x18.backup.MigrationVersionR\aversion\x12-\n" +
	"\tedit_meta\x18\x01 \x03(\v2\x10.backup.MetaEditR\beditMeta\x12!\n" +
	"\ftruncated_to\x18\x02 \x01(\x04R\vtruncatedTo\x12;\n" +
	"\vcompactions\x18\x03 \x03(\v2\x19.backup.LogFileCompactionR\vcompactions\x12'\n" +
	"\x0fdestruct_prefix\x18\x04 \x03(\tR\x0edestructPrefix\x12,\n" +
	"\x12ingested_sst_paths\x18\a \x03(\tR\x10ingestedSstPaths*N\n" +
	" PrepareSnapshotBackupRequestType\x12\x0f\n" +
	"\vUpdateLease\x10\x00\x12\r\n" +
	"\tWaitApply\x10\x01\x12\n" +
	"\n" +
	"\x06Finish\x10\x02*J\n" +
	"\x1ePrepareSnapshotBackupEventType\x12\x11\n" +
	"\rWaitApplyDone\x10\x00\x12\x15\n" +
	"\x11UpdateLeaseResult\x10\x01*=\n" +
	"\x0fCompressionType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\a\n" +
	"\x03LZ4\x10\x01\x12\n" +
	"\n" +
	"\x06SNAPPY\x10\x02\x12\b\n" +
	"\x04ZSTD\x10\x03* \n" +
	"\n" +
	"BackupMode\x12\b\n" +
	"\x04SCAN\x10\x00\x12\b\n" +
	"\x04FILE\x10\x01*\x1d\n" +
	"\vMetaVersion\x12\x06\n" +
	"\x02V1\x10\x00\x12\x06\n" +
	"\x02V2\x10\x01*\x1f\n" +
	"\bFileType\x12\n" +
	"\n" +
	"\x06Delete\x10\x00\x12\a\n" +
	"\x03Put\x10\x01**\n" +
	"\x10MigrationVersion\x12\x06\n" +
	"\x02M0\x10\x00\x12\x06\n" +
	"\x02M1\x10\x01\x12\x06\n" +
	"\x02M2\x10\x022\xfd\x02\n" +
	"\x06Backup\x12;\n" +
	"\x06backup\x12\x15.backup.BackupRequest\x1a\x16.backup.BackupResponse\"\x000\x01\x12P\n" +
	"\x13CheckPendingAdminOp\x12\x19.backup.CheckAdminRequest\x1a\x1a.backup.CheckAdminResponse\"\x000\x01\x12h\n" +
	"\x15PrepareSnapshotBackup\x12$.backup.PrepareSnapshotBackupRequest\x1a%.backup.PrepareSnapshotBackupResponse(\x010\x01\x12<\n" +
	"\aprepare\x12\x16.backup.PrepareRequest\x1a\x17.backup.PrepareResponse\"\x00\x12<\n" +
	"\acleanup\x12\x16.backup.CleanupRequest\x1a\x17.backup.CleanupResponse\"\x002\xc0\x01\n" +
	"\x0fExternalStorage\x12Z\n" +
	"\arestore\x12%.backup.ExternalStorageRestoreRequest\x1a&.backup.ExternalStorageRestoreResponse\"\x00\x12Q\n" +
	"\x04save\x12\".backup.ExternalStorageSaveRequest\x1a#.backup.ExternalStorageSaveResponse\"\x00B\x16\b\x01\n" +
	"\x10org.tikv.kvprotob\x06proto3"

var (
	file_brpb_proto_rawDescOnce sync.Once
	file_brpb_proto_rawDescData []byte
)

func file_brpb_proto_rawDescGZIP() []byte {
	file_brpb_proto_rawDescOnce.Do(func() {
		file_brpb_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_brpb_proto_rawDesc), len(file_brpb_proto_rawDesc)))
	})
	return file_brpb_proto_rawDescData
}

var file_brpb_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_brpb_proto_msgTypes = make([]protoimpl.MessageInfo, 63)
var file_brpb_proto_goTypes = []any{
	(PrepareSnapshotBackupRequestType)(0),   // 0: backup.PrepareSnapshotBackupRequestType
	(PrepareSnapshotBackupEventType)(0),     // 1: backup.PrepareSnapshotBackupEventType
	(CompressionType)(0),                    // 2: backup.CompressionType
	(BackupMode)(0),                         // 3: backup.BackupMode
	(MetaVersion)(0),                        // 4: backup.MetaVersion
	(FileType)(0),                           // 5: backup.FileType
	(MigrationVersion)(0),                   // 6: backup.MigrationVersion
	(*PrepareSnapshotBackupRequest)(nil),    // 7: backup.PrepareSnapshotBackupRequest
	(*PrepareSnapshotBackupResponse)(nil),   // 8: backup.PrepareSnapshotBackupResponse
	(*BackupMeta)(nil),                      // 9: backup.BackupMeta
	(*BackupRange)(nil),                     // 10: backup.BackupRange
	(*TableMeta)(nil),                       // 11: backup.TableMeta
	(*File)(nil),                            // 12: backup.File
	(*MetaFile)(nil),                        // 13: backup.MetaFile
	(*PlacementPolicy)(nil),                 // 14: backup.PlacementPolicy
	(*StatsBlock)(nil),                      // 15: backup.StatsBlock
	(*StatsFile)(nil),                       // 16: backup.StatsFile
	(*StatsFileIndex)(nil),                  // 17: backup.StatsFileIndex
	(*Schema)(nil),                          // 18: backup.Schema
	(*IDMap)(nil),                           // 19: backup.IDMap
	(*PitrTableMap)(nil),                    // 20: backup.PitrTableMap
	(*PitrDBMap)(nil),                       // 21: backup.PitrDBMap
	(*RawRange)(nil),                        // 22: backup.RawRange
	(*ClusterIDError)(nil),                  // 23: backup.ClusterIDError
	(*Error)(nil),                           // 24: backup.Error
	(*StreamBackupTaskSecurityConfig)(nil),  // 25: backup.StreamBackupTaskSecurityConfig
	(*CipherInfo)(nil),                      // 26: backup.CipherInfo
	(*MasterKeyConfig)(nil),                 // 27: backup.MasterKeyConfig
	(*SortedSubRanges)(nil),                 // 28: backup.SortedSubRanges
	(*BackupRequest)(nil),                   // 29: backup.BackupRequest
	(*StreamBackupTaskInfo)(nil),            // 30: backup.StreamBackupTaskInfo
	(*StorageBackend)(nil),                  // 31: backup.StorageBackend
	(*Noop)(nil),                            // 32: backup.Noop
	(*Local)(nil),                           // 33: backup.Local
	(*S3)(nil),                              // 34: backup.S3
	(*GCS)(nil),                             // 35: backup.GCS
	(*AzureCustomerKey)(nil),                // 36: backup.AzureCustomerKey
	(*AzureBlobStorage)(nil),                // 37: backup.AzureBlobStorage
	(*Bucket)(nil),                          // 38: backup.Bucket
	(*CloudDynamic)(nil),                    // 39: backup.CloudDynamic
	(*HDFS)(nil),                            // 40: backup.HDFS
	(*BackupResponse)(nil),                  // 41: backup.BackupResponse
	(*CleanupRequest)(nil),                  // 42: backup.CleanupRequest
	(*CleanupResponse)(nil),                 // 43: backup.CleanupResponse
	(*PrepareRequest)(nil),                  // 44: backup.PrepareRequest
	(*PrepareResponse)(nil),                 // 45: backup.PrepareResponse
	(*CheckAdminRequest)(nil),               // 46: backup.CheckAdminRequest
	(*CheckAdminResponse)(nil),              // 47: backup.CheckAdminResponse
	(*ExternalStorageRestoreRequest)(nil),   // 48: backup.ExternalStorageRestoreRequest
	(*ExternalStorageRestoreResponse)(nil),  // 49: backup.ExternalStorageRestoreResponse
	(*ExternalStorageSaveRequest)(nil),      // 50: backup.ExternalStorageSaveRequest
	(*ExternalStorageSaveResponse)(nil),     // 51: backup.ExternalStorageSaveResponse
	(*Metadata)(nil),                        // 52: backup.Metadata
	(*DataFileGroup)(nil),                   // 53: backup.DataFileGroup
	(*DataFileInfo)(nil),                    // 54: backup.DataFileInfo
	(*StreamBackupError)(nil),               // 55: backup.StreamBackupError
	(*Span)(nil),                            // 56: backup.Span
	(*SpansOfFile)(nil),                     // 57: backup.SpansOfFile
	(*LogFileSubcompactionMeta)(nil),        // 58: backup.LogFileSubcompactionMeta
	(*LogFileSubcompaction)(nil),            // 59: backup.LogFileSubcompaction
	(*RegionMetaHint)(nil),                  // 60: backup.RegionMetaHint
	(*LogFileSubcompactions)(nil),           // 61: backup.LogFileSubcompactions
	(*LogFileCompaction)(nil),               // 62: backup.LogFileCompaction
	(*MetaEdit)(nil),                        // 63: backup.MetaEdit
	(*RewrittenTableID)(nil),                // 64: backup.RewrittenTableID
	(*IngestedSSTs)(nil),                    // 65: backup.IngestedSSTs
	(*DeleteSpansOfFile)(nil),               // 66: backup.DeleteSpansOfFile
	(*Migration)(nil),                       // 67: backup.Migration
	nil,                                     // 68: backup.Schema.PartitionMergeOptionAllowedEntry
	nil,                                     // 69: backup.CloudDynamic.AttrsEntry
	(*metapb.Region)(nil),                   // 70: metapb.Region
	(*errorpb.Error)(nil),                   // 71: errorpb.Error
	(kvrpcpb.APIVersion)(0),                 // 72: kvrpcpb.APIVersion
	(*kvrpcpb.KeyError)(nil),                // 73: kvrpcpb.KeyError
	(encryptionpb.EncryptionMethod)(0),      // 74: encryptionpb.EncryptionMethod
	(*encryptionpb.MasterKey)(nil),          // 75: encryptionpb.MasterKey
	(*kvrpcpb.KeyRange)(nil),                // 76: kvrpcpb.KeyRange
	(*kvrpcpb.Context)(nil),                 // 77: kvrpcpb.Context
	(*metapb.RegionEpoch)(nil),              // 78: metapb.RegionEpoch
	(*encryptionpb.FileEncryptionInfo)(nil), // 79: encryptionpb.FileEncryptionInfo
}
var file_brpb_proto_depIdxs = []int32{
	0,   // 0: backup.PrepareSnapshotBackupRequest.ty:type_name -> backup.PrepareSnapshotBackupRequestType
	70,  // 1: backup.PrepareSnapshotBackupRequest.regions:type_name -> metapb.Region
	1,   // 2: backup.PrepareSnapshotBackupResponse.ty:type_name -> backup.PrepareSnapshotBackupEventType
	70,  // 3: backup.PrepareSnapshotBackupResponse.region:type_name -> metapb.Region
	71,  // 4: backup.PrepareSnapshotBackupResponse.error:type_name -> errorpb.Error
	12,  // 5: backup.BackupMeta.files:type_name -> backup.File
	13,  // 6: backup.BackupMeta.file_index:type_name -> backup.MetaFile
	18,  // 7: backup.BackupMeta.schemas:type_name -> backup.Schema
	13,  // 8: backup.BackupMeta.schema_index:type_name -> backup.MetaFile
	22,  // 9: backup.BackupMeta.raw_ranges:type_name -> backup.RawRange
	13,  // 10: backup.BackupMeta.raw_range_index:type_name -> backup.MetaFile
	13,  // 11: backup.BackupMeta.ddl_indexes:type_name -> backup.MetaFile
	72,  // 12: backup.BackupMeta.api_version:type_name -> kvrpcpb.APIVersion
	14,  // 13: backup.BackupMeta.policies:type_name -> backup.PlacementPolicy
	21,  // 14: backup.BackupMeta.db_maps:type_name -> backup.PitrDBMap
	3,   // 15: backup.BackupMeta.mode:type_name -> backup.BackupMode
	10,  // 16: backup.BackupMeta.ranges:type_name -> backup.BackupRange
	12,  // 17: backup.BackupRange.files:type_name -> backup.File
	11,  // 18: backup.File.table_metas:type_name -> backup.TableMeta
	12,  // 19: backup.MetaFile.meta_files:type_name -> backup.File
	12,  // 20: backup.MetaFile.data_files:type_name -> backup.File
	18,  // 21: backup.MetaFile.schemas:type_name -> backup.Schema
	22,  // 22: backup.MetaFile.raw_ranges:type_name -> backup.RawRange
	10,  // 23: backup.MetaFile.backup_ranges:type_name -> backup.BackupRange
	15,  // 24: backup.StatsFile.blocks:type_name -> backup.StatsBlock
	17,  // 25: backup.Schema.stats_index:type_name -> backup.StatsFileIndex
	68,  // 26: backup.Schema.partition_merge_option_allowed:type_name -> backup.Schema.PartitionMergeOptionAllowedEntry
	19,  // 27: backup.PitrTableMap.id_map:type_name -> backup.IDMap
	19,  // 28: backup.PitrTableMap.partitions:type_name -> backup.IDMap
	19,  // 29: backup.PitrDBMap.id_map:type_name -> backup.IDMap
	20,  // 30: backup.PitrDBMap.tables:type_name -> backup.PitrTableMap
	23,  // 31: backup.Error.cluster_id_error:type_name -> backup.ClusterIDError
	73,  // 32: backup.Error.kv_error:type_name -> kvrpcpb.KeyError
	71,  // 33: backup.Error.region_error:type_name -> errorpb.Error
	26,  // 34: backup.StreamBackupTaskSecurityConfig.plaintext_data_key:type_name -> backup.CipherInfo
	27,  // 35: backup.StreamBackupTaskSecurityConfig.master_key_config:type_name -> backup.MasterKeyConfig
	74,  // 36: backup.CipherInfo.cipher_type:type_name -> encryptionpb.EncryptionMethod
	74,  // 37: backup.MasterKeyConfig.encryption_type:type_name -> encryptionpb.EncryptionMethod
	75,  // 38: backup.MasterKeyConfig.master_keys:type_name -> encryptionpb.MasterKey
	76,  // 39: backup.SortedSubRanges.sub_ranges:type_name -> kvrpcpb.KeyRange
	31,  // 40: backup.BackupRequest.storage_backend:type_name -> backup.StorageBackend
	2,   // 41: backup.BackupRequest.compression_type:type_name -> backup.CompressionType
	26,  // 42: backup.BackupRequest.cipher_info:type_name -> backup.CipherInfo
	72,  // 43: backup.BackupRequest.dst_api_version:type_name -> kvrpcpb.APIVersion
	76,  // 44: backup.BackupRequest.sub_ranges:type_name -> kvrpcpb.KeyRange
	28,  // 45: backup.BackupRequest.sorted_sub_ranges_groups:type_name -> backup.SortedSubRanges
	3,   // 46: backup.BackupRequest.mode:type_name -> backup.BackupMode
	77,  // 47: backup.BackupRequest.context:type_name -> kvrpcpb.Context
	31,  // 48: backup.StreamBackupTaskInfo.storage:type_name -> backup.StorageBackend
	2,   // 49: backup.StreamBackupTaskInfo.compression_type:type_name -> backup.CompressionType
	25,  // 50: backup.StreamBackupTaskInfo.security_config:type_name -> backup.StreamBackupTaskSecurityConfig
	32,  // 51: backup.StorageBackend.noop:type_name -> backup.Noop
	33,  // 52: backup.StorageBackend.local:type_name -> backup.Local
	34,  // 53: backup.StorageBackend.s3:type_name -> backup.S3
	35,  // 54: backup.StorageBackend.gcs:type_name -> backup.GCS
	39,  // 55: backup.StorageBackend.cloud_dynamic:type_name -> backup.CloudDynamic
	40,  // 56: backup.StorageBackend.hdfs:type_name -> backup.HDFS
	37,  // 57: backup.StorageBackend.azure_blob_storage:type_name -> backup.AzureBlobStorage
	36,  // 58: backup.AzureBlobStorage.encryption_key:type_name -> backup.AzureCustomerKey
	38,  // 59: backup.CloudDynamic.bucket:type_name -> backup.Bucket
	69,  // 60: backup.CloudDynamic.attrs:type_name -> backup.CloudDynamic.AttrsEntry
	24,  // 61: backup.BackupResponse.error:type_name -> backup.Error
	12,  // 62: backup.BackupResponse.files:type_name -> backup.File
	72,  // 63: backup.BackupResponse.api_version:type_name -> kvrpcpb.APIVersion
	24,  // 64: backup.CleanupResponse.error:type_name -> backup.Error
	24,  // 65: backup.PrepareResponse.error:type_name -> backup.Error
	24,  // 66: backup.CheckAdminResponse.error:type_name -> backup.Error
	70,  // 67: backup.CheckAdminResponse.region:type_name -> metapb.Region
	31,  // 68: backup.ExternalStorageRestoreRequest.storage_backend:type_name -> backup.StorageBackend
	31,  // 69: backup.ExternalStorageSaveRequest.storage_backend:type_name -> backup.StorageBackend
	54,  // 70: backup.Metadata.files:type_name -> backup.DataFileInfo
	53,  // 71: backup.Metadata.file_groups:type_name -> backup.DataFileGroup
	4,   // 72: backup.Metadata.meta_version:type_name -> backup.MetaVersion
	54,  // 73: backup.DataFileGroup.data_files_info:type_name -> backup.DataFileInfo
	5,   // 74: backup.DataFileInfo.type:type_name -> backup.FileType
	2,   // 75: backup.DataFileInfo.compression_type:type_name -> backup.CompressionType
	78,  // 76: backup.DataFileInfo.region_epoch:type_name -> metapb.RegionEpoch
	79,  // 77: backup.DataFileInfo.file_encryption_info:type_name -> encryptionpb.FileEncryptionInfo
	56,  // 78: backup.SpansOfFile.spans:type_name -> backup.Span
	5,   // 79: backup.LogFileSubcompactionMeta.ty:type_name -> backup.FileType
	57,  // 80: backup.LogFileSubcompactionMeta.sources:type_name -> backup.SpansOfFile
	58,  // 81: backup.LogFileSubcompaction.meta:type_name -> backup.LogFileSubcompactionMeta
	12,  // 82: backup.LogFileSubcompaction.sst_outputs:type_name -> backup.File
	60,  // 83: backup.LogFileSubcompaction.region_meta_hints:type_name -> backup.RegionMetaHint
	78,  // 84: backup.RegionMetaHint.region_epoch:type_name -> metapb.RegionEpoch
	59,  // 85: backup.LogFileSubcompactions.subcompactions:type_name -> backup.LogFileSubcompaction
	66,  // 86: backup.MetaEdit.delete_logical_files:type_name -> backup.DeleteSpansOfFile
	64,  // 87: backup.IngestedSSTs.rewritten_tables:type_name -> backup.RewrittenTableID
	12,  // 88: backup.IngestedSSTs.files:type_name -> backup.File
	56,  // 89: backup.DeleteSpansOfFile.spans:type_name -> backup.Span
	6,   // 90: backup.Migration.version:type_name -> backup.MigrationVersion
	63,  // 91: backup.Migration.edit_meta:type_name -> backup.MetaEdit
	62,  // 92: backup.Migration.compactions:type_name -> backup.LogFileCompaction
	29,  // 93: backup.Backup.backup:input_type -> backup.BackupRequest
	46,  // 94: backup.Backup.CheckPendingAdminOp:input_type -> backup.CheckAdminRequest
	7,   // 95: backup.Backup.PrepareSnapshotBackup:input_type -> backup.PrepareSnapshotBackupRequest
	44,  // 96: backup.Backup.prepare:input_type -> backup.PrepareRequest
	42,  // 97: backup.Backup.cleanup:input_type -> backup.CleanupRequest
	48,  // 98: backup.ExternalStorage.restore:input_type -> backup.ExternalStorageRestoreRequest
	50,  // 99: backup.ExternalStorage.save:input_type -> backup.ExternalStorageSaveRequest
	41,  // 100: backup.Backup.backup:output_type -> backup.BackupResponse
	47,  // 101: backup.Backup.CheckPendingAdminOp:output_type -> backup.CheckAdminResponse
	8,   // 102: backup.Backup.PrepareSnapshotBackup:output_type -> backup.PrepareSnapshotBackupResponse
	45,  // 103: backup.Backup.prepare:output_type -> backup.PrepareResponse
	43,  // 104: backup.Backup.cleanup:output_type -> backup.CleanupResponse
	49,  // 105: backup.ExternalStorage.restore:output_type -> backup.ExternalStorageRestoreResponse
	51,  // 106: backup.ExternalStorage.save:output_type -> backup.ExternalStorageSaveResponse
	100, // [100:107] is the sub-list for method output_type
	93,  // [93:100] is the sub-list for method input_type
	93,  // [93:93] is the sub-list for extension type_name
	93,  // [93:93] is the sub-list for extension extendee
	0,   // [0:93] is the sub-list for field type_name
}

func init() { file_brpb_proto_init() }
func file_brpb_proto_init() {
	if File_brpb_proto != nil {
		return
	}
	file_brpb_proto_msgTypes[17].OneofWrappers = []any{
		(*Error_ClusterIdError)(nil),
		(*Error_KvError)(nil),
		(*Error_RegionError)(nil),
	}
	file_brpb_proto_msgTypes[18].OneofWrappers = []any{
		(*StreamBackupTaskSecurityConfig_PlaintextDataKey)(nil),
		(*StreamBackupTaskSecurityConfig_MasterKeyConfig)(nil),
	}
	file_brpb_proto_msgTypes[24].OneofWrappers = []any{
		(*StorageBackend_Noop)(nil),
		(*StorageBackend_Local)(nil),
		(*StorageBackend_S3)(nil),
		(*StorageBackend_Gcs)(nil),
		(*StorageBackend_CloudDynamic)(nil),
		(*StorageBackend_Hdfs)(nil),
		(*StorageBackend_AzureBlobStorage)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_brpb_proto_rawDesc), len(file_brpb_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   63,
			NumExtensions: 0,
			NumServices:   2,
		},
		GoTypes:           file_brpb_proto_goTypes,
		DependencyIndexes: file_brpb_proto_depIdxs,
		EnumInfos:         file_brpb_proto_enumTypes,
		MessageInfos:      file_brpb_proto_msgTypes,
	}.Build()
	File_brpb_proto = out.File
	file_brpb_proto_goTypes = nil
	file_brpb_proto_depIdxs = nil
}
